

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[14:57:56] Loaded 10 rules                                                                                                                                                                                                                  tasks.py:119
[12/08/24 14:57:56] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0xd33526068d116ce69f19a9ee46f0bd304f21a51f_eth)                                                 subprocess.py:41
[12/08/24 14:57:58] INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0xd33526068d116ce69f19a9ee46f0bd304f21a51f_eth)                                        subprocess.py:41
[12/08/24 14:58:00] INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0xd33526068d116ce69f19a9ee46f0bd304f21a51f_eth)                                       subprocess.py:41
[14:58:01] Traceback (most recent call last):                                                                                                                                                                                               tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                                                          
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                                                         
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                                                         
               self._compile(**kwargs)                                                                                                                                                                                                                  
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                                                         
               self._platform.compile(self, **kwargs)                                                                                                                                                                                                   
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 183, in compile                                                                                        
               hardhat_like_parsing(crytic_compile, self._target, build_directory, hardhat_working_dir)                                                                                                                                                 
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 52, in hardhat_like_parsing                                                                            
               raise InvalidCompilation(txt)                                                                                                                                                                                                            
           crytic_compile.platform.exceptions.InvalidCompilation: Compilation failed. Can you run build command?                                                                                                                                        
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0xd33526068d116ce69f19a9ee46f0bd304f21a51f_eth/artifacts/build-info is not a directory.                                                                                           
                                                                                                                                                                                                                                                        
           During handling of the above exception, another exception occurred:                                                                                                                                                                          
                                                                                                                                                                                                                                                        
           Traceback (most recent call last):                                                                                                                                                                                                           
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                                                              
               falcon_instance = compile_project(source_dir)                                                                                                                                                                                            
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                                                         
               return falcon.Falcon(abs_path)                                                                                                                                                                                                           
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                                                          
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                                                                    
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                                                          
           Compilation failed. Can you run build command?                                                                                                                                                                                               
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0xd33526068d116ce69f19a9ee46f0bd304f21a51f_eth/artifacts/build-info is not a directory.                                                                                           
                                                                                                                                                                                                                                                        
           Compile failed.                                                                                                                                                                                                                  tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                                                       tasks.py:128
[12/08/24 14:58:02] INFO     antlr4helper.callgraph: In whitelist: SafeMath.tryAdd(uint,uint) returns(bool,uint)                                                                                                                         callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: SafeMath.tryMul(uint,uint) returns(bool,uint)                                                                                                                         callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: SafeMath.add(uint,uint) returns(uint)                                                                                                                                 callgraph.py:21
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                               │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _inflationCalculate(uint256 _intervalsSinceLastMint) private view returns (uint256) {                                                                                                                                                   │
│         // The inflation amount                                                                                                                                                                                                                      │
│         uint256 inflationTokenAmount = 0;                                                                                                                                                                                                            │
│         // Only update  if last interval has passed and inflation rate is > 0                                                                                                                                                                        │
│         if(_intervalsSinceLastMint > 0) {                                                                                                                                                                                                            │
│             // Optimisation                                                                                                                                                                                                                          │
│             uint256 inflationRate = getInflationIntervalRate();                                                                                                                                                                                      │
│             if(inflationRate > 0) {                                                                                                                                                                                                                  │
│                 // Get the total supply now                                                                                                                                                                                                          │
│                 uint256 totalSupplyCurrent = totalSupply();                                                                                                                                                                                          │
│                 uint256 newTotalSupply = totalSupplyCurrent;                                                                                                                                                                                         │
│                 // Compute inflation for total inflation intervals elapsed                                                                                                                                                                           │
│                 for (uint256 i = 0; i < _intervalsSinceLastMint; i++) {                                                                                                                                                                              │
│                     newTotalSupply = newTotalSupply.mul(inflationRate).div(10**18);                                                                                                                                                                  │
│                 }                                                                                                                                                                                                                                    │
│                 // Return inflation amount                                                                                                                                                                                                           │
│                 inflationTokenAmount = newTotalSupply.sub(totalSupplyCurrent);                                                                                                                                                                       │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         // Done                                                                                                                                                                                                                                      │
│         return inflationTokenAmount;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes", "3": "No"}                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                           │
│ Code:                                                                                                                                                                                                                                                │
│     function _inflationCalculate(uint256 _intervalsSinceLastMint) private view returns (uint256) {                                                                                                                                                   │
│         // The inflation amount                                                                                                                                                                                                                      │
│         uint256 inflationTokenAmount = 0;                                                                                                                                                                                                            │
│         // Only update  if last interval has passed and inflation rate is > 0                                                                                                                                                                        │
│         if(_intervalsSinceLastMint > 0) {                                                                                                                                                                                                            │
│             // Optimisation                                                                                                                                                                                                                          │
│             uint256 inflationRate = getInflationIntervalRate();                                                                                                                                                                                      │
│             if(inflationRate > 0) {                                                                                                                                                                                                                  │
│                 // Get the total supply now                                                                                                                                                                                                          │
│                 uint256 totalSupplyCurrent = totalSupply();                                                                                                                                                                                          │
│                 uint256 newTotalSupply = totalSupplyCurrent;                                                                                                                                                                                         │
│                 // Compute inflation for total inflation intervals elapsed                                                                                                                                                                           │
│                 for (uint256 i = 0; i < _intervalsSinceLastMint; i++) {                                                                                                                                                                              │
│                     newTotalSupply = newTotalSupply.mul(inflationRate).div(10**18);                                                                                                                                                                  │
│                 }                                                                                                                                                                                                                                    │
│                 // Return inflation amount                                                                                                                                                                                                           │
│                 inflationTokenAmount = newTotalSupply.sub(totalSupplyCurrent);                                                                                                                                                                       │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         // Done                                                                                                                                                                                                                                      │
│         return inflationTokenAmount;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function inflationMintTokens() override external returns (uint256) {                                                                                                                                                                             │
│         // Only run inflation process if at least 1 interval has passed (function returns 0 otherwise)                                                                                                                                               │
│         uint256 inflationLastCalcTime = getInflationCalcTime();                                                                                                                                                                                      │
│         uint256 intervalsSinceLastMint = _getInflationIntervalsPassed(inflationLastCalcTime);                                                                                                                                                        │
│         if (intervalsSinceLastMint == 0) {                                                                                                                                                                                                           │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│         // Address of the vault where to send tokens                                                                                                                                                                                                 │
│         address rocketVaultAddress = getContractAddress("rocketVault");                                                                                                                                                                              │
│         require(rocketVaultAddress != address(0x0), "rocketVault address not set");                                                                                                                                                                  │
│         // Only mint if we have new tokens to mint since last interval and an address is set to receive them                                                                                                                                         │
│         RocketVaultInterface rocketVaultContract = RocketVaultInterface(rocketVaultAddress);                                                                                                                                                         │
│         // Calculate the amount of tokens now based on inflation rate                                                                                                                                                                                │
│         uint256 newTokens = _inflationCalculate(intervalsSinceLastMint);                                                                                                                                                                             │
│         // Update last inflation calculation timestamp even if inflation rate is 0                                                                                                                                                                   │
│         inflationCalcTime = inflationLastCalcTime.add(inflationInterval.mul(intervalsSinceLastMint));                                                                                                                                                │
│         // Check if actually need to mint tokens (e.g. inflation rate > 0)                                                                                                                                                                           │
│         if (newTokens > 0) {                                                                                                                                                                                                                         │
│             // Mint to itself, then allocate tokens for transfer to rewards contract, this will update balance & supply                                                                                                                              │
│             _mint(address(this), newTokens);                                                                                                                                                                                                         │
│             // Initialise itself and allow from it's own balance (cant just do an allow as it could be any user calling this so they are msg.sender)                                                                                                 │
│             IERC20 rplInflationContract = IERC20(address(this));                                                                                                                                                                                     │
│             // Get the current allowance for Rocket Vault                                                                                                                                                                                            │
│             uint256 vaultAllowance = rplFixedSupplyContract.allowance(rocketVaultAddress, address(this));                                                                                                                                            │
│             // Now allow Rocket Vault to move those tokens, we also need to account of any other allowances for this token from other contracts in the same block                                                                                    │
│             require(rplInflationContract.approve(rocketVaultAddress, vaultAllowance.add(newTokens)), "Allowance for Rocket Vault could not be approved");                                                                                            │
│             // Let vault know it can move these tokens to itself now and credit the balance to the RPL rewards pool contract                                                                                                                         │
│             rocketVaultContract.depositToken("rocketRewardsPool", IERC20(address(this)), newTokens);                                                                                                                                                 │
│         }                                                                                                                                                                                                                                            │
│         // Log it                                                                                                                                                                                                                                    │
│         emit RPLInflationLog(msg.sender, newTokens, inflationCalcTime);                                                                                                                                                                              │
│         // return number minted                                                                                                                                                                                                                      │
│         return newTokens;                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _inflationCalculate(uint256 _intervalsSinceLastMint) private view returns (uint256) {                                                                                                                                                   │
│         // The inflation amount                                                                                                                                                                                                                      │
│         uint256 inflationTokenAmount = 0;                                                                                                                                                                                                            │
│         // Only update  if last interval has passed and inflation rate is > 0                                                                                                                                                                        │
│         if(_intervalsSinceLastMint > 0) {                                                                                                                                                                                                            │
│             // Optimisation                                                                                                                                                                                                                          │
│             uint256 inflationRate = getInflationIntervalRate();                                                                                                                                                                                      │
│             if(inflationRate > 0) {                                                                                                                                                                                                                  │
│                 // Get the total supply now                                                                                                                                                                                                          │
│                 uint256 totalSupplyCurrent = totalSupply();                                                                                                                                                                                          │
│                 uint256 newTotalSupply = totalSupplyCurrent;                                                                                                                                                                                         │
│                 // Compute inflation for total inflation intervals elapsed                                                                                                                                                                           │
│                 for (uint256 i = 0; i < _intervalsSinceLastMint; i++) {                                                                                                                                                                              │
│                     newTotalSupply = newTotalSupply.mul(inflationRate).div(10**18);                                                                                                                                                                  │
│                 }                                                                                                                                                                                                                                    │
│                 // Return inflation amount                                                                                                                                                                                                           │
│                 inflationTokenAmount = newTotalSupply.sub(totalSupplyCurrent);                                                                                                                                                                       │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         // Done                                                                                                                                                                                                                                      │
│         return inflationTokenAmount;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function inflationMintTokens() override external returns (uint256) {                                                                                                                                                                             │
│         // Only run inflation process if at least 1 interval has passed (function returns 0 otherwise)                                                                                                                                               │
│         uint256 inflationLastCalcTime = getInflationCalcTime();                                                                                                                                                                                      │
│         uint256 intervalsSinceLastMint = _getInflationIntervalsPassed(inflationLastCalcTime);                                                                                                                                                        │
│         if (intervalsSinceLastMint == 0) {                                                                                                                                                                                                           │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│         // Address of the vault where to send tokens                                                                                                                                                                                                 │
│         address rocketVaultAddress = getContractAddress("rocketVault");                                                                                                                                                                              │
│         require(rocketVaultAddress != address(0x0), "rocketVault address not set");                                                                                                                                                                  │
│         // Only mint if we have new tokens to mint since last interval and an address is set to receive them                                                                                                                                         │
│         RocketVaultInterface rocketVaultContract = RocketVaultInterface(rocketVaultAddress);                                                                                                                                                         │
│         // Calculate the amount of tokens now based on inflation rate                                                                                                                                                                                │
│         uint256 newTokens = _inflationCalculate(intervalsSinceLastMint);                                                                                                                                                                             │
│         // Update last inflation calculation timestamp even if inflation rate is 0                                                                                                                                                                   │
│         inflationCalcTime = inflationLastCalcTime.add(inflationInterval.mul(intervalsSinceLastMint));                                                                                                                                                │
│         // Check if actually need to mint tokens (e.g. inflation rate > 0)                                                                                                                                                                           │
│         if (newTokens > 0) {                                                                                                                                                                                                                         │
│             // Mint to itself, then allocate tokens for transfer to rewards contract, this will update balance & supply                                                                                                                              │
│             _mint(address(this), newTokens);                                                                                                                                                                                                         │
│             // Initialise itself and allow from it's own balance (cant just do an allow as it could be any user calling this so they are msg.sender)                                                                                                 │
│             IERC20 rplInflationContract = IERC20(address(this));                                                                                                                                                                                     │
│             // Get the current allowance for Rocket Vault                                                                                                                                                                                            │
│             uint256 vaultAllowance = rplFixedSupplyContract.allowance(rocketVaultAddress, address(this));                                                                                                                                            │
│             // Now allow Rocket Vault to move those tokens, we also need to account of any other allowances for this token from other contracts in the same block                                                                                    │
│             require(rplInflationContract.approve(rocketVaultAddress, vaultAllowance.add(newTokens)), "Allowance for Rocket Vault could not be approved");                                                                                            │
│             // Let vault know it can move these tokens to itself now and credit the balance to the RPL rewards pool contract                                                                                                                         │
│             rocketVaultContract.depositToken("rocketRewardsPool", IERC20(address(this)), newTokens);                                                                                                                                                 │
│         }                                                                                                                                                                                                                                            │
│         // Log it                                                                                                                                                                                                                                    │
│         emit RPLInflationLog(msg.sender, newTokens, inflationCalcTime);                                                                                                                                                                              │
│         // return number minted                                                                                                                                                                                                                      │
│         return newTokens;                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _inflationCalculate(uint256 _intervalsSinceLastMint) private view returns (uint256) {                                                                                                                                                   │
│         // The inflation amount                                                                                                                                                                                                                      │
│         uint256 inflationTokenAmount = 0;                                                                                                                                                                                                            │
│         // Only update  if last interval has passed and inflation rate is > 0                                                                                                                                                                        │
│         if(_intervalsSinceLastMint > 0) {                                                                                                                                                                                                            │
│             // Optimisation                                                                                                                                                                                                                          │
│             uint256 inflationRate = getInflationIntervalRate();                                                                                                                                                                                      │
│             if(inflationRate > 0) {                                                                                                                                                                                                                  │
│                 // Get the total supply now                                                                                                                                                                                                          │
│                 uint256 totalSupplyCurrent = totalSupply();                                                                                                                                                                                          │
│                 uint256 newTotalSupply = totalSupplyCurrent;                                                                                                                                                                                         │
│                 // Compute inflation for total inflation intervals elapsed                                                                                                                                                                           │
│                 for (uint256 i = 0; i < _intervalsSinceLastMint; i++) {                                                                                                                                                                              │
│                     newTotalSupply = newTotalSupply.mul(inflationRate).div(10**18);                                                                                                                                                                  │
│                 }                                                                                                                                                                                                                                    │
│                 // Return inflation amount                                                                                                                                                                                                           │
│                 inflationTokenAmount = newTotalSupply.sub(totalSupplyCurrent);                                                                                                                                                                       │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         // Done                                                                                                                                                                                                                                      │
│         return inflationTokenAmount;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function inflationMintTokens() override external returns (uint256) {                                                                                                                                                                             │
│         // Only run inflation process if at least 1 interval has passed (function returns 0 otherwise)                                                                                                                                               │
│         uint256 inflationLastCalcTime = getInflationCalcTime();                                                                                                                                                                                      │
│         uint256 intervalsSinceLastMint = _getInflationIntervalsPassed(inflationLastCalcTime);                                                                                                                                                        │
│         if (intervalsSinceLastMint == 0) {                                                                                                                                                                                                           │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│         // Address of the vault where to send tokens                                                                                                                                                                                                 │
│         address rocketVaultAddress = getContractAddress("rocketVault");                                                                                                                                                                              │
│         require(rocketVaultAddress != address(0x0), "rocketVault address not set");                                                                                                                                                                  │
│         // Only mint if we have new tokens to mint since last interval and an address is set to receive them                                                                                                                                         │
│         RocketVaultInterface rocketVaultContract = RocketVaultInterface(rocketVaultAddress);                                                                                                                                                         │
│         // Calculate the amount of tokens now based on inflation rate                                                                                                                                                                                │
│         uint256 newTokens = _inflationCalculate(intervalsSinceLastMint);                                                                                                                                                                             │
│         // Update last inflation calculation timestamp even if inflation rate is 0                                                                                                                                                                   │
│         inflationCalcTime = inflationLastCalcTime.add(inflationInterval.mul(intervalsSinceLastMint));                                                                                                                                                │
│         // Check if actually need to mint tokens (e.g. inflation rate > 0)                                                                                                                                                                           │
│         if (newTokens > 0) {                                                                                                                                                                                                                         │
│             // Mint to itself, then allocate tokens for transfer to rewards contract, this will update balance & supply                                                                                                                              │
│             _mint(address(this), newTokens);                                                                                                                                                                                                         │
│             // Initialise itself and allow from it's own balance (cant just do an allow as it could be any user calling this so they are msg.sender)                                                                                                 │
│             IERC20 rplInflationContract = IERC20(address(this));                                                                                                                                                                                     │
│             // Get the current allowance for Rocket Vault                                                                                                                                                                                            │
│             uint256 vaultAllowance = rplFixedSupplyContract.allowance(rocketVaultAddress, address(this));                                                                                                                                            │
│             // Now allow Rocket Vault to move those tokens, we also need to account of any other allowances for this token from other contracts in the same block                                                                                    │
│             require(rplInflationContract.approve(rocketVaultAddress, vaultAllowance.add(newTokens)), "Allowance for Rocket Vault could not be approved");                                                                                            │
│             // Let vault know it can move these tokens to itself now and credit the balance to the RPL rewards pool contract                                                                                                                         │
│             rocketVaultContract.depositToken("rocketRewardsPool", IERC20(address(this)), newTokens);                                                                                                                                                 │
│         }                                                                                                                                                                                                                                            │
│         // Log it                                                                                                                                                                                                                                    │
│         emit RPLInflationLog(msg.sender, newTokens, inflationCalcTime);                                                                                                                                                                              │
│         // return number minted                                                                                                                                                                                                                      │
│         return newTokens;                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                           │
│ Code:                                                                                                                                                                                                                                                │
│     function inflationMintTokens() override external returns (uint256) {                                                                                                                                                                             │
│         // Only run inflation process if at least 1 interval has passed (function returns 0 otherwise)                                                                                                                                               │
│         uint256 inflationLastCalcTime = getInflationCalcTime();                                                                                                                                                                                      │
│         uint256 intervalsSinceLastMint = _getInflationIntervalsPassed(inflationLastCalcTime);                                                                                                                                                        │
│         if (intervalsSinceLastMint == 0) {                                                                                                                                                                                                           │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│         // Address of the vault where to send tokens                                                                                                                                                                                                 │
│         address rocketVaultAddress = getContractAddress("rocketVault");                                                                                                                                                                              │
│         require(rocketVaultAddress != address(0x0), "rocketVault address not set");                                                                                                                                                                  │
│         // Only mint if we have new tokens to mint since last interval and an address is set to receive them                                                                                                                                         │
│         RocketVaultInterface rocketVaultContract = RocketVaultInterface(rocketVaultAddress);                                                                                                                                                         │
│         // Calculate the amount of tokens now based on inflation rate                                                                                                                                                                                │
│         uint256 newTokens = _inflationCalculate(intervalsSinceLastMint);                                                                                                                                                                             │
│         // Update last inflation calculation timestamp even if inflation rate is 0                                                                                                                                                                   │
│         inflationCalcTime = inflationLastCalcTime.add(inflationInterval.mul(intervalsSinceLastMint));                                                                                                                                                │
│         // Check if actually need to mint tokens (e.g. inflation rate > 0)                                                                                                                                                                           │
│         if (newTokens > 0) {                                                                                                                                                                                                                         │
│             // Mint to itself, then allocate tokens for transfer to rewards contract, this will update balance & supply                                                                                                                              │
│             _mint(address(this), newTokens);                                                                                                                                                                                                         │
│             // Initialise itself and allow from it's own balance (cant just do an allow as it could be any user calling this so they are msg.sender)                                                                                                 │
│             IERC20 rplInflationContract = IERC20(address(this));                                                                                                                                                                                     │
│             // Get the current allowance for Rocket Vault                                                                                                                                                                                            │
│             uint256 vaultAllowance = rplFixedSupplyContract.allowance(rocketVaultAddress, address(this));                                                                                                                                            │
│             // Now allow Rocket Vault to move those tokens, we also need to account of any other allowances for this token from other contracts in the same block                                                                                    │
│             require(rplInflationContract.approve(rocketVaultAddress, vaultAllowance.add(newTokens)), "Allowance for Rocket Vault could not be approved");                                                                                            │
│             // Let vault know it can move these tokens to itself now and credit the balance to the RPL rewards pool contract                                                                                                                         │
│             rocketVaultContract.depositToken("rocketRewardsPool", IERC20(address(this)), newTokens);                                                                                                                                                 │
│         }                                                                                                                                                                                                                                            │
│         // Log it                                                                                                                                                                                                                                    │
│         emit RPLInflationLog(msg.sender, newTokens, inflationCalcTime);                                                                                                                                                                              │
│         // return number minted                                                                                                                                                                                                                      │
│         return newTokens;                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                          │
│ Code:                                                                                                                                                                                                                                                │
│     function swapTokens(uint256 _amount) override external {                                                                                                                                                                                         │
│         // Valid amount?                                                                                                                                                                                                                             │
│         require(_amount > 0, "Please enter valid amount of RPL to swap");                                                                                                                                                                            │
│         // Send the tokens to this contract now and mint new ones for them                                                                                                                                                                           │
│         require(rplFixedSupplyContract.transferFrom(msg.sender, address(this), _amount), "Token transfer from existing RPL contract was not successful");                                                                                            │
│         // Transfer from the contracts RPL balance to the user                                                                                                                                                                                       │
│         require(this.transfer(msg.sender, _amount), "Token transfer from RPL inflation contract was not successful");                                                                                                                                │
│         // Update the total swapped                                                                                                                                                                                                                  │
│         totalSwappedRPL = totalSwappedRPL.add(_amount);                                                                                                                                                                                              │
│         // Log it                                                                                                                                                                                                                                    │
│         emit RPLFixedSupplyBurn(msg.sender, _amount, block.timestamp);                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _inflationCalculate(uint256 _intervalsSinceLastMint) private view returns (uint256) {                                                                                                                                                   │
│         // The inflation amount                                                                                                                                                                                                                      │
│         uint256 inflationTokenAmount = 0;                                                                                                                                                                                                            │
│         // Only update  if last interval has passed and inflation rate is > 0                                                                                                                                                                        │
│         if(_intervalsSinceLastMint > 0) {                                                                                                                                                                                                            │
│             // Optimisation                                                                                                                                                                                                                          │
│             uint256 inflationRate = getInflationIntervalRate();                                                                                                                                                                                      │
│             if(inflationRate > 0) {                                                                                                                                                                                                                  │
│                 // Get the total supply now                                                                                                                                                                                                          │
│                 uint256 totalSupplyCurrent = totalSupply();                                                                                                                                                                                          │
│                 uint256 newTotalSupply = totalSupplyCurrent;                                                                                                                                                                                         │
│                 // Compute inflation for total inflation intervals elapsed                                                                                                                                                                           │
│                 for (uint256 i = 0; i < _intervalsSinceLastMint; i++) {                                                                                                                                                                              │
│                     newTotalSupply = newTotalSupply.mul(inflationRate).div(10**18);                                                                                                                                                                  │
│                 }                                                                                                                                                                                                                                    │
│                 // Return inflation amount                                                                                                                                                                                                           │
│                 inflationTokenAmount = newTotalSupply.sub(totalSupplyCurrent);                                                                                                                                                                       │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         // Done                                                                                                                                                                                                                                      │
│         return inflationTokenAmount;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `newTotalSupply = newTotalSupply.mul(inflationRate).div(10**18);`                                                                                                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                          │
│ Code:                                                                                                                                                                                                                                                │
│     function _inflationCalculate(uint256 _intervalsSinceLastMint) private view returns (uint256) {                                                                                                                                                   │
│         // The inflation amount                                                                                                                                                                                                                      │
│         uint256 inflationTokenAmount = 0;                                                                                                                                                                                                            │
│         // Only update  if last interval has passed and inflation rate is > 0                                                                                                                                                                        │
│         if(_intervalsSinceLastMint > 0) {                                                                                                                                                                                                            │
│             // Optimisation                                                                                                                                                                                                                          │
│             uint256 inflationRate = getInflationIntervalRate();                                                                                                                                                                                      │
│             if(inflationRate > 0) {                                                                                                                                                                                                                  │
│                 // Get the total supply now                                                                                                                                                                                                          │
│                 uint256 totalSupplyCurrent = totalSupply();                                                                                                                                                                                          │
│                 uint256 newTotalSupply = totalSupplyCurrent;                                                                                                                                                                                         │
│                 // Compute inflation for total inflation intervals elapsed                                                                                                                                                                           │
│                 for (uint256 i = 0; i < _intervalsSinceLastMint; i++) {                                                                                                                                                                              │
│                     newTotalSupply = newTotalSupply.mul(inflationRate).div(10**18);                                                                                                                                                                  │
│                 }                                                                                                                                                                                                                                    │
│                 // Return inflation amount                                                                                                                                                                                                           │
│                 inflationTokenAmount = newTotalSupply.sub(totalSupplyCurrent);                                                                                                                                                                       │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         // Done                                                                                                                                                                                                                                      │
│         return inflationTokenAmount;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 inflationTokenAmount = 0;`                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:58:09] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0xd33526068d116ce69f19a9ee46f0bd304f21a51f_eth/racts/contract/token/RocketTokenRPL.sol, current function: _inflationCalculate, tasks.py:260
                             current vul: wrong-order-interest                                                                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function inflationMintTokens() override external returns (uint256) {                                                                                                                                                                             │
│         // Only run inflation process if at least 1 interval has passed (function returns 0 otherwise)                                                                                                                                               │
│         uint256 inflationLastCalcTime = getInflationCalcTime();                                                                                                                                                                                      │
│         uint256 intervalsSinceLastMint = _getInflationIntervalsPassed(inflationLastCalcTime);                                                                                                                                                        │
│         if (intervalsSinceLastMint == 0) {                                                                                                                                                                                                           │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│         // Address of the vault where to send tokens                                                                                                                                                                                                 │
│         address rocketVaultAddress = getContractAddress("rocketVault");                                                                                                                                                                              │
│         require(rocketVaultAddress != address(0x0), "rocketVault address not set");                                                                                                                                                                  │
│         // Only mint if we have new tokens to mint since last interval and an address is set to receive them                                                                                                                                         │
│         RocketVaultInterface rocketVaultContract = RocketVaultInterface(rocketVaultAddress);                                                                                                                                                         │
│         // Calculate the amount of tokens now based on inflation rate                                                                                                                                                                                │
│         uint256 newTokens = _inflationCalculate(intervalsSinceLastMint);                                                                                                                                                                             │
│         // Update last inflation calculation timestamp even if inflation rate is 0                                                                                                                                                                   │
│         inflationCalcTime = inflationLastCalcTime.add(inflationInterval.mul(intervalsSinceLastMint));                                                                                                                                                │
│         // Check if actually need to mint tokens (e.g. inflation rate > 0)                                                                                                                                                                           │
│         if (newTokens > 0) {                                                                                                                                                                                                                         │
│             // Mint to itself, then allocate tokens for transfer to rewards contract, this will update balance & supply                                                                                                                              │
│             _mint(address(this), newTokens);                                                                                                                                                                                                         │
│             // Initialise itself and allow from it's own balance (cant just do an allow as it could be any user calling this so they are msg.sender)                                                                                                 │
│             IERC20 rplInflationContract = IERC20(address(this));                                                                                                                                                                                     │
│             // Get the current allowance for Rocket Vault                                                                                                                                                                                            │
│             uint256 vaultAllowance = rplFixedSupplyContract.allowance(rocketVaultAddress, address(this));                                                                                                                                            │
│             // Now allow Rocket Vault to move those tokens, we also need to account of any other allowances for this token from other contracts in the same block                                                                                    │
│             require(rplInflationContract.approve(rocketVaultAddress, vaultAllowance.add(newTokens)), "Allowance for Rocket Vault could not be approved");                                                                                            │
│             // Let vault know it can move these tokens to itself now and credit the balance to the RPL rewards pool contract                                                                                                                         │
│             rocketVaultContract.depositToken("rocketRewardsPool", IERC20(address(this)), newTokens);                                                                                                                                                 │
│         }                                                                                                                                                                                                                                            │
│         // Log it                                                                                                                                                                                                                                    │
│         emit RPLInflationLog(msg.sender, newTokens, inflationCalcTime);                                                                                                                                                                              │
│         // return number minted                                                                                                                                                                                                                      │
│         return newTokens;                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate in the given code is `uint256 newTokens = _inflationCalculate(intervalsSinceLastMint);`.                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                          │
│ Code:                                                                                                                                                                                                                                                │
│     function inflationMintTokens() override external returns (uint256) {                                                                                                                                                                             │
│         // Only run inflation process if at least 1 interval has passed (function returns 0 otherwise)                                                                                                                                               │
│         uint256 inflationLastCalcTime = getInflationCalcTime();                                                                                                                                                                                      │
│         uint256 intervalsSinceLastMint = _getInflationIntervalsPassed(inflationLastCalcTime);                                                                                                                                                        │
│         if (intervalsSinceLastMint == 0) {                                                                                                                                                                                                           │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│         // Address of the vault where to send tokens                                                                                                                                                                                                 │
│         address rocketVaultAddress = getContractAddress("rocketVault");                                                                                                                                                                              │
│         require(rocketVaultAddress != address(0x0), "rocketVault address not set");                                                                                                                                                                  │
│         // Only mint if we have new tokens to mint since last interval and an address is set to receive them                                                                                                                                         │
│         RocketVaultInterface rocketVaultContract = RocketVaultInterface(rocketVaultAddress);                                                                                                                                                         │
│         // Calculate the amount of tokens now based on inflation rate                                                                                                                                                                                │
│         uint256 newTokens = _inflationCalculate(intervalsSinceLastMint);                                                                                                                                                                             │
│         // Update last inflation calculation timestamp even if inflation rate is 0                                                                                                                                                                   │
│         inflationCalcTime = inflationLastCalcTime.add(inflationInterval.mul(intervalsSinceLastMint));                                                                                                                                                │
│         // Check if actually need to mint tokens (e.g. inflation rate > 0)                                                                                                                                                                           │
│         if (newTokens > 0) {                                                                                                                                                                                                                         │
│             // Mint to itself, then allocate tokens for transfer to rewards contract, this will update balance & supply                                                                                                                              │
│             _mint(address(this), newTokens);                                                                                                                                                                                                         │
│             // Initialise itself and allow from it's own balance (cant just do an allow as it could be any user calling this so they are msg.sender)                                                                                                 │
│             IERC20 rplInflationContract = IERC20(address(this));                                                                                                                                                                                     │
│             // Get the current allowance for Rocket Vault                                                                                                                                                                                            │
│             uint256 vaultAllowance = rplFixedSupplyContract.allowance(rocketVaultAddress, address(this));                                                                                                                                            │
│             // Now allow Rocket Vault to move those tokens, we also need to account of any other allowances for this token from other contracts in the same block                                                                                    │
│             require(rplInflationContract.approve(rocketVaultAddress, vaultAllowance.add(newTokens)), "Allowance for Rocket Vault could not be approved");                                                                                            │
│             // Let vault know it can move these tokens to itself now and credit the balance to the RPL rewards pool contract                                                                                                                         │
│             rocketVaultContract.depositToken("rocketRewardsPool", IERC20(address(this)), newTokens);                                                                                                                                                 │
│         }                                                                                                                                                                                                                                            │
│         // Log it                                                                                                                                                                                                                                    │
│         emit RPLInflationLog(msg.sender, newTokens, inflationCalcTime);                                                                                                                                                                              │
│         // return number minted                                                                                                                                                                                                                      │
│         return newTokens;                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 newTokens = _inflationCalculate(intervalsSinceLastMint);`                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:58:11] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0xd33526068d116ce69f19a9ee46f0bd304f21a51f_eth/racts/contract/token/RocketTokenRPL.sol, current function: inflationMintTokens, tasks.py:260
                             current vul: wrong-order-interest                                                                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                   Summary                   
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value              ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 8                  │
│ Contracts            │ 8                  │
│ Functions            │ 6                  │
│ Lines of Code        │ 861                │
│ Used Time            │ 15.012813329696655 │
│ Estimated Cost (USD) │ 0.009146           │
└──────────────────────┴────────────────────┘
