

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[14:26:21] Loaded 10 rules                                                                                                                                                                                                                  tasks.py:119
           Traceback (most recent call last):                                                                                                                                                                                               tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                                                          
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                                                         
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                                                         
               self._compile(**kwargs)                                                                                                                                                                                                                  
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                                                         
               self._platform.compile(self, **kwargs)                                                                                                                                                                                                   
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/solc.py", line 149, in compile                                                                                           
               targets_json = _get_targets_json(compilation_unit, self._target, **kwargs)                                                                                                                                                               
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/solc.py", line 278, in _get_targets_json                                                                                 
               return _run_solc(                                                                                                                                                                                                                        
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/solc.py", line 483, in _run_solc                                                                                         
               raise InvalidCompilation(                                                                                                                                                                                                                
           crytic_compile.platform.exceptions.InvalidCompilation: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth is a directory. Expected a Solidity file when not using a                   
           compilation framework.                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                        
           During handling of the above exception, another exception occurred:                                                                                                                                                                          
                                                                                                                                                                                                                                                        
           Traceback (most recent call last):                                                                                                                                                                                                           
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                                                              
               falcon_instance = compile_project(source_dir)                                                                                                                                                                                            
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                                                         
               return falcon.Falcon(abs_path)                                                                                                                                                                                                           
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                                                          
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                                                                    
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                                                          
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth is a directory. Expected a Solidity file when not using a compilation framework.                                                   
                                                                                                                                                                                                                                                        
           Compile failed.                                                                                                                                                                                                                  tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                                                       tasks.py:128
[12/08/24 14:26:22] INFO     antlr4helper.callgraph: In whitelist: ERC20.transferFrom(address,address,uint) returns(bool)                                                                                                                callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: ERC20._approve(address,address,uint) returns()                                                                                                                        callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: SafeMath.add(uint,uint) returns(uint)                                                                                                                                 callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: SafeMath.sub(uint,uint,string) returns(uint)                                                                                                                          callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: SafeMath.div(uint,uint,string) returns(uint)                                                                                                                          callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: AccessControl.grantRole(bytes32,address) returns()                                                                                                                    callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: AccessControl.revokeRole(bytes32,address) returns()                                                                                                                   callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: AccessControl.renounceRole(bytes32,address) returns()                                                                                                                 callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: Address.sendValue(address,uint) returns()                                                                                                                             callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: ERC20.transferFrom(address,address,uint) returns(bool)                                                                                                                callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: ERC20._approve(address,address,uint) returns()                                                                                                                        callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: ERC20.transferFrom(address,address,uint) returns(bool)                                                                                                                callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: ERC20._approve(address,address,uint) returns()                                                                                                                        callgraph.py:21
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapToPrice(                                                                                                                                                                                                                            │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint256 truePriceTokenA,                                                                                                                                                                                                                     │
│         uint256 truePriceTokenB,                                                                                                                                                                                                                     │
│         uint256 maxSpendTokenA,                                                                                                                                                                                                                      │
│         uint256 maxSpendTokenB,                                                                                                                                                                                                                      │
│         address to,                                                                                                                                                                                                                                  │
│         uint256 deadline                                                                                                                                                                                                                             │
│     ) public {                                                                                                                                                                                                                                       │
│         // true price is expressed as a ratio, so both values must be non-zero                                                                                                                                                                       │
│         require(truePriceTokenA != 0 && truePriceTokenB != 0, "ExampleSwapToPrice: ZERO_PRICE");                                                                                                                                                     │
│         // caller can specify 0 for either if they wish to swap in only one direction, but not both                                                                                                                                                  │
│         require(maxSpendTokenA != 0 || maxSpendTokenB != 0, "ExampleSwapToPrice: ZERO_SPEND");                                                                                                                                                       │
│                                                                                                                                                                                                                                                      │
│         bool aToB;                                                                                                                                                                                                                                   │
│         uint256 amountIn;                                                                                                                                                                                                                            │
│         {                                                                                                                                                                                                                                            │
│             (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                            │
│             (aToB, amountIn) = computeProfitMaximizingTrade(                                                                                                                                                                                         │
│                 truePriceTokenA, truePriceTokenB,                                                                                                                                                                                                    │
│                 reserveA, reserveB                                                                                                                                                                                                                   │
│             );                                                                                                                                                                                                                                       │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // spend up to the allowance of the token in                                                                                                                                                                                                 │
│         uint256 maxSpend = aToB ? maxSpendTokenA : maxSpendTokenB;                                                                                                                                                                                   │
│         if (amountIn > maxSpend) {                                                                                                                                                                                                                   │
│             amountIn = maxSpend;                                                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         address tokenIn = aToB ? tokenA : tokenB;                                                                                                                                                                                                    │
│         address tokenOut = aToB ? tokenB : tokenA;                                                                                                                                                                                                   │
│         TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);                                                                                                                                                               │
│         TransferHelper.safeApprove(tokenIn, address(router), amountIn);                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         address[] memory path = new address[](2);                                                                                                                                                                                                    │
│         path[0] = tokenIn;                                                                                                                                                                                                                           │
│         path[1] = tokenOut;                                                                                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         router.swapExactTokensForTokens(                                                                                                                                                                                                             │
│             amountIn,                                                                                                                                                                                                                                │
│             0, // amountOutMin: we can skip computing this number because the math is tested                                                                                                                                                         │
│             path,                                                                                                                                                                                                                                    │
│             to,                                                                                                                                                                                                                                      │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function swapToPrice(                                                                                                                                                                                                                            │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint256 truePriceTokenA,                                                                                                                                                                                                                     │
│         uint256 truePriceTokenB,                                                                                                                                                                                                                     │
│         uint256 maxSpendTokenA,                                                                                                                                                                                                                      │
│         uint256 maxSpendTokenB,                                                                                                                                                                                                                      │
│         address to,                                                                                                                                                                                                                                  │
│         uint256 deadline                                                                                                                                                                                                                             │
│     ) public {                                                                                                                                                                                                                                       │
│         // true price is expressed as a ratio, so both values must be non-zero                                                                                                                                                                       │
│         require(truePriceTokenA != 0 && truePriceTokenB != 0, "ExampleSwapToPrice: ZERO_PRICE");                                                                                                                                                     │
│         // caller can specify 0 for either if they wish to swap in only one direction, but not both                                                                                                                                                  │
│         require(maxSpendTokenA != 0 || maxSpendTokenB != 0, "ExampleSwapToPrice: ZERO_SPEND");                                                                                                                                                       │
│                                                                                                                                                                                                                                                      │
│         bool aToB;                                                                                                                                                                                                                                   │
│         uint256 amountIn;                                                                                                                                                                                                                            │
│         {                                                                                                                                                                                                                                            │
│             (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                            │
│             (aToB, amountIn) = computeProfitMaximizingTrade(                                                                                                                                                                                         │
│                 truePriceTokenA, truePriceTokenB,                                                                                                                                                                                                    │
│                 reserveA, reserveB                                                                                                                                                                                                                   │
│             );                                                                                                                                                                                                                                       │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // spend up to the allowance of the token in                                                                                                                                                                                                 │
│         uint256 maxSpend = aToB ? maxSpendTokenA : maxSpendTokenB;                                                                                                                                                                                   │
│         if (amountIn > maxSpend) {                                                                                                                                                                                                                   │
│             amountIn = maxSpend;                                                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         address tokenIn = aToB ? tokenA : tokenB;                                                                                                                                                                                                    │
│         address tokenOut = aToB ? tokenB : tokenA;                                                                                                                                                                                                   │
│         TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);                                                                                                                                                               │
│         TransferHelper.safeApprove(tokenIn, address(router), amountIn);                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         address[] memory path = new address[](2);                                                                                                                                                                                                    │
│         path[0] = tokenIn;                                                                                                                                                                                                                           │
│         path[1] = tokenOut;                                                                                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         router.swapExactTokensForTokens(                                                                                                                                                                                                             │
│             amountIn,                                                                                                                                                                                                                                │
│             0, // amountOutMin: we can skip computing this number because the math is tested                                                                                                                                                         │
│             path,                                                                                                                                                                                                                                    │
│             to,                                                                                                                                                                                                                                      │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ mint or vest or collect token/liquidity/earning and assign them to the address recipient or to variable,                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes", "3": "Yes"}                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: mint or vest or collect token/liquidity/earning and assign them to the address recipient or to variable, and this operation could be front run to benefit the account/address that can be controlled by the parameter and has no sender   │
│ check in the function code                                                                                                                                                                                                                           │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│         IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                     │
│         assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                               │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│         IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                     │
│         assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                               │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│                                                                                                                                                                                                                                                      │
│                                                                                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(WETH, msg.sender, pair, amountETH);                                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         // IWETH(WETH).transferFrom(msg.sender, pair, amountETH);                                                                                                                                                                                    │
│         // IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                  │
│         // assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // require(false, "HELLO: HOW ARE YOU TODAY!");                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         liquidity = IUniswapV2Pair(pair).mint(to); // << PROBLEM IS HERE                                                                                                                                                                             │
│                                                                                                                                                                                                                                                      │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│                                                                                                                                                                                                                                                      │
│                                                                                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(WETH, msg.sender, pair, amountETH);                                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         // IWETH(WETH).transferFrom(msg.sender, pair, amountETH);                                                                                                                                                                                    │
│         // IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                  │
│         // assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // require(false, "HELLO: HOW ARE YOU TODAY!");                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         liquidity = IUniswapV2Pair(pair).mint(to); // << PROBLEM IS HERE                                                                                                                                                                             │
│                                                                                                                                                                                                                                                      │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidity(                                                                                                                                                                                                                        │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {                                                                                                                                                                │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair                                                                                                                                                    │
│         (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);                                                                                                                                                                                │
│         (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);                                                                                                                                                                             │
│         (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);                                                                                                                                                             │
│         require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                                    │
│         require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidity(                                                                                                                                                                                                                        │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {                                                                                                                                                                │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair                                                                                                                                                    │
│         (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);                                                                                                                                                                                │
│         (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);                                                                                                                                                                             │
│         (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);                                                                                                                                                             │
│         require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                                    │
│         require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidity(                                                                                                                                                                                                                        │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {                                                                                                                                                                │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair                                                                                                                                                    │
│         (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);                                                                                                                                                                                │
│         (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);                                                                                                                                                                             │
│         (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);                                                                                                                                                             │
│         require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                                    │
│         require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidity(                                                                                                                                                                                                                        │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {                                                                                                                                                                │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair                                                                                                                                                    │
│         (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);                                                                                                                                                                                │
│         (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);                                                                                                                                                                             │
│         (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);                                                                                                                                                             │
│         require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                                    │
│         require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {                                                                                                                                        │
│         require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         uint balance0;                                                                                                                                                                                                                               │
│         uint balance1;                                                                                                                                                                                                                               │
│         { // scope for _token{0,1}, avoids stack too deep errors                                                                                                                                                                                     │
│         address _token0 = token0;                                                                                                                                                                                                                    │
│         address _token1 = token1;                                                                                                                                                                                                                    │
│         require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');                                                                                                                                                                            │
│         if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens                                                                                                                                                │
│         if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens                                                                                                                                                │
│         if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);                                                                                                                                           │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                            │
│         uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;                                                                                                                                                │
│         uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;                                                                                                                                                │
│         require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');                                                                                                                                                             │
│         { // scope for reserve{0,1}Adjusted, avoids stack too deep errors                                                                                                                                                                            │
│         uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));                                                                                                                                                                            │
│         uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));                                                                                                                                                                            │
│         require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');                                                                                                                              │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {                                                                                                                                                     │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (address input, address output) = (path, path);                                                                                                                                                                                          │
│             (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                          │
│             uint amountOut = amounts;                                                                                                                                                                                                                │
│             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));                                                                                                                                      │
│             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                                │
│             IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(                                                                                                                                                                   │
│                 amount0Out, amount1Out, to, new bytes(0)                                                                                                                                                                                             │
│             );                                                                                                                                                                                                                                       │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {                                                                                                                                        │
│         require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         uint balance0;                                                                                                                                                                                                                               │
│         uint balance1;                                                                                                                                                                                                                               │
│         { // scope for _token{0,1}, avoids stack too deep errors                                                                                                                                                                                     │
│         address _token0 = token0;                                                                                                                                                                                                                    │
│         address _token1 = token1;                                                                                                                                                                                                                    │
│         require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');                                                                                                                                                                            │
│         if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens                                                                                                                                                │
│         if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens                                                                                                                                                │
│         if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);                                                                                                                                           │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                            │
│         uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;                                                                                                                                                │
│         uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;                                                                                                                                                │
│         require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');                                                                                                                                                             │
│         { // scope for reserve{0,1}Adjusted, avoids stack too deep errors                                                                                                                                                                            │
│         uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));                                                                                                                                                                            │
│         uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));                                                                                                                                                                            │
│         require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');                                                                                                                              │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {                                                                                                                                                     │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (address input, address output) = (path, path);                                                                                                                                                                                          │
│             (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                          │
│             uint amountOut = amounts;                                                                                                                                                                                                                │
│             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));                                                                                                                                      │
│             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                                │
│             IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(                                                                                                                                                                   │
│                 amount0Out, amount1Out, to, new bytes(0)                                                                                                                                                                                             │
│             );                                                                                                                                                                                                                                       │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {                                                                                                                                        │
│         require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         uint balance0;                                                                                                                                                                                                                               │
│         uint balance1;                                                                                                                                                                                                                               │
│         { // scope for _token{0,1}, avoids stack too deep errors                                                                                                                                                                                     │
│         address _token0 = token0;                                                                                                                                                                                                                    │
│         address _token1 = token1;                                                                                                                                                                                                                    │
│         require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');                                                                                                                                                                            │
│         if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens                                                                                                                                                │
│         if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens                                                                                                                                                │
│         if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);                                                                                                                                           │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                            │
│         uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;                                                                                                                                                │
│         uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;                                                                                                                                                │
│         require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');                                                                                                                                                             │
│         { // scope for reserve{0,1}Adjusted, avoids stack too deep errors                                                                                                                                                                            │
│         uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));                                                                                                                                                                            │
│         uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));                                                                                                                                                                            │
│         require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');                                                                                                                              │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function skim(address to) external override lock {                                                                                                                                                                                               │
│         address _token0 = token0; // gas savings                                                                                                                                                                                                     │
│         address _token1 = token1; // gas savings                                                                                                                                                                                                     │
│         _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));                                                                                                                                                          │
│         _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mint(address to, uint value) internal {                                                                                                                                                                                                │
│         totalSupply = totalSupply.add(value);                                                                                                                                                                                                        │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(address(0), to, value);                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mint(address to, uint value) internal {                                                                                                                                                                                                │
│         totalSupply = totalSupply.add(value);                                                                                                                                                                                                        │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(address(0), to, value);                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address to, uint value) internal {                                                                                                                                                                                                │
│         totalSupply = totalSupply.add(value);                                                                                                                                                                                                        │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(address(0), to, value);                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address to, uint value) internal {                                                                                                                                                                                                │
│         totalSupply = totalSupply.add(value);                                                                                                                                                                                                        │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(address(0), to, value);                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address to, uint value) internal {                                                                                                                                                                                                │
│         totalSupply = totalSupply.add(value);                                                                                                                                                                                                        │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(address(0), to, value);                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address to, uint value) internal {                                                                                                                                                                                                │
│         totalSupply = totalSupply.add(value);                                                                                                                                                                                                        │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(address(0), to, value);                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address to, uint value) internal {                                                                                                                                                                                                │
│         totalSupply = totalSupply.add(value);                                                                                                                                                                                                        │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(address(0), to, value);                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _burn(address from, uint value) internal {                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         totalSupply = totalSupply.sub(value);                                                                                                                                                                                                        │
│         emit Transfer(from, address(0), value);                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address from, uint value) internal {                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         totalSupply = totalSupply.sub(value);                                                                                                                                                                                                        │
│         emit Transfer(from, address(0), value);                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address from, uint value) internal {                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         totalSupply = totalSupply.sub(value);                                                                                                                                                                                                        │
│         emit Transfer(from, address(0), value);                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address from, uint value) internal {                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         totalSupply = totalSupply.sub(value);                                                                                                                                                                                                        │
│         emit Transfer(from, address(0), value);                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address from, uint value) internal {                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         totalSupply = totalSupply.sub(value);                                                                                                                                                                                                        │
│         emit Transfer(from, address(0), value);                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address from, uint value) internal {                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         totalSupply = totalSupply.sub(value);                                                                                                                                                                                                        │
│         emit Transfer(from, address(0), value);                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _transfer(address from, address to, uint value) private {                                                                                                                                                                               │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(from, to, value);                                                                                                                                                                                                              │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {                                                                                                                                                    │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             // Transfer votes                                                                                                                                                                                                                        │
│             trackVotes(_msgSender(), recipient, uint96(amount));                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         _transfer(_msgSender(), recipient, amount);                                                                                                                                                                                                  │
│         return true;                                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _transfer(address from, address to, uint value) private {                                                                                                                                                                               │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(from, to, value);                                                                                                                                                                                                              │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {                                                                                                                                │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             // Transfer votes                                                                                                                                                                                                                        │
│             trackVotes(sender, recipient, uint96(amount));                                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         _transfer(sender, recipient, amount);                                                                                                                                                                                                        │
│         _approve(sender, _msgSender(), _allowances[_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         return true;                                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _transfer(address from, address to, uint value) private {                                                                                                                                                                               │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(from, to, value);                                                                                                                                                                                                              │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function transferFrom(address from, address to, uint value) external override returns (bool) {                                                                                                                                                   │
│         if (allowance != uint(-1)) {                                                                                                                                                                                                                 │
│             allowance = allowance.sub(value);                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         _transfer(from, to, value);                                                                                                                                                                                                                  │
│         return true;                                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _transfer(address from, address to, uint value) private {                                                                                                                                                                               │
│         balanceOf = balanceOf.sub(value);                                                                                                                                                                                                            │
│         balanceOf = balanceOf.add(value);                                                                                                                                                                                                            │
│         emit Transfer(from, to, value);                                                                                                                                                                                                              │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)                                                                                                                             │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│         returns (uint[] memory amounts)                                                                                                                                                                                                              │
│     {                                                                                                                                                                                                                                                │
│         require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                      │
│         amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);                                                                                                                                                                           │
│         require(amounts >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                             │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]                                                                                                                                                     │
│         );                                                                                                                                                                                                                                           │
│         _swap(amounts, path, address(this));                                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amounts);                                                                                                                                                                                                               │
│         TransferHelper.safeTransferETH(to, amounts);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)                                                                                                                             │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│         returns (uint[] memory amounts)                                                                                                                                                                                                              │
│     {                                                                                                                                                                                                                                                │
│         require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                      │
│         amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);                                                                                                                                                                           │
│         require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]                                                                                                                                                     │
│         );                                                                                                                                                                                                                                           │
│         _swap(amounts, path, address(this));                                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amounts);                                                                                                                                                                                                               │
│         TransferHelper.safeTransferETH(to, amounts);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)                                                                                                                             │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│         returns (uint[] memory amounts)                                                                                                                                                                                                              │
│     {                                                                                                                                                                                                                                                │
│         require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                      │
│         amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);                                                                                                                                                                           │
│         require(amounts >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                             │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]                                                                                                                                                     │
│         );                                                                                                                                                                                                                                           │
│         _swap(amounts, path, address(this));                                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amounts);                                                                                                                                                                                                               │
│         TransferHelper.safeTransferETH(to, amounts);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)                                                                                                                             │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│         returns (uint[] memory amounts)                                                                                                                                                                                                              │
│     {                                                                                                                                                                                                                                                │
│         require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                      │
│         amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);                                                                                                                                                                           │
│         require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]                                                                                                                                                     │
│         );                                                                                                                                                                                                                                           │
│         _swap(amounts, path, address(this));                                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amounts);                                                                                                                                                                                                               │
│         TransferHelper.safeTransferETH(to, amounts);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForETHSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                       │
│         );                                                                                                                                                                                                                                           │
│         _swapSupportingFeeOnTransferTokens(path, address(this));                                                                                                                                                                                     │
│         uint amountOut = IERC20(WETH).balanceOf(address(this));                                                                                                                                                                                      │
│         require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                           │
│         IWETH(WETH).withdraw(amountOut);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountOut);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
│     function withdraw(uint wad) override public {                                                                                                                                                                                                    │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         msg.sender.transfer(wad);                                                                                                                                                                                                                    │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function transferFrom(address src, address dst, uint wad)                                                                                                                                                                                        │
│         public                                                                                                                                                                                                                                       │
│         override                                                                                                                                                                                                                                     │
│         returns (bool)                                                                                                                                                                                                                               │
│     {                                                                                                                                                                                                                                                │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                                      │
│         if (src != msg.sender && allowance != uint(-1)) {                                                                                                                                                                                            │
│             require(allowance >= wad);                                                                                                                                                                                                               │
│             allowance -= wad;                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         balanceOf += wad;                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         emit Transfer(src, dst, wad);                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                                      │
│         return true;                                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidity(                                                                                                                                                                                                                        │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {                                                                                                                                                                │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair                                                                                                                                                    │
│         (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);                                                                                                                                                                                │
│         (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);                                                                                                                                                                             │
│         (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);                                                                                                                                                             │
│         require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                                    │
│         require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
│     function transferFrom(address src, address dst, uint wad)                                                                                                                                                                                        │
│         public                                                                                                                                                                                                                                       │
│         override                                                                                                                                                                                                                                     │
│         returns (bool)                                                                                                                                                                                                                               │
│     {                                                                                                                                                                                                                                                │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                                      │
│         if (src != msg.sender && allowance != uint(-1)) {                                                                                                                                                                                            │
│             require(allowance >= wad);                                                                                                                                                                                                               │
│             allowance -= wad;                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         balanceOf += wad;                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         emit Transfer(src, dst, wad);                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                                      │
│         return true;                                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidity(                                                                                                                                                                                                                        │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {                                                                                                                                                                │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair                                                                                                                                                    │
│         (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);                                                                                                                                                                                │
│         (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);                                                                                                                                                                             │
│         (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);                                                                                                                                                             │
│         require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                                    │
│         require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
│     function transferFrom(address src, address dst, uint wad)                                                                                                                                                                                        │
│         public                                                                                                                                                                                                                                       │
│         override                                                                                                                                                                                                                                     │
│         returns (bool)                                                                                                                                                                                                                               │
│     {                                                                                                                                                                                                                                                │
│         require(balanceOf >= wad);                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                                      │
│         if (src != msg.sender && allowance != uint(-1)) {                                                                                                                                                                                            │
│             require(allowance >= wad);                                                                                                                                                                                                               │
│             allowance -= wad;                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         balanceOf -= wad;                                                                                                                                                                                                                            │
│         balanceOf += wad;                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         emit Transfer(src, dst, wad);                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                                      │
│         return true;                                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│         IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                     │
│         assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                               │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│         IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                     │
│         assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                               │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│                                                                                                                                                                                                                                                      │
│                                                                                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(WETH, msg.sender, pair, amountETH);                                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         // IWETH(WETH).transferFrom(msg.sender, pair, amountETH);                                                                                                                                                                                    │
│         // IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                  │
│         // assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // require(false, "HELLO: HOW ARE YOU TODAY!");                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         liquidity = IUniswapV2Pair(pair).mint(to); // << PROBLEM IS HERE                                                                                                                                                                             │
│                                                                                                                                                                                                                                                      │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│         IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                     │
│         assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                               │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermit(                                                                                                                                                                                                           │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountToken, uint amountETH) {                                                                                                                                                                         │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermit(                                                                                                                                                                                                           │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountToken, uint amountETH) {                                                                                                                                                                         │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermit(                                                                                                                                                                                                           │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountToken, uint amountETH) {                                                                                                                                                                         │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermit(                                                                                                                                                                                                           │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountToken, uint amountETH) {                                                                                                                                                                         │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ have code statements that get or calculate LP token's value/price                                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ have code statements that get or calculate LP token's value/price                                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ have code statements that get or calculate LP token's value/price                                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender                                                                                                                                                                   │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (address input, address output) = (path, path);                                                                                                                                                                                          │
│             (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                          │
│             IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                                  │
│             uint amountInput;                                                                                                                                                                                                                        │
│             uint amountOutput;                                                                                                                                                                                                                       │
│             { // scope to avoid stack too deep errors                                                                                                                                                                                                │
│             (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                    │
│             (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                 │
│             amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                                  │
│             amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                                │
│             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                                │
│             pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (address input, address output) = (path, path);                                                                                                                                                                                          │
│             (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                          │
│             IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                                  │
│             uint amountInput;                                                                                                                                                                                                                        │
│             uint amountOutput;                                                                                                                                                                                                                       │
│             { // scope to avoid stack too deep errors                                                                                                                                                                                                │
│             (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                    │
│             (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                 │
│             amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                                  │
│             amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                                │
│             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                                │
│             pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForETHSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                       │
│         );                                                                                                                                                                                                                                           │
│         _swapSupportingFeeOnTransferTokens(path, address(this));                                                                                                                                                                                     │
│         uint amountOut = IERC20(WETH).balanceOf(address(this));                                                                                                                                                                                      │
│         require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                           │
│         IWETH(WETH).withdraw(amountOut);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountOut);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (address input, address output) = (path, path);                                                                                                                                                                                          │
│             (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                          │
│             IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                                  │
│             uint amountInput;                                                                                                                                                                                                                        │
│             uint amountOutput;                                                                                                                                                                                                                       │
│             { // scope to avoid stack too deep errors                                                                                                                                                                                                │
│             (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                    │
│             (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                 │
│             amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                                  │
│             amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                                │
│             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                                │
│             pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactETHForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         payable                                                                                                                                                                                                                                      │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                   │
│         uint amountIn = msg.value;                                                                                                                                                                                                                   │
│         IWETH(WETH).deposit{value: amountIn}();                                                                                                                                                                                                      │
│         assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));                                                                                                                                                 │
│         uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                             │
│         _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                                │
│         require(                                                                                                                                                                                                                                     │
│             IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                           │
│             'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                            │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (address input, address output) = (path, path);                                                                                                                                                                                          │
│             (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                          │
│             IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                                  │
│             uint amountInput;                                                                                                                                                                                                                        │
│             uint amountOutput;                                                                                                                                                                                                                       │
│             { // scope to avoid stack too deep errors                                                                                                                                                                                                │
│             (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                    │
│             (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                 │
│             amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                                  │
│             amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                                │
│             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                                │
│             pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                  │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) {                                                                                                                                                                                                   │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                       │
│         );                                                                                                                                                                                                                                           │
│         uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                             │
│         _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                                │
│         require(                                                                                                                                                                                                                                     │
│             IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                           │
│             'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                            │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (address input, address output) = (path, path);                                                                                                                                                                                          │
│             (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                          │
│             IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                                  │
│             uint amountInput;                                                                                                                                                                                                                        │
│             uint amountOutput;                                                                                                                                                                                                                       │
│             { // scope to avoid stack too deep errors                                                                                                                                                                                                │
│             (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                    │
│             (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                 │
│             amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                                  │
│             amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                                │
│             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                                │
│             pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                  │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) {                                                                                                                                                                                                   │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                       │
│         );                                                                                                                                                                                                                                           │
│         uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                             │
│         _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                                │
│         require(                                                                                                                                                                                                                                     │
│             IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                           │
│             'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                            │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (address input, address output) = (path, path);                                                                                                                                                                                          │
│             (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                          │
│             IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                                  │
│             uint amountInput;                                                                                                                                                                                                                        │
│             uint amountOutput;                                                                                                                                                                                                                       │
│             { // scope to avoid stack too deep errors                                                                                                                                                                                                │
│             (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                    │
│             (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                 │
│             amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                                  │
│             amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                                │
│             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                                │
│             pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                  │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) {                                                                                                                                                                                                   │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                       │
│         );                                                                                                                                                                                                                                           │
│         uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                             │
│         _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                                │
│         require(                                                                                                                                                                                                                                     │
│             IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                           │
│             'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                            │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender                                                                                                                                                                   │
│ have code statements that get or calculate LP token's value/price                                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactETHForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         payable                                                                                                                                                                                                                                      │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                   │
│         uint amountIn = msg.value;                                                                                                                                                                                                                   │
│         IWETH(WETH).deposit{value: amountIn}();                                                                                                                                                                                                      │
│         assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));                                                                                                                                                 │
│         uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                             │
│         _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                                │
│         require(                                                                                                                                                                                                                                     │
│             IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                           │
│             'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                            │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForETHSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                       │
│         );                                                                                                                                                                                                                                           │
│         _swapSupportingFeeOnTransferTokens(path, address(this));                                                                                                                                                                                     │
│         uint amountOut = IERC20(WETH).balanceOf(address(this));                                                                                                                                                                                      │
│         require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                           │
│         IWETH(WETH).withdraw(amountOut);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountOut);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                          │
│ Code:                                                                                                                                                                                                                                                │
│     function recollateralizeAmount(uint256 total_supply, uint256 global_collateral_ratio, uint256 global_collat_value) public pure returns (uint256) {                                                                                               │
│         uint256 target_collat_value = total_supply.mul(global_collateral_ratio).div(1e6); // We want 18 decimals of precision so divide by 1e6; total_supply is 1e18 and global_collateral_ratio is 1e6                                              │
│         // Subtract the current value of collateral from the target value needed, if higher than 0 then system needs to recollateralize                                                                                                              │
│         uint256 recollateralization_left = target_collat_value.sub(global_collat_value); // If recollateralization is not needed, throws a subtraction underflow                                                                                     │
│         return(recollateralization_left);                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                          │
│ Code:                                                                                                                                                                                                                                                │
│     function calcRecollateralizeFRAXInner(                                                                                                                                                                                                           │
│         uint256 collateral_amount,                                                                                                                                                                                                                   │
│         uint256 col_price,                                                                                                                                                                                                                           │
│         uint256 global_collat_value,                                                                                                                                                                                                                 │
│         uint256 frax_total_supply,                                                                                                                                                                                                                   │
│         uint256 global_collateral_ratio                                                                                                                                                                                                              │
│     ) public pure returns (uint256, uint256) {                                                                                                                                                                                                       │
│         uint256 collat_value_attempted = collateral_amount.mul(col_price).div(1e6);                                                                                                                                                                  │
│         uint256 effective_collateral_ratio = global_collat_value.mul(1e6).div(frax_total_supply); //returns it in 1e6                                                                                                                                │
│         uint256 recollat_possible = (global_collateral_ratio.mul(frax_total_supply).sub(frax_total_supply.mul(effective_collateral_ratio))).div(1e6);                                                                                                │
│                                                                                                                                                                                                                                                      │
│         uint256 amount_to_recollat;                                                                                                                                                                                                                  │
│         if(collat_value_attempted <= recollat_possible){                                                                                                                                                                                             │
│             amount_to_recollat = collat_value_attempted;                                                                                                                                                                                             │
│         } else {                                                                                                                                                                                                                                     │
│             amount_to_recollat = recollat_possible;                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         return (amount_to_recollat.mul(1e6).div(col_price), amount_to_recollat);                                                                                                                                                                     │
│                                                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function collatDollarBalance() public view returns (uint256) {                                                                                                                                                                                   │
│         uint256 eth_usd_price = FRAX.eth_usd_price();                                                                                                                                                                                                │
│         uint256 eth_collat_price = collatEthOracle.consult(weth_address, (PRICE_PRECISION * (10 ** missing_decimals)));                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         uint256 collat_usd_price = eth_usd_price.mul(PRICE_PRECISION).div(eth_collat_price);                                                                                                                                                         │
│         return (collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral)).mul(10 ** missing_decimals).mul(collat_usd_price).div(PRICE_PRECISION); //.mul(getCollateralPrice()).div(1e6);                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function globalCollateralValue() public view returns (uint256) {                                                                                                                                                                                 │
│         uint256 total_collateral_value_d18 = 0;                                                                                                                                                                                                      │
│                                                                                                                                                                                                                                                      │
│         for (uint i = 0; i < frax_pools_array.length; i++){                                                                                                                                                                                          │
│             // Exclude null addresses                                                                                                                                                                                                                │
│             if (frax_pools_array != address(0)){                                                                                                                                                                                                     │
│                 total_collateral_value_d18 = total_collateral_value_d18.add(FraxPool(frax_pools_array).collatDollarBalance());                                                                                                                       │
│             }                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│         return total_collateral_value_d18;                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function collatDollarBalance() public view returns (uint256) {                                                                                                                                                                                   │
│         uint256 eth_usd_price = FRAX.eth_usd_price();                                                                                                                                                                                                │
│         uint256 eth_collat_price = collatEthOracle.consult(weth_address, (PRICE_PRECISION * (10 ** missing_decimals)));                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         uint256 collat_usd_price = eth_usd_price.mul(PRICE_PRECISION).div(eth_collat_price);                                                                                                                                                         │
│         return (collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral)).mul(10 ** missing_decimals).mul(collat_usd_price).div(PRICE_PRECISION); //.mul(getCollateralPrice()).div(1e6);                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function availableExcessCollatDV() public view returns (uint256) {                                                                                                                                                                               │
│         uint256 total_supply = FRAX.totalSupply();                                                                                                                                                                                                   │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│         uint256 global_collat_value = FRAX.globalCollateralValue();                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         if (global_collateral_ratio > COLLATERAL_RATIO_PRECISION) global_collateral_ratio = COLLATERAL_RATIO_PRECISION; // Handles an overcollateralized contract with CR > 1                                                                        │
│         uint256 required_collat_dollar_value_d18 = (total_supply.mul(global_collateral_ratio)).div(COLLATERAL_RATIO_PRECISION); // Calculates collateral needed to back each 1 FRAX with $1 of collateral at current collat ratio                    │
│         if (global_collat_value > required_collat_dollar_value_d18) return global_collat_value.sub(required_collat_dollar_value_d18);                                                                                                                │
│         else return 0;                                                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function buyBackFXS(uint256 FXS_amount, uint256 COLLATERAL_out_min) external {                                                                                                                                                                   │
│         require(buyBackPaused == false, "Buyback is paused");                                                                                                                                                                                        │
│         uint256 fxs_price = FRAX.fxs_price();                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         FraxPoolLibrary.BuybackFXS_Params memory input_params = FraxPoolLibrary.BuybackFXS_Params(                                                                                                                                                   │
│             availableExcessCollatDV(),                                                                                                                                                                                                               │
│             fxs_price,                                                                                                                                                                                                                               │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             FXS_amount                                                                                                                                                                                                                               │
│         );                                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         (uint256 collateral_equivalent_d18) = FraxPoolLibrary.calcBuyBackFXS(input_params);                                                                                                                                                          │
│         uint256 collateral_precision = collateral_equivalent_d18.div(10 ** missing_decimals);                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         require(COLLATERAL_out_min <= collateral_precision, "Slippage limit reached");                                                                                                                                                               │
│         // Give the sender their desired collateral and burn the FXS                                                                                                                                                                                 │
│         FXS.pool_burn_from(msg.sender, FXS_amount);                                                                                                                                                                                                  │
│         collateral_token.transfer(msg.sender, collateral_precision);                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function availableExcessCollatDV() public view returns (uint256) {                                                                                                                                                                               │
│         uint256 total_supply = FRAX.totalSupply();                                                                                                                                                                                                   │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│         uint256 global_collat_value = FRAX.globalCollateralValue();                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         if (global_collateral_ratio > COLLATERAL_RATIO_PRECISION) global_collateral_ratio = COLLATERAL_RATIO_PRECISION; // Handles an overcollateralized contract with CR > 1                                                                        │
│         uint256 required_collat_dollar_value_d18 = (total_supply.mul(global_collateral_ratio)).div(COLLATERAL_RATIO_PRECISION); // Calculates collateral needed to back each 1 FRAX with $1 of collateral at current collat ratio                    │
│         if (global_collat_value > required_collat_dollar_value_d18) return global_collat_value.sub(required_collat_dollar_value_d18);                                                                                                                │
│         else return 0;                                                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function buyBackFXS(uint256 FXS_amount, uint256 COLLATERAL_out_min) external {                                                                                                                                                                   │
│         require(buyBackPaused == false, "Buyback is paused");                                                                                                                                                                                        │
│         uint256 fxs_price = FRAX.fxs_price();                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         FraxPoolLibrary.BuybackFXS_Params memory input_params = FraxPoolLibrary.BuybackFXS_Params(                                                                                                                                                   │
│             availableExcessCollatDV(),                                                                                                                                                                                                               │
│             fxs_price,                                                                                                                                                                                                                               │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             FXS_amount                                                                                                                                                                                                                               │
│         );                                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         (uint256 collateral_equivalent_d18) = FraxPoolLibrary.calcBuyBackFXS(input_params);                                                                                                                                                          │
│         uint256 collateral_precision = collateral_equivalent_d18.div(10 ** missing_decimals);                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         require(COLLATERAL_out_min <= collateral_precision, "Slippage limit reached");                                                                                                                                                               │
│         // Give the sender their desired collateral and burn the FXS                                                                                                                                                                                 │
│         FXS.pool_burn_from(msg.sender, FXS_amount);                                                                                                                                                                                                  │
│         collateral_token.transfer(msg.sender, collateral_precision);                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function availableExcessCollatDV() public view returns (uint256) {                                                                                                                                                                               │
│         uint256 total_supply = FRAX.totalSupply();                                                                                                                                                                                                   │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│         uint256 global_collat_value = FRAX.globalCollateralValue();                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         if (global_collateral_ratio > COLLATERAL_RATIO_PRECISION) global_collateral_ratio = COLLATERAL_RATIO_PRECISION; // Handles an overcollateralized contract with CR > 1                                                                        │
│         uint256 required_collat_dollar_value_d18 = (total_supply.mul(global_collateral_ratio)).div(COLLATERAL_RATIO_PRECISION); // Calculates collateral needed to back each 1 FRAX with $1 of collateral at current collat ratio                    │
│         if (global_collat_value > required_collat_dollar_value_d18) return global_collat_value.sub(required_collat_dollar_value_d18);                                                                                                                │
│         else return 0;                                                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function mint1t1FRAX(uint256 collateral_amount, uint256 FRAX_out_min) external notMintPaused {                                                                                                                                                   │
│         uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);                                                                                                                                                                │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(global_collateral_ratio >= COLLATERAL_RATIO_MAX, "Collateral ratio must be >= 1");                                                                                                                                                   │
│         require((collateral_token.balanceOf(address(this))).sub(unclaimedPoolCollateral).add(collateral_amount) <= pool_ceiling, "[Pool's Closed]: Ceiling reached");                                                                                │
│                                                                                                                                                                                                                                                      │
│         (uint256 frax_amount_d18) = FraxPoolLibrary.calcMint1t1FRAX(                                                                                                                                                                                 │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             minting_fee,                                                                                                                                                                                                                             │
│             collateral_amount_d18                                                                                                                                                                                                                    │
│         ); //1 FRAX for each $1 worth of collateral                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         require(FRAX_out_min <= frax_amount_d18, "Slippage limit reached");                                                                                                                                                                          │
│         collateral_token.transferFrom(msg.sender, address(this), collateral_amount);                                                                                                                                                                 │
│         FRAX.pool_mint(msg.sender, frax_amount_d18);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function mint1t1FRAX(uint256 collateral_amount, uint256 FRAX_out_min) external notMintPaused {                                                                                                                                                   │
│         uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);                                                                                                                                                                │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(global_collateral_ratio >= COLLATERAL_RATIO_MAX, "Collateral ratio must be >= 1");                                                                                                                                                   │
│         require((collateral_token.balanceOf(address(this))).sub(unclaimedPoolCollateral).add(collateral_amount) <= pool_ceiling, "[Pool's Closed]: Ceiling reached");                                                                                │
│                                                                                                                                                                                                                                                      │
│         (uint256 frax_amount_d18) = FraxPoolLibrary.calcMint1t1FRAX(                                                                                                                                                                                 │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             minting_fee,                                                                                                                                                                                                                             │
│             collateral_amount_d18                                                                                                                                                                                                                    │
│         ); //1 FRAX for each $1 worth of collateral                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         require(FRAX_out_min <= frax_amount_d18, "Slippage limit reached");                                                                                                                                                                          │
│         collateral_token.transferFrom(msg.sender, address(this), collateral_amount);                                                                                                                                                                 │
│         FRAX.pool_mint(msg.sender, frax_amount_d18);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function mintFractionalFRAX(uint256 collateral_amount, uint256 fxs_amount, uint256 FRAX_out_min) external notMintPaused {                                                                                                                        │
│         uint256 frax_price = FRAX.frax_price();                                                                                                                                                                                                      │
│         uint256 fxs_price = FRAX.fxs_price();                                                                                                                                                                                                        │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(global_collateral_ratio < COLLATERAL_RATIO_MAX && global_collateral_ratio > 0, "Collateral ratio needs to be between .000001 and .999999");                                                                                          │
│         require(collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral).add(collateral_amount) <= pool_ceiling, "Pool ceiling reached, no more FRAX can be minted with this collateral");                                             │
│                                                                                                                                                                                                                                                      │
│         uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);                                                                                                                                                                │
│         FraxPoolLibrary.MintFF_Params memory input_params = FraxPoolLibrary.MintFF_Params(                                                                                                                                                           │
│             minting_fee,                                                                                                                                                                                                                             │
│             fxs_price,                                                                                                                                                                                                                               │
│             frax_price,                                                                                                                                                                                                                              │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             fxs_amount,                                                                                                                                                                                                                              │
│             collateral_amount_d18,                                                                                                                                                                                                                   │
│             (collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral)),                                                                                                                                                                │
│             pool_ceiling,                                                                                                                                                                                                                            │
│             global_collateral_ratio                                                                                                                                                                                                                  │
│         );                                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         (uint256 mint_amount, uint256 fxs_needed) = FraxPoolLibrary.calcMintFractionalFRAX(input_params);                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(FRAX_out_min <= mint_amount, "Slippage limit reached");                                                                                                                                                                              │
│         require(fxs_needed <= fxs_amount, "Not enough FXS inputted");                                                                                                                                                                                │
│         FXS.pool_burn_from(msg.sender, fxs_needed);                                                                                                                                                                                                  │
│         collateral_token.transferFrom(msg.sender, address(this), collateral_amount);                                                                                                                                                                 │
│         FRAX.pool_mint(msg.sender, mint_amount);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function mintFractionalFRAX(uint256 collateral_amount, uint256 fxs_amount, uint256 FRAX_out_min) external notMintPaused {                                                                                                                        │
│         uint256 frax_price = FRAX.frax_price();                                                                                                                                                                                                      │
│         uint256 fxs_price = FRAX.fxs_price();                                                                                                                                                                                                        │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(global_collateral_ratio < COLLATERAL_RATIO_MAX && global_collateral_ratio > 0, "Collateral ratio needs to be between .000001 and .999999");                                                                                          │
│         require(collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral).add(collateral_amount) <= pool_ceiling, "Pool ceiling reached, no more FRAX can be minted with this collateral");                                             │
│                                                                                                                                                                                                                                                      │
│         uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);                                                                                                                                                                │
│         FraxPoolLibrary.MintFF_Params memory input_params = FraxPoolLibrary.MintFF_Params(                                                                                                                                                           │
│             minting_fee,                                                                                                                                                                                                                             │
│             fxs_price,                                                                                                                                                                                                                               │
│             frax_price,                                                                                                                                                                                                                              │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             fxs_amount,                                                                                                                                                                                                                              │
│             collateral_amount_d18,                                                                                                                                                                                                                   │
│             (collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral)),                                                                                                                                                                │
│             pool_ceiling,                                                                                                                                                                                                                            │
│             global_collateral_ratio                                                                                                                                                                                                                  │
│         );                                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         (uint256 mint_amount, uint256 fxs_needed) = FraxPoolLibrary.calcMintFractionalFRAX(input_params);                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(FRAX_out_min <= mint_amount, "Slippage limit reached");                                                                                                                                                                              │
│         require(fxs_needed <= fxs_amount, "Not enough FXS inputted");                                                                                                                                                                                │
│         FXS.pool_burn_from(msg.sender, fxs_needed);                                                                                                                                                                                                  │
│         collateral_token.transferFrom(msg.sender, address(this), collateral_amount);                                                                                                                                                                 │
│         FRAX.pool_mint(msg.sender, mint_amount);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function redeem1t1FRAX(uint256 FRAX_amount, uint256 COLLATERAL_out_min) external notRedeemPaused {                                                                                                                                               │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│         require(global_collateral_ratio == COLLATERAL_RATIO_MAX, "Collateral ratio must be == 1");                                                                                                                                                   │
│                                                                                                                                                                                                                                                      │
│         // Need to adjust for decimals of collateral                                                                                                                                                                                                 │
│         uint256 FRAX_amount_precision = FRAX_amount.div(10 ** missing_decimals);                                                                                                                                                                     │
│         (uint256 collateral_needed) = FraxPoolLibrary.calcRedeem1t1FRAX(                                                                                                                                                                             │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             FRAX_amount_precision,                                                                                                                                                                                                                   │
│             redemption_fee                                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         require(collateral_needed <= collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral), "Not enough collateral in pool");                                                                                                       │
│                                                                                                                                                                                                                                                      │
│         redeemCollateralBalances = redeemCollateralBalances.add(collateral_needed);                                                                                                                                                                  │
│         unclaimedPoolCollateral = unclaimedPoolCollateral.add(collateral_needed);                                                                                                                                                                    │
│         lastRedeemed = block.number;                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                                      │
│         require(COLLATERAL_out_min <= collateral_needed, "Slippage limit reached");                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         // Move all external functions to the end                                                                                                                                                                                                    │
│         FRAX.pool_burn_from(msg.sender, FRAX_amount);                                                                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function redeemFractionalFRAX(uint256 FRAX_amount, uint256 FXS_out_min, uint256 COLLATERAL_out_min) external notRedeemPaused {                                                                                                                   │
│         uint256 fxs_price = FRAX.fxs_price();                                                                                                                                                                                                        │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(global_collateral_ratio < COLLATERAL_RATIO_MAX && global_collateral_ratio > 0, "Collateral ratio needs to be between .000001 and .999999");                                                                                          │
│         uint256 col_price_usd = getCollateralPrice();                                                                                                                                                                                                │
│                                                                                                                                                                                                                                                      │
│         uint256 FRAX_amount_post_fee = FRAX_amount.sub((FRAX_amount.mul(redemption_fee)).div(PRICE_PRECISION));                                                                                                                                      │
│         uint256 fxs_dollar_value_d18 = FRAX_amount_post_fee.sub(FRAX_amount_post_fee.mul(global_collateral_ratio).div(PRICE_PRECISION));                                                                                                             │
│         uint256 fxs_amount = fxs_dollar_value_d18.mul(PRICE_PRECISION).div(fxs_price);                                                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         // Need to adjust for decimals of collateral                                                                                                                                                                                                 │
│         uint256 FRAX_amount_precision = FRAX_amount_post_fee.div(10 ** missing_decimals);                                                                                                                                                            │
│         uint256 collateral_dollar_value = FRAX_amount_precision.mul(global_collateral_ratio).div(PRICE_PRECISION);                                                                                                                                   │
│         uint256 collateral_amount = collateral_dollar_value.mul(PRICE_PRECISION).div(col_price_usd);                                                                                                                                                 │
│                                                                                                                                                                                                                                                      │
│         redeemCollateralBalances = redeemCollateralBalances.add(collateral_amount);                                                                                                                                                                  │
│         unclaimedPoolCollateral = unclaimedPoolCollateral.add(collateral_amount);                                                                                                                                                                    │
│                                                                                                                                                                                                                                                      │
│         redeemFXSBalances = redeemFXSBalances.add(fxs_amount);                                                                                                                                                                                       │
│         unclaimedPoolFXS = unclaimedPoolFXS.add(fxs_amount);                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         lastRedeemed = block.number;                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                                      │
│         require(collateral_amount <= collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral), "Not enough collateral in pool");                                                                                                       │
│         require(COLLATERAL_out_min <= collateral_amount, "Slippage limit reached ");                                                                                                                                                                 │
│         require(FXS_out_min <= fxs_amount, "Slippage limit reached [FXS]");                                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         // Move all external functions to the end                                                                                                                                                                                                    │
│         FRAX.pool_burn_from(msg.sender, FRAX_amount);                                                                                                                                                                                                │
│         FXS.pool_mint(address(this), fxs_amount);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                               │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function recollateralizeFRAX(uint256 collateral_amount, uint256 FXS_out_min) external {                                                                                                                                                          │
│         require(recollateralizePaused == false, "Recollateralize is paused");                                                                                                                                                                        │
│         uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);                                                                                                                                                                │
│         uint256 fxs_price = FRAX.fxs_price();                                                                                                                                                                                                        │
│         uint256 frax_total_supply = FRAX.totalSupply();                                                                                                                                                                                              │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│         uint256 global_collat_value = FRAX.globalCollateralValue();                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         (uint256 collateral_units, uint256 amount_to_recollat) = FraxPoolLibrary.calcRecollateralizeFRAXInner(                                                                                                                                       │
│             collateral_amount_d18,                                                                                                                                                                                                                   │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             global_collat_value,                                                                                                                                                                                                                     │
│             frax_total_supply,                                                                                                                                                                                                                       │
│             global_collateral_ratio                                                                                                                                                                                                                  │
│         );                                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         uint256 collateral_units_precision = collateral_units.div(10 ** missing_decimals);                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         uint256 fxs_paid_back = amount_to_recollat.mul(uint(1e6).add(bonus_rate)).div(fxs_price);                                                                                                                                                    │
│                                                                                                                                                                                                                                                      │
│         require(FXS_out_min <= fxs_paid_back, "Slippage limit reached");                                                                                                                                                                             │
│         collateral_token.transferFrom(msg.sender, address(this), collateral_units_precision);                                                                                                                                                        │
│         FXS.pool_mint(msg.sender, fxs_paid_back);                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No", "3": "Yes"}                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function recollateralizeFRAX(uint256 collateral_amount, uint256 FXS_out_min) external {                                                                                                                                                          │
│         require(recollateralizePaused == false, "Recollateralize is paused");                                                                                                                                                                        │
│         uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);                                                                                                                                                                │
│         uint256 fxs_price = FRAX.fxs_price();                                                                                                                                                                                                        │
│         uint256 frax_total_supply = FRAX.totalSupply();                                                                                                                                                                                              │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│         uint256 global_collat_value = FRAX.globalCollateralValue();                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         (uint256 collateral_units, uint256 amount_to_recollat) = FraxPoolLibrary.calcRecollateralizeFRAXInner(                                                                                                                                       │
│             collateral_amount_d18,                                                                                                                                                                                                                   │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             global_collat_value,                                                                                                                                                                                                                     │
│             frax_total_supply,                                                                                                                                                                                                                       │
│             global_collateral_ratio                                                                                                                                                                                                                  │
│         );                                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         uint256 collateral_units_precision = collateral_units.div(10 ** missing_decimals);                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         uint256 fxs_paid_back = amount_to_recollat.mul(uint(1e6).add(bonus_rate)).div(fxs_price);                                                                                                                                                    │
│                                                                                                                                                                                                                                                      │
│         require(FXS_out_min <= fxs_paid_back, "Slippage limit reached");                                                                                                                                                                             │
│         collateral_token.transferFrom(msg.sender, address(this), collateral_units_precision);                                                                                                                                                        │
│         FXS.pool_mint(msg.sender, fxs_paid_back);                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function recollateralizeFRAX(uint256 collateral_amount, uint256 FXS_out_min) external {                                                                                                                                                          │
│         require(recollateralizePaused == false, "Recollateralize is paused");                                                                                                                                                                        │
│         uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);                                                                                                                                                                │
│         uint256 fxs_price = FRAX.fxs_price();                                                                                                                                                                                                        │
│         uint256 frax_total_supply = FRAX.totalSupply();                                                                                                                                                                                              │
│         uint256 global_collateral_ratio = FRAX.global_collateral_ratio();                                                                                                                                                                            │
│         uint256 global_collat_value = FRAX.globalCollateralValue();                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         (uint256 collateral_units, uint256 amount_to_recollat) = FraxPoolLibrary.calcRecollateralizeFRAXInner(                                                                                                                                       │
│             collateral_amount_d18,                                                                                                                                                                                                                   │
│             getCollateralPrice(),                                                                                                                                                                                                                    │
│             global_collat_value,                                                                                                                                                                                                                     │
│             frax_total_supply,                                                                                                                                                                                                                       │
│             global_collateral_ratio                                                                                                                                                                                                                  │
│         );                                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         uint256 collateral_units_precision = collateral_units.div(10 ** missing_decimals);                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         uint256 fxs_paid_back = amount_to_recollat.mul(uint(1e6).add(bonus_rate)).div(fxs_price);                                                                                                                                                    │
│                                                                                                                                                                                                                                                      │
│         require(FXS_out_min <= fxs_paid_back, "Slippage limit reached");                                                                                                                                                                             │
│         collateral_token.transferFrom(msg.sender, address(this), collateral_units_precision);                                                                                                                                                        │
│         FXS.pool_mint(msg.sender, fxs_paid_back);                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay) external onlyByOwnerOrGovernance {                                                                                                         │
│         pool_ceiling = new_ceiling;                                                                                                                                                                                                                  │
│         bonus_rate = new_bonus_rate;                                                                                                                                                                                                                 │
│         redemption_delay = new_redemption_delay;                                                                                                                                                                                                     │
│         minting_fee = FRAX.minting_fee();                                                                                                                                                                                                            │
│         redemption_fee = FRAX.redemption_fee();                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {                                                                                                                                                           │
│         address feeTo = IUniswapV2Factory(factory).feeTo();                                                                                                                                                                                          │
│         feeOn = feeTo != address(0);                                                                                                                                                                                                                 │
│         uint _kLast = kLast; // gas savings                                                                                                                                                                                                          │
│         if (feeOn) {                                                                                                                                                                                                                                 │
│             if (_kLast != 0) {                                                                                                                                                                                                                       │
│                 uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                                                                                                                                                                              │
│                 uint rootKLast = Math.sqrt(_kLast);                                                                                                                                                                                                  │
│                 if (rootK > rootKLast) {                                                                                                                                                                                                             │
│                     uint numerator = totalSupply.mul(rootK.sub(rootKLast));                                                                                                                                                                          │
│                     uint denominator = rootK.mul(5).add(rootKLast);                                                                                                                                                                                  │
│                     uint liquidity = numerator / denominator;                                                                                                                                                                                        │
│                     if (liquidity > 0) _mint(feeTo, liquidity);                                                                                                                                                                                      │
│                 }                                                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                                                        │
│         } else if (_kLast != 0) {                                                                                                                                                                                                                    │
│             kLast = 0;                                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function _mint(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(address(0), account, amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _totalSupply = _totalSupply.add(amount);                                                                                                                                                                                                     │
│         _balances = _balances.add(amount);                                                                                                                                                                                                           │
│         emit Transfer(address(0), account, amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                                                              │
│         uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _approve(account, _msgSender(), decreasedAllowance);                                                                                                                                                                                         │
│         _burn(account, amount);                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function _burn(address account, uint256 amount) internal virtual {                                                                                                                                                                               │
│         require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _beforeTokenTransfer(account, address(0), amount);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                                      │
│         _balances = _balances.sub(amount, "ERC20: burn amount exceeds balance");                                                                                                                                                                     │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                                                     │
│         emit Transfer(account, address(0), amount);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│         IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                     │
│         assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                               │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│         IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                     │
│         assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                               │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│                                                                                                                                                                                                                                                      │
│                                                                                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(WETH, msg.sender, pair, amountETH);                                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         // IWETH(WETH).transferFrom(msg.sender, pair, amountETH);                                                                                                                                                                                    │
│         // IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                  │
│         // assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // require(false, "HELLO: HOW ARE YOU TODAY!");                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         liquidity = IUniswapV2Pair(pair).mint(to); // << PROBLEM IS HERE                                                                                                                                                                             │
│                                                                                                                                                                                                                                                      │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
│     function _addLiquidity(                                                                                                                                                                                                                          │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin                                                                                                                                                                                                                              │
│     ) internal virtual returns (uint amountA, uint amountB) {                                                                                                                                                                                        │
│         // create the pair if it doesn't exist yet                                                                                                                                                                                                   │
│         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {                                                                                                                                                                      │
│             IUniswapV2Factory(factory).createPair(tokenA, tokenB);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│         (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);                                                                                                                                                      │
│         if (reserveA == 0 && reserveB == 0) {                                                                                                                                                                                                        │
│             (amountA, amountB) = (amountADesired, amountBDesired);                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                                                     │
│             uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);                                                                                                                                                        │
│             if (amountBOptimal <= amountBDesired) {                                                                                                                                                                                                  │
│                 require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountADesired, amountBOptimal);                                                                                                                                                                               │
│             } else {                                                                                                                                                                                                                                 │
│                 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);                                                                                                                                                    │
│                 assert(amountAOptimal <= amountADesired);                                                                                                                                                                                            │
│                 require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');                                                                                                                                                     │
│                 (amountA, amountB) = (amountAOptimal, amountBDesired);                                                                                                                                                                               │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidity(                                                                                                                                                                                                                           │
│         address tokenA,                                                                                                                                                                                                                              │
│         address tokenB,                                                                                                                                                                                                                              │
│         uint amountADesired,                                                                                                                                                                                                                         │
│         uint amountBDesired,                                                                                                                                                                                                                         │
│         uint amountAMin,                                                                                                                                                                                                                             │
│         uint amountBMin,                                                                                                                                                                                                                             │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {                                                                                                                                              │
│         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);                                                                                                                                  │
│         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);                                                                                                                                                                            │
│         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);                                                                                                                                                                          │
│         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);                                                                                                                                                                          │
│         liquidity = IUniswapV2Pair(pair).mint(to);                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function addLiquidityETH(                                                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint amountTokenDesired,                                                                                                                                                                                                                     │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {                                                                                                                                │
│         (amountToken, amountETH) = _addLiquidity(                                                                                                                                                                                                    │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             amountTokenDesired,                                                                                                                                                                                                                      │
│             msg.value,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin                                                                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);                                                                                                                                                                       │
│                                                                                                                                                                                                                                                      │
│                                                                                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(WETH, msg.sender, pair, amountETH);                                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         // IWETH(WETH).transferFrom(msg.sender, pair, amountETH);                                                                                                                                                                                    │
│         // IWETH(WETH).deposit{value: amountETH}();                                                                                                                                                                                                  │
│         // assert(IWETH(WETH).transfer(pair, amountETH));                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // require(false, "HELLO: HOW ARE YOU TODAY!");                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         liquidity = IUniswapV2Pair(pair).mint(to); // << PROBLEM IS HERE                                                                                                                                                                             │
│                                                                                                                                                                                                                                                      │
│         // refund dust eth, if any                                                                                                                                                                                                                   │
│         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);                                                                                                                                                │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermit(                                                                                                                                                                                                           │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountToken, uint amountETH) {                                                                                                                                                                         │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermit(                                                                                                                                                                                                           │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountToken, uint amountETH) {                                                                                                                                                                         │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermit(                                                                                                                                                                                                           │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountToken, uint amountETH) {                                                                                                                                                                         │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermit(                                                                                                                                                                                                           │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountToken, uint amountETH) {                                                                                                                                                                         │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETH(                                                                                                                                                                                                                     │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {                                                                                                                                                          │
│         (amountToken, amountETH) = removeLiquidity(                                                                                                                                                                                                  │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, amountToken);                                                                                                                                                                                         │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ have code statements that get or calculate LP token's value/price                                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ have code statements that get or calculate LP token's value/price                                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                                                                    │
│ have code statements that get or calculate LP token's value/price                                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum value check                          │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                        │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) public virtual override ensure(deadline) returns (uint amountETH) {                                                                                                                                                                            │
│         (, amountETH) = removeLiquidity(                                                                                                                                                                                                             │
│             token,                                                                                                                                                                                                                                   │
│             WETH,                                                                                                                                                                                                                                    │
│             liquidity,                                                                                                                                                                                                                               │
│             amountTokenMin,                                                                                                                                                                                                                          │
│             amountETHMin,                                                                                                                                                                                                                            │
│             address(this),                                                                                                                                                                                                                           │
│             deadline                                                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                                                           │
│         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));                                                                                                                                                              │
│         IWETH(WETH).withdraw(amountETH);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountETH);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender                                                                                                                                                                   │
│ Code:                                                                                                                                                                                                                                                │
│     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(                                                                                                                                                                              │
│         address token,                                                                                                                                                                                                                               │
│         uint liquidity,                                                                                                                                                                                                                              │
│         uint amountTokenMin,                                                                                                                                                                                                                         │
│         uint amountETHMin,                                                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline,                                                                                                                                                                                                                               │
│         bool approveMax, uint8 v, bytes32 r, bytes32 s                                                                                                                                                                                               │
│     ) external virtual override returns (uint amountETH) {                                                                                                                                                                                           │
│         address pair = UniswapV2Library.pairFor(factory, token, WETH);                                                                                                                                                                               │
│         uint value = approveMax ? uint(-1) : liquidity;                                                                                                                                                                                              │
│         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);                                                                                                                                                            │
│         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(                                                                                                                                                                                 │
│             token, liquidity, amountTokenMin, amountETHMin, to, deadline                                                                                                                                                                             │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         // for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                  │
│         //     (address input, address output) = (path, path);                                                                                                                                                                                       │
│         //     (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                       │
│         //     IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                               │
│         //     uint amountInput;                                                                                                                                                                                                                     │
│         //     uint amountOutput;                                                                                                                                                                                                                    │
│         //     { // scope to avoid stack too deep errors                                                                                                                                                                                             │
│         //     (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                 │
│         //     (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                              │
│         //     amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                               │
│         //     amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                               │
│         //     }                                                                                                                                                                                                                                     │
│         //     (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                             │
│         //     address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                             │
│         //     pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                  │
│         // }                                                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForETHSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                      │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                       │
│         );                                                                                                                                                                                                                                           │
│         _swapSupportingFeeOnTransferTokens(path, address(this));                                                                                                                                                                                     │
│         uint amountOut = IERC20(WETH).balanceOf(address(this));                                                                                                                                                                                      │
│         require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                           │
│         IWETH(WETH).withdraw(amountOut);                                                                                                                                                                                                             │
│         TransferHelper.safeTransferETH(to, amountOut);                                                                                                                                                                                               │
│     }                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         // for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                  │
│         //     (address input, address output) = (path, path);                                                                                                                                                                                       │
│         //     (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                       │
│         //     IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                               │
│         //     uint amountInput;                                                                                                                                                                                                                     │
│         //     uint amountOutput;                                                                                                                                                                                                                    │
│         //     { // scope to avoid stack too deep errors                                                                                                                                                                                             │
│         //     (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                 │
│         //     (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                              │
│         //     amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                               │
│         //     amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                               │
│         //     }                                                                                                                                                                                                                                     │
│         //     (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                             │
│         //     address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                             │
│         //     pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                  │
│         // }                                                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactETHForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         payable                                                                                                                                                                                                                                      │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                   │
│         uint amountIn = msg.value;                                                                                                                                                                                                                   │
│         IWETH(WETH).deposit{value: amountIn}();                                                                                                                                                                                                      │
│         assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));                                                                                                                                                 │
│         uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                             │
│         _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                                │
│         require(                                                                                                                                                                                                                                     │
│             IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                           │
│             'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                            │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         // for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                  │
│         //     (address input, address output) = (path, path);                                                                                                                                                                                       │
│         //     (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                       │
│         //     IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                               │
│         //     uint amountInput;                                                                                                                                                                                                                     │
│         //     uint amountOutput;                                                                                                                                                                                                                    │
│         //     { // scope to avoid stack too deep errors                                                                                                                                                                                             │
│         //     (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                 │
│         //     (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                              │
│         //     amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                               │
│         //     amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                               │
│         //     }                                                                                                                                                                                                                                     │
│         //     (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                             │
│         //     address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                             │
│         //     pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                  │
│         // }                                                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                  │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) {                                                                                                                                                                                                   │
│         TransferHelper.safeTransferFrom(                                                                                                                                                                                                             │
│             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                       │
│         );                                                                                                                                                                                                                                           │
│         uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                             │
│         _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                                │
│         require(                                                                                                                                                                                                                                     │
│             IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                           │
│             'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                            │
│         );                                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                                │
│     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {                                                                                                                                               │
│         // for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                  │
│         //     (address input, address output) = (path, path);                                                                                                                                                                                       │
│         //     (address token0,) = UniswapV2Library.sortTokens(input, output);                                                                                                                                                                       │
│         //     IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));                                                                                                                                               │
│         //     uint amountInput;                                                                                                                                                                                                                     │
│         //     uint amountOutput;                                                                                                                                                                                                                    │
│         //     { // scope to avoid stack too deep errors                                                                                                                                                                                             │
│         //     (uint reserve0, uint reserve1,) = pair.getReserves();                                                                                                                                                                                 │
│         //     (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                              │
│         //     amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);                                                                                                                                                               │
│         //     amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);                                                                                                                                               │
│         //     }                                                                                                                                                                                                                                     │
│         //     (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));                                                                                                                             │
│         //     address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path) : _to;                                                                                                                                             │
│         //     pair.swap(amount0Out, amount1Out, to, new bytes(0));                                                                                                                                                                                  │
│         // }                                                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                  │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     ) external virtual override ensure(deadline) {                                                                                                                                                                                                   │
│         // TransferHelper.safeTransferFrom(                                                                                                                                                                                                          │
│         //     path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                    │
│         // );                                                                                                                                                                                                                                        │
│         // uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                          │
│         // _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                             │
│         // require(                                                                                                                                                                                                                                  │
│         //     IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                        │
│         //     'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                         │
│         // );                                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender                                                                                                                                                                   │
│ have code statements that get or calculate LP token's value/price                                                                                                                                                                                    │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactETHForTokensSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         payable                                                                                                                                                                                                                                      │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         // require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                │
│         // uint amountIn = msg.value;                                                                                                                                                                                                                │
│         // IWETH(WETH).deposit{value: amountIn}();                                                                                                                                                                                                   │
│         // assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));                                                                                                                                              │
│         // uint balanceBefore = IERC20(path).balanceOf(to);                                                                                                                                                                                          │
│         // _swapSupportingFeeOnTransferTokens(path, to);                                                                                                                                                                                             │
│         // require(                                                                                                                                                                                                                                  │
│         //     IERC20(path).balanceOf(to).sub(balanceBefore) >= amountOutMin,                                                                                                                                                                        │
│         //     'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'                                                                                                                                                                                         │
│         // );                                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swapExactTokensForETHSupportingFeeOnTransferTokens(                                                                                                                                                                                     │
│         uint amountIn,                                                                                                                                                                                                                               │
│         uint amountOutMin,                                                                                                                                                                                                                           │
│         address[] calldata path,                                                                                                                                                                                                                     │
│         address to,                                                                                                                                                                                                                                  │
│         uint deadline                                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                                │
│         external                                                                                                                                                                                                                                     │
│         virtual                                                                                                                                                                                                                                      │
│         override                                                                                                                                                                                                                                     │
│         ensure(deadline)                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                                │
│         // require(path == WETH, 'UniswapV2Router: INVALID_PATH');                                                                                                                                                                                   │
│         // TransferHelper.safeTransferFrom(                                                                                                                                                                                                          │
│         //     path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn                                                                                                                                                    │
│         // );                                                                                                                                                                                                                                        │
│         // _swapSupportingFeeOnTransferTokens(path, address(this));                                                                                                                                                                                  │
│         // uint amountOut = IERC20(WETH).balanceOf(address(this));                                                                                                                                                                                   │
│         // require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                        │
│         // IWETH(WETH).withdraw(amountOut);                                                                                                                                                                                                          │
│         // TransferHelper.safeTransferETH(to, amountOut);                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function retroCatchUp() internal {                                                                                                                                                                                                               │
│         // Failsafe check                                                                                                                                                                                                                            │
│         require(block.timestamp > periodFinish, "Period has not expired yet!");                                                                                                                                                                      │
│                                                                                                                                                                                                                                                      │
│         // Ensure the provided reward amount is not more than the balance in the contract.                                                                                                                                                           │
│         // This keeps the reward rate in the right range, preventing overflows due to                                                                                                                                                                │
│         // very high values of rewardRate in the earned and rewardsPerToken functions;                                                                                                                                                               │
│         // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.                                                                                                                                                                      │
│         uint256 num_periods_elapsed = uint256(block.timestamp.sub(periodFinish)) / rewardsDuration; // Floor division to the nearest period                                                                                                          │
│         uint balance = rewardsToken.balanceOf(address(this));                                                                                                                                                                                        │
│         require(rewardRate.mul(rewardsDuration).mul(crBoostMultiplier()).mul(num_periods_elapsed + 1).div(PRICE_PRECISION) <= balance, "Not enough FXS available for rewards!");                                                                     │
│                                                                                                                                                                                                                                                      │
│         // uint256 old_lastUpdateTime = lastUpdateTime;                                                                                                                                                                                              │
│         // uint256 new_lastUpdateTime = block.timestamp;                                                                                                                                                                                             │
│                                                                                                                                                                                                                                                      │
│         // lastUpdateTime = periodFinish;                                                                                                                                                                                                            │
│         periodFinish = periodFinish.add((num_periods_elapsed.add(1)).mul(rewardsDuration));                                                                                                                                                          │
│                                                                                                                                                                                                                                                      │
│         rewardPerTokenStored = rewardPerToken();                                                                                                                                                                                                     │
│         lastUpdateTime = lastTimeRewardApplicable();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                                      │
│         emit RewardsPeriodRenewed(address(stakingToken));                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function mint(address to) external override lock returns (uint liquidity) {                                                                                                                                                                      │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(token0).balanceOf(address(this));                                                                                                                                                                                     │
│         uint balance1 = IERC20(token1).balanceOf(address(this));                                                                                                                                                                                     │
│         uint amount0 = balance0.sub(_reserve0);                                                                                                                                                                                                      │
│         uint amount1 = balance1.sub(_reserve1);                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         if (_totalSupply == 0) {                                                                                                                                                                                                                     │
│             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);                                                                                                                                                                      │
│            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens                                                                                                                                              │
│         } else {                                                                                                                                                                                                                                     │
│             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');                                                                                                                                                                          │
│         _mint(to, liquidity);                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Mint(msg.sender, amount0, amount1);                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {                                                                                                                    │
│         require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');                                                                                                                                                                                 │
│         amounts = new uint[](path.length);                                                                                                                                                                                                           │
│         amounts = amountOut;                                                                                                                                                                                                                         │
│         for (uint i = path.length - 1; i > 0; i--) {                                                                                                                                                                                                 │
│             (uint reserveIn, uint reserveOut) = getReserves(factory, path, path);                                                                                                                                                                    │
│             amounts = getAmountIn(amounts, reserveIn, reserveOut);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {                                                                                                                    │
│         require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');                                                                                                                                                                                 │
│         amounts = new uint[](path.length);                                                                                                                                                                                                           │
│         amounts = amountOut;                                                                                                                                                                                                                         │
│         for (uint i = path.length - 1; i > 0; i--) {                                                                                                                                                                                                 │
│             (uint reserveIn, uint reserveOut) = getReserves(factory, path, path);                                                                                                                                                                    │
│             amounts = getAmountIn(amounts, reserveIn, reserveOut);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function currentCumulativePrices(                                                                                                                                                                                                                │
│         address pair                                                                                                                                                                                                                                 │
│     ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {                                                                                                                                                  │
│         blockTimestamp = currentBlockTimestamp();                                                                                                                                                                                                    │
│         price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();                                                                                                                                                                              │
│         price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         // if time has elapsed since the last update on the pair, mock the accumulated price values                                                                                                                                                  │
│         (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();                                                                                                                                        │
│         if (blockTimestampLast != blockTimestamp) {                                                                                                                                                                                                  │
│             // subtraction overflow is desired                                                                                                                                                                                                       │
│             uint32 timeElapsed = blockTimestamp - blockTimestampLast;                                                                                                                                                                                │
│             // addition overflow is desired                                                                                                                                                                                                          │
│             // counterfactual                                                                                                                                                                                                                        │
│             price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;                                                                                                                                                      │
│             // counterfactual                                                                                                                                                                                                                        │
│             price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;                                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function currentCumulativePrices(                                                                                                                                                                                                                │
│         address pair                                                                                                                                                                                                                                 │
│     ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {                                                                                                                                                  │
│         blockTimestamp = currentBlockTimestamp();                                                                                                                                                                                                    │
│         price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();                                                                                                                                                                              │
│         price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         // if time has elapsed since the last update on the pair, mock the accumulated price values                                                                                                                                                  │
│         (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();                                                                                                                                        │
│         if (blockTimestampLast != blockTimestamp) {                                                                                                                                                                                                  │
│             // subtraction overflow is desired                                                                                                                                                                                                       │
│             uint32 timeElapsed = blockTimestamp - blockTimestampLast;                                                                                                                                                                                │
│             // addition overflow is desired                                                                                                                                                                                                          │
│             // counterfactual                                                                                                                                                                                                                        │
│             price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;                                                                                                                                                      │
│             // counterfactual                                                                                                                                                                                                                        │
│             price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;                                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function burn(address to) external override lock returns (uint amount0, uint amount1) {                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         address _token0 = token0;                                // gas savings                                                                                                                                                                      │
│         address _token1 = token1;                                // gas savings                                                                                                                                                                      │
│         uint balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                    │
│         uint balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                    │
│         uint liquidity = balanceOf;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                                      │
│         bool feeOn = _mintFee(_reserve0, _reserve1);                                                                                                                                                                                                 │
│         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee                                                                                                                               │
│         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution                                                                                                                                            │
│         require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');                                                                                                                                                             │
│         _burn(address(this), liquidity);                                                                                                                                                                                                             │
│         _safeTransfer(_token0, to, amount0);                                                                                                                                                                                                         │
│         _safeTransfer(_token1, to, amount1);                                                                                                                                                                                                         │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date                                                                                                                                                     │
│         emit Burn(msg.sender, amount0, amount1, to);                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {                                                                                                                                        │
│         require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');                                                                                                                                                          │
│         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings                                                                                                                                                                      │
│         require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         uint balance0;                                                                                                                                                                                                                               │
│         uint balance1;                                                                                                                                                                                                                               │
│         { // scope for _token{0,1}, avoids stack too deep errors                                                                                                                                                                                     │
│         address _token0 = token0;                                                                                                                                                                                                                    │
│         address _token1 = token1;                                                                                                                                                                                                                    │
│         require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');                                                                                                                                                                            │
│         if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens                                                                                                                                                │
│         if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens                                                                                                                                                │
│         if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);                                                                                                                                           │
│         balance0 = IERC20(_token0).balanceOf(address(this));                                                                                                                                                                                         │
│         balance1 = IERC20(_token1).balanceOf(address(this));                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                            │
│         uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;                                                                                                                                                │
│         uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;                                                                                                                                                │
│         require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');                                                                                                                                                             │
│         { // scope for reserve{0,1}Adjusted, avoids stack too deep errors                                                                                                                                                                            │
│         uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));                                                                                                                                                                            │
│         uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));                                                                                                                                                                            │
│         require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');                                                                                                                              │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         _update(balance0, balance1, _reserve0, _reserve1);                                                                                                                                                                                           │
│         emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {                                                                                                                    │
│         require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');                                                                                                                                                                                 │
│         amounts = new uint[](path.length);                                                                                                                                                                                                           │
│         amounts[0] = amountIn;                                                                                                                                                                                                                       │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (uint reserveIn, uint reserveOut) = getReserves(factory, path, path);                                                                                                                                                                    │
│             amounts = getAmountOut(amounts, reserveIn, reserveOut);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {                                                                                                                    │
│         require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');                                                                                                                                                                                 │
│         amounts = new uint[](path.length);                                                                                                                                                                                                           │
│         amounts[0] = amountIn;                                                                                                                                                                                                                       │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (uint reserveIn, uint reserveOut) = getReserves(factory, path, path);                                                                                                                                                                    │
│             amounts = getAmountOut(amounts, reserveIn, reserveOut);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
│     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {                                                                                                                     │
│         (address token0,) = sortTokens(tokenA, tokenB);                                                                                                                                                                                              │
│         (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();                                                                                                                                            │
│         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);                                                                                                                                                       │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {                                                                                                                    │
│         require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');                                                                                                                                                                                 │
│         amounts = new uint[](path.length);                                                                                                                                                                                                           │
│         amounts[0] = amountIn;                                                                                                                                                                                                                       │
│         for (uint i; i < path.length - 1; i++) {                                                                                                                                                                                                     │
│             (uint reserveIn, uint reserveOut) = getReserves(factory, path, path);                                                                                                                                                                    │
│             amounts = getAmountOut(amounts, reserveIn, reserveOut);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {                                                                                                                    │
│         require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');                                                                                                                                                                                 │
│         amounts = new uint[](path.length);                                                                                                                                                                                                           │
│         amounts = amountOut;                                                                                                                                                                                                                         │
│         for (uint i = path.length - 1; i > 0; i--) {                                                                                                                                                                                                 │
│             (uint reserveIn, uint reserveOut) = getReserves(factory, path, path);                                                                                                                                                                    │
│             amounts = getAmountIn(amounts, reserveIn, reserveOut);                                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function currentCumulativePrices(                                                                                                                                                                                                                │
│         address pair                                                                                                                                                                                                                                 │
│     ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {                                                                                                                                                  │
│         blockTimestamp = currentBlockTimestamp();                                                                                                                                                                                                    │
│         price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();                                                                                                                                                                              │
│         price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         // if time has elapsed since the last update on the pair, mock the accumulated price values                                                                                                                                                  │
│         (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();                                                                                                                                        │
│         if (blockTimestampLast != blockTimestamp) {                                                                                                                                                                                                  │
│             // subtraction overflow is desired                                                                                                                                                                                                       │
│             uint32 timeElapsed = blockTimestamp - blockTimestampLast;                                                                                                                                                                                │
│             // addition overflow is desired                                                                                                                                                                                                          │
│             // counterfactual                                                                                                                                                                                                                        │
│             price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;                                                                                                                                                      │
│             // counterfactual                                                                                                                                                                                                                        │
│             price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;                                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                               │
│ Code:                                                                                                                                                                                                                                                │
│     function currentCumulativePrices(                                                                                                                                                                                                                │
│         address pair                                                                                                                                                                                                                                 │
│     ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {                                                                                                                                                  │
│         blockTimestamp = currentBlockTimestamp();                                                                                                                                                                                                    │
│         price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();                                                                                                                                                                              │
│         price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         // if time has elapsed since the last update on the pair, mock the accumulated price values                                                                                                                                                  │
│         (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();                                                                                                                                        │
│         if (blockTimestampLast != blockTimestamp) {                                                                                                                                                                                                  │
│             // subtraction overflow is desired                                                                                                                                                                                                       │
│             uint32 timeElapsed = blockTimestamp - blockTimestampLast;                                                                                                                                                                                │
│             // addition overflow is desired                                                                                                                                                                                                          │
│             // counterfactual                                                                                                                                                                                                                        │
│             price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;                                                                                                                                                      │
│             // counterfactual                                                                                                                                                                                                                        │
│             price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;                                                                                                                                                      │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function revoke() public {                                                                                                                                                                                                                       │
│         require(msg.sender == _timelock_address, "Must be called by the timelock contract");                                                                                                                                                         │
│         require(_revocable, "TokenVesting: cannot revoke");                                                                                                                                                                                          │
│         require(!_revoked, "TokenVesting: token already revoked");                                                                                                                                                                                   │
│                                                                                                                                                                                                                                                      │
│         uint256 balance = FXS.balanceOf(address(this));                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│         uint256 unreleased = _releasableAmount();                                                                                                                                                                                                    │
│         uint256 refund = balance.sub(unreleased);                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                                      │
│         _revoked = true;                                                                                                                                                                                                                             │
│                                                                                                                                                                                                                                                      │
│         FXS.transfer(_owner, refund);                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                                      │
│         emit TokenVestingRevoked();                                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                                                                │
│     function _vestedAmount() private view returns (uint256) {                                                                                                                                                                                        │
│         uint256 currentBalance = FXS.balanceOf(address(this));                                                                                                                                                                                       │
│         uint256 totalBalance = currentBalance.add(_released);                                                                                                                                                                                        │
│         if (block.timestamp < _cliff) {                                                                                                                                                                                                              │
│             return 0;                                                                                                                                                                                                                                │
│         } else if (block.timestamp >= _start.add(_duration) || _revoked) {                                                                                                                                                                           │
│             return totalBalance;                                                                                                                                                                                                                     │
│         } else {                                                                                                                                                                                                                                     │
│             return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);                                                                                                                                                                     │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                                │
│     function pool_mint(address m_address, uint256 m_amount) external onlyPools {                                                                                                                                                                     │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                       │
│             uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                                │
│             uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), "pool_mint new votes overflows");                                                                                                                                                  │
│             _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes                                                                                                                                                      │
│             trackVotes(address(this), m_address, uint96(m_amount));                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         super._mint(m_address, m_amount);                                                                                                                                                                                                            │
│         emit FXSMinted(address(this), m_address, m_amount);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                                                        │
│ Code:                                                                                                                                                                                                                                                │
│     function pool_mint(address m_address, uint256 m_amount) external onlyPools {                                                                                                                                                                     │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                       │
│             uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                                │
│             uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), "pool_mint new votes overflows");                                                                                                                                                  │
│             _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes                                                                                                                                                      │
│             trackVotes(address(this), m_address, uint96(m_amount));                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         super._mint(m_address, m_amount);                                                                                                                                                                                                            │
│         emit FXSMinted(address(this), m_address, m_amount);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                                │
│     function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {                                                                                                                                                                │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             trackVotes(b_address, address(this), uint96(b_amount));                                                                                                                                                                                  │
│             uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                       │
│             uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                                │
│             uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), "pool_burn_from new votes underflows");                                                                                                                                            │
│             _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes                                                                                                                                                          │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         super._burnFrom(b_address, b_amount);                                                                                                                                                                                                        │
│         emit FXSBurned(b_address, address(this), b_amount);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                                                        │
│ Code:                                                                                                                                                                                                                                                │
│     function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {                                                                                                                                                                │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             trackVotes(b_address, address(this), uint96(b_amount));                                                                                                                                                                                  │
│             uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                       │
│             uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                                │
│             uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), "pool_burn_from new votes underflows");                                                                                                                                            │
│             _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes                                                                                                                                                          │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         super._burnFrom(b_address, b_amount);                                                                                                                                                                                                        │
│         emit FXSBurned(b_address, address(this), b_amount);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                                │
│     function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {                                                                                                                                                         │
│         require(blockNumber < block.number, "FXS::getPriorVotes: not yet determined");                                                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         uint32 nCheckpoints = numCheckpoints;                                                                                                                                                                                                        │
│         if (nCheckpoints == 0) {                                                                                                                                                                                                                     │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // First check most recent balance                                                                                                                                                                                                           │
│         if (checkpoints.fromBlock <= blockNumber) {                                                                                                                                                                                                  │
│             return checkpoints.votes;                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // Next check implicit zero balance                                                                                                                                                                                                          │
│         if (checkpoints[0].fromBlock > blockNumber) {                                                                                                                                                                                                │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         uint32 lower = 0;                                                                                                                                                                                                                            │
│         uint32 upper = nCheckpoints - 1;                                                                                                                                                                                                             │
│         while (upper > lower) {                                                                                                                                                                                                                      │
│             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow                                                                                                                                                                  │
│             Checkpoint memory cp = checkpoints;                                                                                                                                                                                                      │
│             if (cp.fromBlock == blockNumber) {                                                                                                                                                                                                       │
│                 return cp.votes;                                                                                                                                                                                                                     │
│             } else if (cp.fromBlock < blockNumber) {                                                                                                                                                                                                 │
│                 lower = center;                                                                                                                                                                                                                      │
│             } else {                                                                                                                                                                                                                                 │
│                 upper = center - 1;                                                                                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         return checkpoints.votes;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                                                        │
│ Code:                                                                                                                                                                                                                                                │
│     function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {                                                                                                                                                         │
│         require(blockNumber < block.number, "FXS::getPriorVotes: not yet determined");                                                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         uint32 nCheckpoints = numCheckpoints;                                                                                                                                                                                                        │
│         if (nCheckpoints == 0) {                                                                                                                                                                                                                     │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // First check most recent balance                                                                                                                                                                                                           │
│         if (checkpoints.fromBlock <= blockNumber) {                                                                                                                                                                                                  │
│             return checkpoints.votes;                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // Next check implicit zero balance                                                                                                                                                                                                          │
│         if (checkpoints[0].fromBlock > blockNumber) {                                                                                                                                                                                                │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         uint32 lower = 0;                                                                                                                                                                                                                            │
│         uint32 upper = nCheckpoints - 1;                                                                                                                                                                                                             │
│         while (upper > lower) {                                                                                                                                                                                                                      │
│             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow                                                                                                                                                                  │
│             Checkpoint memory cp = checkpoints;                                                                                                                                                                                                      │
│             if (cp.fromBlock == blockNumber) {                                                                                                                                                                                                       │
│                 return cp.votes;                                                                                                                                                                                                                     │
│             } else if (cp.fromBlock < blockNumber) {                                                                                                                                                                                                 │
│                 lower = center;                                                                                                                                                                                                                      │
│             } else {                                                                                                                                                                                                                                 │
│                 upper = center - 1;                                                                                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         return checkpoints.votes;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                                │
│     function trackVotes(address srcRep, address dstRep, uint96 amount) internal {                                                                                                                                                                    │
│         if (srcRep != dstRep && amount > 0) {                                                                                                                                                                                                        │
│             if (srcRep != address(0)) {                                                                                                                                                                                                              │
│                 uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                   │
│                 uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                            │
│                 uint96 srcRepNew = sub96(srcRepOld, amount, "FXS::_moveVotes: vote amount underflows");                                                                                                                                              │
│                 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│             if (dstRep != address(0)) {                                                                                                                                                                                                              │
│                 uint32 dstRepNum = numCheckpoints;                                                                                                                                                                                                   │
│                 uint96 dstRepOld = dstRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                            │
│                 uint96 dstRepNew = add96(dstRepOld, amount, "FXS::_moveVotes: vote amount overflows");                                                                                                                                               │
│                 _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                                                        │
│ Code:                                                                                                                                                                                                                                                │
│     function trackVotes(address srcRep, address dstRep, uint96 amount) internal {                                                                                                                                                                    │
│         if (srcRep != dstRep && amount > 0) {                                                                                                                                                                                                        │
│             if (srcRep != address(0)) {                                                                                                                                                                                                              │
│                 uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                   │
│                 uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                            │
│                 uint96 srcRepNew = sub96(srcRepOld, amount, "FXS::_moveVotes: vote amount underflows");                                                                                                                                              │
│                 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│             if (dstRep != address(0)) {                                                                                                                                                                                                              │
│                 uint32 dstRepNum = numCheckpoints;                                                                                                                                                                                                   │
│                 uint96 dstRepOld = dstRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                            │
│                 uint96 dstRepNew = add96(dstRepOld, amount, "FXS::_moveVotes: vote amount overflows");                                                                                                                                               │
│                 _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                                │
│     function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {                                                                                                                                       │
│       uint32 blockNumber = safe32(block.number, "FXS::_writeCheckpoint: block number exceeds 32 bits");                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│       if (nCheckpoints > 0 && checkpoints.fromBlock == blockNumber) {                                                                                                                                                                                │
│           checkpoints.votes = newVotes;                                                                                                                                                                                                              │
│       } else {                                                                                                                                                                                                                                       │
│           checkpoints = Checkpoint(blockNumber, newVotes);                                                                                                                                                                                           │
│           numCheckpoints = nCheckpoints + 1;                                                                                                                                                                                                         │
│       }                                                                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│       emit VoterVotesChanged(voter, oldVotes, newVotes);                                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                                                        │
│ Code:                                                                                                                                                                                                                                                │
│     function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {                                                                                                                                       │
│       uint32 blockNumber = safe32(block.number, "FXS::_writeCheckpoint: block number exceeds 32 bits");                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│       if (nCheckpoints > 0 && checkpoints.fromBlock == blockNumber) {                                                                                                                                                                                │
│           checkpoints.votes = newVotes;                                                                                                                                                                                                              │
│       } else {                                                                                                                                                                                                                                       │
│           checkpoints = Checkpoint(blockNumber, newVotes);                                                                                                                                                                                           │
│           numCheckpoints = nCheckpoints + 1;                                                                                                                                                                                                         │
│       }                                                                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│       emit VoterVotesChanged(voter, oldVotes, newVotes);                                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"Variable name":"_totalSupply", "Description":"This variable holds the total supply of the tokens."}, "VariableB":{"Variable name":"_balances", "Description":"This variable holds the calculated value/price of LP token for the      │
│ specific account."}}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:07] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/akeCollateral.sol, current function: _mint, current vul: price-manipulation     tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 209, in simple_cli                                                                                                                            
                                 raise Exception(                                                                                                                                                                                                       
                             Exception: The description of variable did not pass the `validate_description` validation                                                                                                                                  
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, amount0, amount1, _totalSupply":"These variables are used for the calculation of market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity."},   │
│ "VariableB":{"liquidity":"This variable holds the calculated value/price of LP token."}}                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:10] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/akeCollateral.sol, current function: _mint, current vul: price-manipulation     tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_totalSupply":"Total minted share or amount"}, "VariableB":{"_totalSupply":"Total supply/liquidity used by the conditional branch to determine if the supply/liquidity is 0"}, "VariableC":{"amount":"Value of the deposit/mint/add   │
│ amount"}}                                                                                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:12] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/akeCollateral.sol, current function: _mint, current vul: first-deposit          tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"_totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the supply/liquidity  │
│ is 0."}, "VariableC":{"amount0, amount1":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:14] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/akeCollateral.sol, current function: _mint, current vul: first-deposit          tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_balances":"This variable holds the balance of the custom token for a specific account", "_totalSupply":"This variable holds the total supply of the custom token"}, "VariableB":{"None":"This function does not calculate the        │
│ value/price of LP token"}}                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:16] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/akeCollateral.sol, current function: _burn, current vul: price-manipulation     tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, liquidity, _totalSupply":"These variables hold the market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity calculation."},                     │
│ "VariableB":{"amount0, amount1":"These variables hold the calculated value/price of LP token."}}                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:19] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/akeCollateral.sol, current function: _burn, current vul: price-manipulation     tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserveA, reserveB":"These variables hold the market reserves for tokenA and tokenB respectively, obtained from the UniswapV2Library.getReserves function."}, "VariableB":{"amountIn":"This variable holds the calculated value/price │
│ of LP token, computed by the computeProfitMaximizingTrade function."}}                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:22] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/wapToPrice.sol, current function: swapToPrice, current vul: price-manipulation  tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1":"These variables hold the market reserves. The liquidity calculation is done using these reserves in the function."}, "VariableB":{"liquidity":"This variable holds the calculated value of LP token."}}        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:25] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mintFee, current vul: price-manipulation   tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, liquidity, _totalSupply":"These variables hold the market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity calculation."},                     │
│ "VariableB":{"amount0, amount1":"These variables hold the calculated value/price of LP token."}}                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:27] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mintFee, current vul: price-manipulation   tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, amount0, amount1, _totalSupply":"These variables are used for the calculation of market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity."},   │
│ "VariableB":{"liquidity":"This variable holds the calculated value/price of LP token."}}                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:29] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mintFee, current vul: price-manipulation   tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"totalSupply":"This variable holds the total minted share or amount."}, "VariableB":{"totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the supply/liquidity is 0."}, │
│ "VariableC":{"_reserve0, _reserve1":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:31] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mintFee, current vul: first-deposit        tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"_totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the supply/liquidity  │
│ is 0."}, "VariableC":{"amount0, amount1":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:34] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mintFee, current vul: first-deposit        tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, amount0, amount1, _totalSupply":"These variables are used for the calculation of market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity."},   │
│ "VariableB":{"liquidity":"This variable holds the calculated value/price of LP token."}}                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:36] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: mint, current vul: price-manipulation       tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"_totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the supply/liquidity  │
│ is 0."}, "VariableC":{"amount0, amount1":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:38] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: mint, current vul: first-deposit            tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: mint, current vul: front-running            tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"IUniswapV2Pair(pair).mint(to)":"This function holds the total supply/liquidity and is used by the conditional branch to determine if the  │
│ supply/liquidity is 0."}, "VariableC":{"amountTokenDesired":"This variable holds the value of the deposit/mint/add amount."}}                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:41] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: mint, current vul: first-deposit            tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"IUniswapV2Pair(pair).mint(to)":"This function holds the total supply/liquidity and is used by the conditional branch to determine if the  │
│ supply/liquidity is 0."}, "VariableC":{"amountADesired, amountBDesired":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:44] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: mint, current vul: first-deposit            tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"IUniswapV2Pair(pair).mint(to)":"This function holds the total supply/liquidity and is used by the conditional branch to determine if the  │
│ supply/liquidity is 0."}, "VariableC":{"amountADesired, amountBDesired":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:47] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: mint, current vul: first-deposit            tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"IUniswapV2Pair(pair).mint(to)":"This function holds the total supply/liquidity and is used by the conditional branch to determine if the  │
│ supply/liquidity is 0."}, "VariableC":{"amountTokenDesired":"This variable holds the value of the deposit/mint/add amount."}}                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:49] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: mint, current vul: first-deposit            tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, liquidity, _totalSupply":"These variables hold the market reserves, exchange rate, custom token balance, total supply, and liquidity calculation."}, "VariableB":{"amount0, amount1":"These │
│ variables hold the calculated value/price of LP token."}}                                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:53] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: burn, current vul: price-manipulation       tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the amount of liquidity to be removed from the pool."}, "VariableB":{"amountA, amountB":"These variables hold the calculated value of LP token after removing liquidity."}}                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:55] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: burn, current vul: price-manipulation       tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the amount of liquidity to be removed from the pool."}, "VariableB":{"amountA and amountB":"These variables hold the calculated value of LP token."}}                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:29:57] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: burn, current vul: price-manipulation       tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"totalSupply":"This variable holds the total supply of the custom token", "balanceOf":"This function holds the balance of the custom token for a specific address"}, "VariableB":{}}                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:00] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mint, current vul: price-manipulation      tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, amount0, amount1, _totalSupply":"These variables are used for the calculation of market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity."},   │
│ "VariableB":{"liquidity":"This variable holds the calculated value/price of LP token."}}                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:02] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mint, current vul: price-manipulation      tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"totalSupply":"This variable holds the value of total minted share or amount"}, "VariableB":{"totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the supply/liquidity  │
│ is 0"}, "VariableC":{"value":"This variable holds the value of the deposit/mint/add amount"}}                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:06] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mint, current vul: first-deposit           tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"_totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the supply/liquidity  │
│ is 0."}, "VariableC":{"amount0, amount1":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:09] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _mint, current vul: first-deposit           tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balanceOf":"This variable holds the custom token balance of a specific address", "totalSupply":"This variable holds the total supply of the custom tokens"}, "VariableB":{}}                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:10] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _burn, current vul: price-manipulation      tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, liquidity, _totalSupply":"These variables hold the market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity calculation."},                     │
│ "VariableB":{"amount0, amount1":"These variables hold the calculated value/price of LP token."}}                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:13] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Pair.sol, current function: _burn, current vul: price-manipulation      tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserveA, reserveB":"These variables hold the market reserves for tokenA and tokenB respectively."}, "VariableB":{"amountA, amountB":"These variables hold the calculated value of LP token."}}                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:15] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Router02.sol, current function: _addLiquidity, current vul:             tasks.py:260
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"amountTokenDesired":"This variable holds the desired amount of custom tokens to be added to the liquidity pool", "amountETHMin":"This variable holds the minimum amount of ETH to be added to the liquidity pool",                    │
│ "amountToken":"This variable holds the actual amount of custom tokens added to the liquidity pool", "amountETH":"This variable holds the actual amount of ETH added to the liquidity pool"}, "VariableB":{"liquidity":"This variable holds the       │
│ calculated value of LP token"}}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:18] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Router02.sol, current function: _addLiquidity, current vul:             tasks.py:359
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserve0, reserve1":"These variables hold the market reserves for the two tokens in the pair. They are fetched from the getReserves function of the UniswapV2Pair contract.", "amountInput":"This variable holds the balance of the   │
│ input token in the pair contract, subtracting the reserve of the input token.", "amountOutput":"This variable holds the calculated output amount for the swap, which is calculated using the getAmountOut function of the UniswapV2Library with the  │
│ input amount and the reserves of the input and output tokens."}, "VariableB":{"amountOutput":"This variable holds the calculated output amount for the swap, which is calculated using the getAmountOut function of the UniswapV2Library with the    │
│ input amount and the reserves of the input and output tokens."}}                                                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:25] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Router02.sol, current function: _swapSupportingFeeOnTransferTokens,     tasks.py:260
                             current vul: price-manipulation                                                                                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 209, in simple_cli                                                                                                                            
                                 raise Exception(                                                                                                                                                                                                       
                             Exception: The description of variable did not pass the `validate_description` validation                                                                                                                                  
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"amountIn":"This variable holds the amount of tokens that the user wants to swap. It can be considered as a part of the liquidity calculation as it represents the amount of tokens that are being added to the liquidity pool."},     │
│ "VariableB":{"balanceBefore":"This variable holds the balance of the destination token in the 'to' address before the swap operation. It is used to calculate the actual amount of tokens received after the swap."}}                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:28] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Router02.sol, current function: _swapSupportingFeeOnTransferTokens,     tasks.py:359
                             current vul: price-manipulation                                                                                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 310, in simple_cli                                                                                                                            
                                 raise Exception(                                                                                                                                                                                                       
                             Exception: The description of variable did not pass the validation                                                                                                                                                         
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"total_supply":"This variable holds the total supply of the custom token FRAX.", "global_collateral_ratio":"This variable holds the market reserves or exchange rate.", "global_collat_value":"This variable holds the total value of  │
│ the collateral in the system."}, "VariableB":{"required_collat_dollar_value_d18":"This variable holds the calculated value of LP token."}}                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:31] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/raxPool.sol, current function: availableExcessCollatDV, current vul:            tasks.py:260
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"fxs_price":"This variable holds the price of the FXS token. It is fetched from the FRAX contract using the fxs_price() function.", "availableExcessCollatDV":"This function calculates the available excess collateral in the         │
│ system.", "getCollateralPrice":"This function gets the price of the collateral.", "FXS_amount":"This variable holds the amount of FXS tokens to be bought back.", "collateral_equivalent_d18":"This variable holds the equivalent amount of          │
│ collateral for the FXS tokens to be bought back, calculated by the calcBuyBackFXS function in the FraxPoolLibrary.", "collateral_precision":"This variable holds the equivalent amount of collateral with the correct precision, calculated by       │
│ dividing collateral_equivalent_d18 by 10 to the power of missing_decimals."}, "VariableB":{"collateral_precision":"This variable holds the calculated value of the LP token. It is calculated by dividing the equivalent amount of collateral (in    │
│ D18) by 10 to the power of missing decimals."}}                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:38] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/raxPool.sol, current function: availableExcessCollatDV, current vul:            tasks.py:359
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"collateral_token.balanceOf":"This function returns the balance of the collateral token in the contract's address. It is used to check if the pool's ceiling has been reached.", "getCollateralPrice":"This function returns the price │
│ of the collateral. It is used in the calculation of the amount of FRAX to be minted.", "FRAX.global_collateral_ratio":"This function returns the global collateral ratio of the FRAX token. It is used to ensure that the collateral ratio is        │
│ greater than or equal to 1."}, "VariableB":{"frax_amount_d18":"This variable holds the calculated amount of FRAX to be minted. It is calculated using the FraxPoolLibrary's calcMint1t1FRAX function."}}                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:44] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/raxPool.sol, current function: mint1t1FRAX, current vul: price-manipulation     tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral)":"This is the balance of the custom token in the contract. It is used to calculate the liquidity in the pool.", "frax_price":"This is the price of the FRAX    │
│ token in the AMM.", "fxs_price":"This is the price of the FXS token in the AMM.", "global_collateral_ratio":"This is the global collateral ratio used in the AMM price calculation.", "getCollateralPrice()":"This is the price of the collateral in │
│ the AMM."}, "VariableB":{"mint_amount":"This is the calculated value/price of the LP token."}}                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:49] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/raxPool.sol, current function: mintFractionalFRAX, current vul:                 tasks.py:260
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"fxs_price":"This variable holds the price of the FXS token. It is used in the calculation of the amount of FXS to be paid back during recollateralization.", "frax_total_supply":"This variable holds the total supply of the FRAX    │
│ token. It is used in the calculation of the amount to recollateralize.", "global_collateral_ratio":"This variable holds the global collateral ratio. It is used in the calculation of the amount to recollateralize.", "global_collat_value":"This   │
│ variable holds the global collateral value. It is used in the calculation of the amount to recollateralize.", "getCollateralPrice()":"This function returns the price of the collateral. It is used in the calculation of the amount to              │
│ recollateralize."}, "VariableB":{"fxs_paid_back":"This variable holds the calculated value of the amount of FXS to be paid back during recollateralization."}}                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:56] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/raxPool.sol, current function: recollateralizeFRAX, current vul:                tasks.py:260
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"Variable name":"_totalSupply","Description":"This variable holds the total supply of the tokens."}, "VariableB":{"Variable name":"_balances","Description":"This variable holds the calculated value/price of LP token for the        │
│ specific account."}}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:30:58] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20Custom.sol, current function: _mint, current vul: price-manipulation        tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 209, in simple_cli                                                                                                                            
                                 raise Exception(                                                                                                                                                                                                       
                             Exception: The description of variable did not pass the `validate_description` validation                                                                                                                                  
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, amount0, amount1, _totalSupply":"These variables are used for market reserves, AMM price, exchange rate, custom token balanceOf, totalSupply, amount, and liquidity calculation."},         │
│ "VariableB":{"liquidity":"This variable holds the calculated value/price of LP token."}}                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:00] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20Custom.sol, current function: _mint, current vul: price-manipulation        tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_totalSupply":"Total minted share or amount"}, "VariableB":{"_totalSupply":"Total supply/liquidity used by the conditional branch to determine if the supply/liquidity is 0"}, "VariableC":{"amount":"Value of the deposit/mint/add   │
│ amount"}}                                                                                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:04] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20Custom.sol, current function: _mint, current vul: first-deposit             tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"_totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the supply/liquidity  │
│ is 0."}, "VariableC":{"amount0, amount1":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:12] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20Custom.sol, current function: _mint, current vul: first-deposit             tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_balances":"This variable holds the balance of the custom token for a specific account", "_totalSupply":"This variable holds the total supply of the custom token"}, "VariableB":{}}                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:14] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20Custom.sol, current function: _burn, current vul: price-manipulation        tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, liquidity, _totalSupply":"These variables hold the market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity calculation."},                     │
│ "VariableB":{"amount0, amount1":"These variables hold the calculated value/price of LP token."}}                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:17] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20Custom.sol, current function: _burn, current vul: price-manipulation        tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"Variable name":"_totalSupply","Description":"This variable holds the total supply of the custom tokens."}, "VariableB":{"Variable name":"_balances","Description":"This variable holds the calculated value of LP token for a         │
│ specific account."}}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:18] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20.sol, current function: _mint, current vul: price-manipulation              tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 209, in simple_cli                                                                                                                            
                                 raise Exception(                                                                                                                                                                                                       
                             Exception: The description of variable did not pass the `validate_description` validation                                                                                                                                  
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, amount0, amount1, _totalSupply":"These variables are used for the calculation of market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity."},   │
│ "VariableB":{"liquidity":"This variable holds the calculated value/price of LP token."}}                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:22] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20.sol, current function: _mint, current vul: price-manipulation              tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_totalSupply":"Total minted share or amount"}, "VariableB":{"_totalSupply":"Total supply/liquidity used by the conditional branch to determine if the supply/liquidity is 0"}, "VariableC":{"amount":"Value of the deposit/mint/add   │
│ amount"}}                                                                                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:24] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20.sol, current function: _mint, current vul: first-deposit                   tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"liquidity":"This variable holds the value of total minted share or amount."}, "VariableB":{"_totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the supply/liquidity  │
│ is 0."}, "VariableC":{"amount0, amount1":"These variables hold the value of the deposit/mint/add amount."}}                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:26] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20.sol, current function: _mint, current vul: first-deposit                   tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_balances":"This variable holds the balance of the account from which tokens are being burned", "_totalSupply":"This variable holds the total supply of the tokens"}, "VariableB":{}}                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:28] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20.sol, current function: _burn, current vul: price-manipulation              tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, liquidity, _totalSupply":"These variables hold the market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity calculation."},                     │
│ "VariableB":{"amount0, amount1":"These variables hold the calculated value/price of LP token."}}                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:31] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/RC20.sol, current function: _burn, current vul: price-manipulation              tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserveA, reserveB":"These variables hold the market reserves for tokenA and tokenB respectively."}, "VariableB":{"amountA, amountB":"These variables hold the calculated value/price of LP token."}}                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:33] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Router02_Modified.sol, current function: _addLiquidity, current vul:    tasks.py:260
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"amountToken, amountETH, liquidity":"These variables hold the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"liquidity":"This variable holds the       │
│ calculated value/price of LP token."}}                                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:31:58] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Router02_Modified.sol, current function: _addLiquidity, current vul:    tasks.py:359
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserveA, reserveB":"These variables hold the market reserves for the tokens."}, "VariableB":{}}                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:01] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Library.sol, current function: getReserves, current vul:                tasks.py:260
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserveIn, reserveOut":"These variables hold the market reserves for the token pairs in the path."}, "VariableB":{"amounts":"This array holds the calculated values of the required input amount for each token pair in the path."}}  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:02] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Library.sol, current function: getReserves, current vul:                tasks.py:359
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserve0, reserve1":"These variables hold the market reserves or liquidity calculation for the two tokens in the pair."}, "VariableB":{"price0Cumulative, price1Cumulative":"These variables hold the calculated value/price of LP    │
│ token."}}                                                                                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:06] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Library.sol, current function: getReserves, current vul:                tasks.py:359
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserveA, reserveB":"These variables hold the market reserves for the tokens."}, "VariableB":{"None":"This function does not calculate the value/price of LP token."}}                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:07] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Library.sol, current function: getReserves, current vul:                tasks.py:359
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_reserve0, _reserve1, balance0, balance1, liquidity, _totalSupply":"These variables hold the market reserves, AMM price, exchange rate, custom token balance, total supply, amount, and liquidity calculation."},                     │
│ "VariableB":{"amount0, amount1":"These variables hold the calculated value/price of LP token."}}                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:10] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Library.sol, current function: getReserves, current vul:                tasks.py:359
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserveIn, reserveOut":"These variables hold the market reserves for the token pair in the path. They are used to calculate the output amount of the swap."}, "VariableB":{"amounts":"This array holds the calculated output amounts  │
│ for each token in the path. The final value in the array is the calculated value/price of the LP token."}}                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:12] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2Library.sol, current function: getReserves, current vul:                tasks.py:359
                             price-manipulation                                                                                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                            
                                 falcon_instance, function2_text)                                                                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"reserve0, reserve1":"These variables hold the market reserves or liquidity calculation. They are fetched from the getReserves() function of the Uniswap pair contract."}, "VariableB":{"price0Cumulative, price1Cumulative":"These    │
│ variables hold the calculated value/price of LP token. They are calculated based on the market reserves and the time elapsed since the last update."}}                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:15] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/niswapV2OracleLibrary.sol, current function: currentCumulativePrices, current   tasks.py:260
                             vul: price-manipulation                                                                                                                                                                                                    
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                                                       │
│ Code:                                                                                                                                                                                                                                                │
│     function pool_mint(address m_address, uint256 m_amount) external onlyPools {                                                                                                                                                                     │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                       │
│             uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                                │
│             uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), "pool_mint new votes overflows");                                                                                                                                                  │
│             _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes                                                                                                                                                      │
│             trackVotes(address(this), m_address, uint96(m_amount));                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         super._mint(m_address, m_amount);                                                                                                                                                                                                            │
│         emit FXSMinted(address(this), m_address, m_amount);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to invoke user checkpoint in the given code is `_writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew);`.                                                                                                              │
│                                                                                                                                                                                                                                                      │
│ Please note that the function `_writeCheckpoint` is not directly visible in the provided code snippet, but it is implied to be a function that handles user checkpoints based on the context.                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                          │
│ Code:                                                                                                                                                                                                                                                │
│     function pool_mint(address m_address, uint256 m_amount) external onlyPools {                                                                                                                                                                     │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                       │
│             uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                                │
│             uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), "pool_mint new votes overflows");                                                                                                                                                  │
│             _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes                                                                                                                                                      │
│             trackVotes(address(this), m_address, uint96(m_amount));                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         super._mint(m_address, m_amount);                                                                                                                                                                                                            │
│         emit FXSMinted(address(this), m_address, m_amount);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), "pool_mint new votes overflows");`                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:18] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/XS.sol, current function: pool_mint, current vul: wrong-order-checkpoint        tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                                                       │
│ Code:                                                                                                                                                                                                                                                │
│     function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {                                                                                                                                                                │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             trackVotes(b_address, address(this), uint96(b_amount));                                                                                                                                                                                  │
│             uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                       │
│             uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                                │
│             uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), "pool_burn_from new votes underflows");                                                                                                                                            │
│             _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes                                                                                                                                                          │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         super._burnFrom(b_address, b_amount);                                                                                                                                                                                                        │
│         emit FXSBurned(b_address, address(this), b_amount);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to invoke user checkpoint in the given code is `_writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew);`.                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                          │
│ Code:                                                                                                                                                                                                                                                │
│     function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {                                                                                                                                                                │
│         if(trackingVotes){                                                                                                                                                                                                                           │
│             trackVotes(b_address, address(this), uint96(b_amount));                                                                                                                                                                                  │
│             uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                       │
│             uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                                │
│             uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), "pool_burn_from new votes underflows");                                                                                                                                            │
│             _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes                                                                                                                                                          │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         super._burnFrom(b_address, b_amount);                                                                                                                                                                                                        │
│         emit FXSBurned(b_address, address(this), b_amount);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `trackVotes(b_address, address(this), uint96(b_amount));`                                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:20] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/XS.sol, current function: pool_burn_from, current vul: wrong-order-checkpoint   tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                                                       │
│ Code:                                                                                                                                                                                                                                                │
│     function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {                                                                                                                                                         │
│         require(blockNumber < block.number, "FXS::getPriorVotes: not yet determined");                                                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         uint32 nCheckpoints = numCheckpoints;                                                                                                                                                                                                        │
│         if (nCheckpoints == 0) {                                                                                                                                                                                                                     │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // First check most recent balance                                                                                                                                                                                                           │
│         if (checkpoints.fromBlock <= blockNumber) {                                                                                                                                                                                                  │
│             return checkpoints.votes;                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // Next check implicit zero balance                                                                                                                                                                                                          │
│         if (checkpoints[0].fromBlock > blockNumber) {                                                                                                                                                                                                │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         uint32 lower = 0;                                                                                                                                                                                                                            │
│         uint32 upper = nCheckpoints - 1;                                                                                                                                                                                                             │
│         while (upper > lower) {                                                                                                                                                                                                                      │
│             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow                                                                                                                                                                  │
│             Checkpoint memory cp = checkpoints;                                                                                                                                                                                                      │
│             if (cp.fromBlock == blockNumber) {                                                                                                                                                                                                       │
│                 return cp.votes;                                                                                                                                                                                                                     │
│             } else if (cp.fromBlock < blockNumber) {                                                                                                                                                                                                 │
│                 lower = center;                                                                                                                                                                                                                      │
│             } else {                                                                                                                                                                                                                                 │
│                 upper = center - 1;                                                                                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         return checkpoints.votes;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to invoke user checkpoint in the given code is `if (checkpoints.fromBlock <= blockNumber)`.                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                          │
│ Code:                                                                                                                                                                                                                                                │
│     function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {                                                                                                                                                         │
│         require(blockNumber < block.number, "FXS::getPriorVotes: not yet determined");                                                                                                                                                               │
│                                                                                                                                                                                                                                                      │
│         uint32 nCheckpoints = numCheckpoints;                                                                                                                                                                                                        │
│         if (nCheckpoints == 0) {                                                                                                                                                                                                                     │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // First check most recent balance                                                                                                                                                                                                           │
│         if (checkpoints.fromBlock <= blockNumber) {                                                                                                                                                                                                  │
│             return checkpoints.votes;                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         // Next check implicit zero balance                                                                                                                                                                                                          │
│         if (checkpoints[0].fromBlock > blockNumber) {                                                                                                                                                                                                │
│             return 0;                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                                      │
│         uint32 lower = 0;                                                                                                                                                                                                                            │
│         uint32 upper = nCheckpoints - 1;                                                                                                                                                                                                             │
│         while (upper > lower) {                                                                                                                                                                                                                      │
│             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow                                                                                                                                                                  │
│             Checkpoint memory cp = checkpoints;                                                                                                                                                                                                      │
│             if (cp.fromBlock == blockNumber) {                                                                                                                                                                                                       │
│                 return cp.votes;                                                                                                                                                                                                                     │
│             } else if (cp.fromBlock < blockNumber) {                                                                                                                                                                                                 │
│                 lower = center;                                                                                                                                                                                                                      │
│             } else {                                                                                                                                                                                                                                 │
│                 upper = center - 1;                                                                                                                                                                                                                  │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│         return checkpoints.votes;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint32 nCheckpoints = numCheckpoints;`                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:23] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/XS.sol, current function: getPriorVotes, current vul: wrong-order-checkpoint    tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                                                       │
│ Code:                                                                                                                                                                                                                                                │
│     function trackVotes(address srcRep, address dstRep, uint96 amount) internal {                                                                                                                                                                    │
│         if (srcRep != dstRep && amount > 0) {                                                                                                                                                                                                        │
│             if (srcRep != address(0)) {                                                                                                                                                                                                              │
│                 uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                   │
│                 uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                            │
│                 uint96 srcRepNew = sub96(srcRepOld, amount, "FXS::_moveVotes: vote amount underflows");                                                                                                                                              │
│                 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│             if (dstRep != address(0)) {                                                                                                                                                                                                              │
│                 uint32 dstRepNum = numCheckpoints;                                                                                                                                                                                                   │
│                 uint96 dstRepOld = dstRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                            │
│                 uint96 dstRepNew = add96(dstRepOld, amount, "FXS::_moveVotes: vote amount overflows");                                                                                                                                               │
│                 _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to invoke user checkpoint is `_writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);`.                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                          │
│ Code:                                                                                                                                                                                                                                                │
│     function trackVotes(address srcRep, address dstRep, uint96 amount) internal {                                                                                                                                                                    │
│         if (srcRep != dstRep && amount > 0) {                                                                                                                                                                                                        │
│             if (srcRep != address(0)) {                                                                                                                                                                                                              │
│                 uint32 srcRepNum = numCheckpoints;                                                                                                                                                                                                   │
│                 uint96 srcRepOld = srcRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                            │
│                 uint96 srcRepNew = sub96(srcRepOld, amount, "FXS::_moveVotes: vote amount underflows");                                                                                                                                              │
│                 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                                      │
│             if (dstRep != address(0)) {                                                                                                                                                                                                              │
│                 uint32 dstRepNum = numCheckpoints;                                                                                                                                                                                                   │
│                 uint96 dstRepOld = dstRepNum > 0 ? checkpoints.votes : 0;                                                                                                                                                                            │
│                 uint96 dstRepNew = add96(dstRepOld, amount, "FXS::_moveVotes: vote amount overflows");                                                                                                                                               │
│                 _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward in the given code is `uint32 srcRepNum = numCheckpoints;`.                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:26] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/XS.sol, current function: trackVotes, current vul: wrong-order-checkpoint       tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                                                       │
│ Code:                                                                                                                                                                                                                                                │
│     function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {                                                                                                                                       │
│       uint32 blockNumber = safe32(block.number, "FXS::_writeCheckpoint: block number exceeds 32 bits");                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│       if (nCheckpoints > 0 && checkpoints.fromBlock == blockNumber) {                                                                                                                                                                                │
│           checkpoints.votes = newVotes;                                                                                                                                                                                                              │
│       } else {                                                                                                                                                                                                                                       │
│           checkpoints = Checkpoint(blockNumber, newVotes);                                                                                                                                                                                           │
│           numCheckpoints = nCheckpoints + 1;                                                                                                                                                                                                         │
│       }                                                                                                                                                                                                                                              │
│                                                                                                                                                                                                                                                      │
│       emit VoterVotesChanged(voter, oldVotes, newVotes);                                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to invoke user checkpoint in the given code is `checkpoints.fromBlock == blockNumber`.                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 14:32:28] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                                    tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0_eth/XS.sol, current function: _writeCheckpoint, current vul: wrong-order-checkpoint tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                                      tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                            
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                                       
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                           
                                                                                                                                                                                                                                                        
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                   Summary                    
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value               ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 67                  │
│ Contracts            │ 68                  │
│ Functions            │ 170                 │
│ Lines of Code        │ 7734                │
│ Used Time            │ 367.0298082828522   │
│ Estimated Cost (USD) │ 0.18429700000000002 │
└──────────────────────┴─────────────────────┘
