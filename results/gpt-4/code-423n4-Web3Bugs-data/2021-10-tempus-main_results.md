

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[16:49:10] Loaded 10 rules                                                                                                                                                                                                          tasks.py:119
[12/08/24 16:49:10] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main)                                                                    subprocess.py:41
[12/08/24 16:49:11] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                                                 subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                                             subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                                                            
                             stdout: Ok to proceed? (y)                                                                                                                                                                                         
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                                                          subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-08T23_49_10_337Z-debug-0.log                                                                                           
                    INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main)                                                           subprocess.py:41
[12/08/24 16:56:09] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                                                 subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                                             subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                                                            
                             stdout: Ok to proceed? (y)                                                                                                                                                                                         
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                                                          subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-08T23_49_12_006Z-debug-0.log                                                                                           
[12/08/24 16:56:11] INFO     CryticCompile: Problem executing hardhat: npm warn exec The following package was not found and will be installed: hardhat@2.22.17                                                                   hardhat.py:327
                             npm error Invalid Version:                                                                                                                                                                                         
                             npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-08T23_56_09_918Z-debug-0.log                                                                                                   
                                                                                                                                                                                                                                                
                    INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main)                                                          subprocess.py:41
[12/08/24 16:56:20] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                                                 subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                                             subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                                                            
                             stdout: Ok to proceed? (y)                                                                                                                                                                                         
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                                                          subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-08T23_56_11_087Z-debug-0.log                                                                                           
[16:56:20] Traceback (most recent call last):                                                                                                                                                                                       tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                                                  
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                                                 
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                                                 
               self._compile(**kwargs)                                                                                                                                                                                                          
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                                                 
               self._platform.compile(self, **kwargs)                                                                                                                                                                                           
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 183, in compile                                                                                
               hardhat_like_parsing(crytic_compile, self._target, build_directory, hardhat_working_dir)                                                                                                                                         
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 52, in hardhat_like_parsing                                                                    
               raise InvalidCompilation(txt)                                                                                                                                                                                                    
           crytic_compile.platform.exceptions.InvalidCompilation: Compilation failed. Can you run build command?                                                                                                                                
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/artifacts/build-info is not a directory.                                                                                                              
                                                                                                                                                                                                                                                
           During handling of the above exception, another exception occurred:                                                                                                                                                                  
                                                                                                                                                                                                                                                
           Traceback (most recent call last):                                                                                                                                                                                                   
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                                                      
               falcon_instance = compile_project(source_dir)                                                                                                                                                                                    
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                                                 
               return falcon.Falcon(abs_path)                                                                                                                                                                                                   
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                                                  
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                                                            
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                                                  
           Compilation failed. Can you run build command?                                                                                                                                                                                       
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/artifacts/build-info is not a directory.                                                                                                              
                                                                                                                                                                                                                                                
           Compile failed.                                                                                                                                                                                                          tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                                               tasks.py:128
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _provideLiquidity(                                                                                                                                                                                                              │
│         address sender,                                                                                                                                                                                                                      │
│         IVault vault,                                                                                                                                                                                                                        │
│         bytes32 poolId,                                                                                                                                                                                                                      │
│         IERC20[] memory ammTokens,                                                                                                                                                                                                           │
│         uint256[] memory ammBalances,                                                                                                                                                                                                        │
│         uint256 sharesAmount,                                                                                                                                                                                                                │
│         address recipient                                                                                                                                                                                                                    │
│     ) private returns (uint256[] memory) {                                                                                                                                                                                                   │
│         uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         if (sender != address(this)) {                                                                                                                                                                                                       │
│             ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);                                                                                                                                           │
│             ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);                                                                                                                                                 │
│         ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({                                                                                                                                                                     │
│             assets: ammTokens,                                                                                                                                                                                                               │
│             maxAmountsIn: ammLiquidityProvisionAmounts,                                                                                                                                                                                      │
│             userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),                                                                                                                      │
│             fromInternalBalance: false                                                                                                                                                                                                       │
│         });                                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Provide TPS/TYS liquidity to TempusAMM                                                                                                                                                                                            │
│         vault.joinPool(poolId, address(this), recipient, request);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return ammLiquidityProvisionAmounts;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function provideLiquidity(ITempusAMM tempusAMM, uint256 sharesAmount) external nonReentrant {                                                                                                                                            │
│         (                                                                                                                                                                                                                                    │
│             IVault vault,                                                                                                                                                                                                                    │
│             bytes32 poolId,                                                                                                                                                                                                                  │
│             IERC20[] memory ammTokens,                                                                                                                                                                                                       │
│             uint256[] memory ammBalances                                                                                                                                                                                                     │
│         ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _provideLiquidity(msg.sender, vault, poolId, ammTokens, ammBalances, sharesAmount, msg.sender);                                                                                                                                      │
│     }                                                                                                                                                                                                                                        │
│     function _provideLiquidity(                                                                                                                                                                                                              │
│         address sender,                                                                                                                                                                                                                      │
│         IVault vault,                                                                                                                                                                                                                        │
│         bytes32 poolId,                                                                                                                                                                                                                      │
│         IERC20[] memory ammTokens,                                                                                                                                                                                                           │
│         uint256[] memory ammBalances,                                                                                                                                                                                                        │
│         uint256 sharesAmount,                                                                                                                                                                                                                │
│         address recipient                                                                                                                                                                                                                    │
│     ) private returns (uint256[] memory) {                                                                                                                                                                                                   │
│         uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         if (sender != address(this)) {                                                                                                                                                                                                       │
│             ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);                                                                                                                                           │
│             ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);                                                                                                                                                 │
│         ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({                                                                                                                                                                     │
│             assets: ammTokens,                                                                                                                                                                                                               │
│             maxAmountsIn: ammLiquidityProvisionAmounts,                                                                                                                                                                                      │
│             userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),                                                                                                                      │
│             fromInternalBalance: false                                                                                                                                                                                                       │
│         });                                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Provide TPS/TYS liquidity to TempusAMM                                                                                                                                                                                            │
│         vault.joinPool(poolId, address(this), recipient, request);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return ammLiquidityProvisionAmounts;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _depositAndProvideLiquidity(                                                                                                                                                                                                    │
│         ITempusAMM tempusAMM,                                                                                                                                                                                                                │
│         uint256 tokenAmount,                                                                                                                                                                                                                 │
│         bool isBackingToken                                                                                                                                                                                                                  │
│     ) private {                                                                                                                                                                                                                              │
│         (                                                                                                                                                                                                                                    │
│             IVault vault,                                                                                                                                                                                                                    │
│             bytes32 poolId,                                                                                                                                                                                                                  │
│             IERC20[] memory ammTokens,                                                                                                                                                                                                       │
│             uint256[] memory ammBalances                                                                                                                                                                                                     │
│         ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         uint256 mintedShares = _deposit(tempusAMM.tempusPool(), tokenAmount, isBackingToken);                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         uint256[] memory sharesUsed = _provideLiquidity(                                                                                                                                                                                     │
│             address(this),                                                                                                                                                                                                                   │
│             vault,                                                                                                                                                                                                                           │
│             poolId,                                                                                                                                                                                                                          │
│             ammTokens,                                                                                                                                                                                                                       │
│             ammBalances,                                                                                                                                                                                                                     │
│             mintedShares,                                                                                                                                                                                                                    │
│             msg.sender                                                                                                                                                                                                                       │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Send remaining Shares to user                                                                                                                                                                                                     │
│         if (sharesUsed[0] < mintedShares) {                                                                                                                                                                                                  │
│             ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│         if (sharesUsed[1] < mintedShares) {                                                                                                                                                                                                  │
│             ammTokens[1].safeTransfer(msg.sender, mintedShares - sharesUsed[1]);                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _provideLiquidity(                                                                                                                                                                                                              │
│         address sender,                                                                                                                                                                                                                      │
│         IVault vault,                                                                                                                                                                                                                        │
│         bytes32 poolId,                                                                                                                                                                                                                      │
│         IERC20[] memory ammTokens,                                                                                                                                                                                                           │
│         uint256[] memory ammBalances,                                                                                                                                                                                                        │
│         uint256 sharesAmount,                                                                                                                                                                                                                │
│         address recipient                                                                                                                                                                                                                    │
│     ) private returns (uint256[] memory) {                                                                                                                                                                                                   │
│         uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         if (sender != address(this)) {                                                                                                                                                                                                       │
│             ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);                                                                                                                                           │
│             ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);                                                                                                                                                 │
│         ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({                                                                                                                                                                     │
│             assets: ammTokens,                                                                                                                                                                                                               │
│             maxAmountsIn: ammLiquidityProvisionAmounts,                                                                                                                                                                                      │
│             userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),                                                                                                                      │
│             fromInternalBalance: false                                                                                                                                                                                                       │
│         });                                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Provide TPS/TYS liquidity to TempusAMM                                                                                                                                                                                            │
│         vault.joinPool(poolId, address(this), recipient, request);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return ammLiquidityProvisionAmounts;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _depositAndFix(                                                                                                                                                                                                                 │
│         ITempusAMM tempusAMM,                                                                                                                                                                                                                │
│         uint256 tokenAmount,                                                                                                                                                                                                                 │
│         bool isBackingToken,                                                                                                                                                                                                                 │
│         uint256 minTYSRate                                                                                                                                                                                                                   │
│     ) private {                                                                                                                                                                                                                              │
│         ITempusPool targetPool = tempusAMM.tempusPool();                                                                                                                                                                                     │
│         IERC20 principalShares = IERC20(address(targetPool.principalShare()));                                                                                                                                                               │
│         IERC20 yieldShares = IERC20(address(targetPool.yieldShare()));                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         uint256 swapAmount = _deposit(targetPool, tokenAmount, isBackingToken);                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         yieldShares.safeIncreaseAllowance(address(tempusAMM.getVault()), swapAmount);                                                                                                                                                        │
│         uint256 minReturn = swapAmount.mulfV(minTYSRate, targetPool.backingTokenONE());                                                                                                                                                      │
│         swap(tempusAMM, swapAmount, yieldShares, principalShares, minReturn);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         // At this point all TYS must be swapped for TPS                                                                                                                                                                                     │
│         uint256 principalsBalance = principalShares.balanceOf(address(this));                                                                                                                                                                │
│         assert(principalsBalance > 0);                                                                                                                                                                                                       │
│         assert(yieldShares.balanceOf(address(this)) == 0);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         principalShares.safeTransfer(msg.sender, principalsBalance);                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitTempusAMM(                                                                                                                                                                                                                 │
│         ITempusAMM tempusAMM,                                                                                                                                                                                                                │
│         uint256 lpTokensAmount,                                                                                                                                                                                                              │
│         uint256 principalAmountOutMin,                                                                                                                                                                                                       │
│         uint256 yieldAmountOutMin,                                                                                                                                                                                                           │
│         bool toInternalBalances                                                                                                                                                                                                              │
│     ) private {                                                                                                                                                                                                                              │
│         require(tempusAMM.transferFrom(msg.sender, address(this), lpTokensAmount), "LP token transfer failed");                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         ITempusPool tempusPool = tempusAMM.tempusPool();                                                                                                                                                                                     │
│         uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalAmountOutMin, yieldAmountOutMin);                                                                                                                               │
│         _exitTempusAMMGivenLP(tempusAMM, address(this), msg.sender, lpTokensAmount, amounts, toInternalBalances);                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         assert(tempusAMM.balanceOf(address(this)) == 0);                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitTempusAMMAndRedeem(                                                                                                                                                                                                        │
│         ITempusAMM tempusAMM,                                                                                                                                                                                                                │
│         uint256 principals,                                                                                                                                                                                                                  │
│         uint256 yields,                                                                                                                                                                                                                      │
│         uint256 principalsStaked,                                                                                                                                                                                                            │
│         uint256 yieldsStaked,                                                                                                                                                                                                                │
│         uint256 maxLpTokensToRedeem,                                                                                                                                                                                                         │
│         bool toBackingToken                                                                                                                                                                                                                  │
│     ) private {                                                                                                                                                                                                                              │
│         ITempusPool tempusPool = tempusAMM.tempusPool();                                                                                                                                                                                     │
│         require(!tempusPool.matured(), "Pool already finalized");                                                                                                                                                                            │
│         principals += principalsStaked;                                                                                                                                                                                                      │
│         yields += yieldsStaked;                                                                                                                                                                                                              │
│         require(principals == yields, "Needs equal amounts of shares before maturity");                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         // transfer LP tokens to controller                                                                                                                                                                                                  │
│         require(tempusAMM.transferFrom(msg.sender, address(this), maxLpTokensToRedeem), "LP token transfer failed");                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalsStaked, yieldsStaked);                                                                                                                                         │
│         _exitTempusAMMGivenAmountsOut(tempusAMM, address(this), msg.sender, amounts, maxLpTokensToRedeem, false);                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // transfer remainder of LP tokens back to user                                                                                                                                                                                      │
│         uint256 lpTokenBalance = tempusAMM.balanceOf(address(this));                                                                                                                                                                         │
│         require(tempusAMM.transferFrom(address(this), msg.sender, lpTokenBalance), "LP token transfer failed");                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         if (toBackingToken) {                                                                                                                                                                                                                │
│             _redeemToBacking(tempusPool, msg.sender, principals, yields, msg.sender);                                                                                                                                                        │
│         } else {                                                                                                                                                                                                                             │
│             _redeemToYieldBearing(tempusPool, msg.sender, principals, yields, msg.sender);                                                                                                                                                   │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitTempusAmmAndRedeem(                                                                                                                                                                                                        │
│         ITempusAMM tempusAMM,                                                                                                                                                                                                                │
│         uint256 lpTokens,                                                                                                                                                                                                                    │
│         uint256 principals,                                                                                                                                                                                                                  │
│         uint256 yields,                                                                                                                                                                                                                      │
│         uint256[] memory minLpAmountsOut,                                                                                                                                                                                                    │
│         uint256 maxLeftoverShares,                                                                                                                                                                                                           │
│         bool toBackingToken                                                                                                                                                                                                                  │
│     ) private {                                                                                                                                                                                                                              │
│         ITempusPool tempusPool = tempusAMM.tempusPool();                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         IERC20 principalShare = IERC20(address(tempusPool.principalShare()));                                                                                                                                                                │
│         IERC20 yieldShare = IERC20(address(tempusPool.yieldShare()));                                                                                                                                                                        │
│         require(principalShare.transferFrom(msg.sender, address(this), principals), "Principals transfer failed");                                                                                                                           │
│         require(yieldShare.transferFrom(msg.sender, address(this), yields), "Yields transfer failed");                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         if (lpTokens > 0) {                                                                                                                                                                                                                  │
│             // if there is LP balance, transfer to controller                                                                                                                                                                                │
│             require(tempusAMM.transferFrom(msg.sender, address(this), lpTokens), "LP token transfer failed");                                                                                                                                │
│                                                                                                                                                                                                                                              │
│             // exit amm and sent shares to controller                                                                                                                                                                                        │
│             _exitTempusAMMGivenLP(tempusAMM, address(this), address(this), lpTokens, minLpAmountsOut, false);                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         principals = principalShare.balanceOf(address(this));                                                                                                                                                                                │
│         yields = yieldShare.balanceOf(address(this));                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         if (!tempusPool.matured()) {                                                                                                                                                                                                         │
│             bool yieldsIn = yields > principals;                                                                                                                                                                                             │
│             uint256 difference = yieldsIn ? (yields - principals) : (principals - yields);                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│             if (difference >= maxLeftoverShares) {                                                                                                                                                                                           │
│                 (IERC20 tokenIn, IERC20 tokenOut) = yieldsIn                                                                                                                                                                                 │
│                     ? (yieldShare, principalShare)                                                                                                                                                                                           │
│                     : (principalShare, yieldShare);                                                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│                 swap(                                                                                                                                                                                                                        │
│                     tempusAMM,                                                                                                                                                                                                               │
│                     tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),                                                                                                                                      │
│                     tokenIn,                                                                                                                                                                                                                 │
│                     tokenOut,                                                                                                                                                                                                                │
│                     0                                                                                                                                                                                                                        │
│                 );                                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│                 principals = principalShare.balanceOf(address(this));                                                                                                                                                                        │
│                 yields = yieldShare.balanceOf(address(this));                                                                                                                                                                                │
│             }                                                                                                                                                                                                                                │
│             (yields, principals) = (principals <= yields) ? (principals, principals) : (yields, yields);                                                                                                                                     │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         if (toBackingToken) {                                                                                                                                                                                                                │
│             _redeemToBacking(tempusPool, address(this), principals, yields, msg.sender);                                                                                                                                                     │
│         } else {                                                                                                                                                                                                                             │
│             _redeemToYieldBearing(tempusPool, address(this), principals, yields, msg.sender);                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function finalize() external override onlyController {                                                                                                                                                                                   │
│         if (!matured) {                                                                                                                                                                                                                      │
│             require(block.timestamp >= maturityTime, "Maturity not been reached yet.");                                                                                                                                                      │
│             maturityInterestRate = currentInterestRate();                                                                                                                                                                                    │
│             matured = true;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│             assert(IERC20(address(principalShare)).totalSupply() == IERC20(address(yieldShare)).totalSupply());                                                                                                                              │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes", "3": "No"}                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function finalize() external override onlyController {                                                                                                                                                                                   │
│         if (!matured) {                                                                                                                                                                                                                      │
│             require(block.timestamp >= maturityTime, "Maturity not been reached yet.");                                                                                                                                                      │
│             maturityInterestRate = currentInterestRate();                                                                                                                                                                                    │
│             matured = true;                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│             assert(IERC20(address(principalShare)).totalSupply() == IERC20(address(yieldShare)).totalSupply());                                                                                                                              │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function depositBacking(uint256 backingTokenAmount, address recipient)                                                                                                                                                                   │
│         external                                                                                                                                                                                                                             │
│         payable                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 mintedShares,                                                                                                                                                                                                            │
│             uint256 depositedYBT,                                                                                                                                                                                                            │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(backingTokenAmount > 0, "backingTokenAmount must be greater than 0");                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         depositedYBT = depositToUnderlying(backingTokenAmount);                                                                                                                                                                              │
│         assert(depositedYBT > 0);                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (mintedShares, , fee, rate) = _deposit(depositedYBT, recipient);                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                                                            │
│         external                                                                                                                                                                                                                             │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 mintedShares,                                                                                                                                                                                                            │
│             uint256 depositedBT,                                                                                                                                                                                                             │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(yieldTokenAmount > 0, "yieldTokenAmount must be greater than 0");                                                                                                                                                            │
│         // Collect the deposit                                                                                                                                                                                                               │
│         yieldTokenAmount = IERC20(yieldBearingToken).untrustedTransferFrom(msg.sender, address(this), yieldTokenAmount);                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         (mintedShares, depositedBT, fee, rate) = _deposit(yieldTokenAmount, recipient);                                                                                                                                                      │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                                                           │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 mintedShares,                                                                                                                                                                                                            │
│             uint256 depositedBT,                                                                                                                                                                                                             │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(!matured, "Maturity reached.");                                                                                                                                                                                              │
│         rate = updateInterestRate();                                                                                                                                                                                                         │
│         require(rate >= initialInterestRate, "Negative yield!");                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Collect fees if they are set, reducing the number of tokens for the sender                                                                                                                                                        │
│         // thus leaving more YBT in the TempusPool than there are minted TPS/TYS                                                                                                                                                             │
│         uint256 tokenAmount = yieldTokenAmount;                                                                                                                                                                                              │
│         uint256 depositFees = feesConfig.depositPercent;                                                                                                                                                                                     │
│         if (depositFees != 0) {                                                                                                                                                                                                              │
│             fee = tokenAmount.mulfV(depositFees, yieldBearingONE);                                                                                                                                                                           │
│             tokenAmount -= fee;                                                                                                                                                                                                              │
│             totalFees += fee;                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Issue appropriate shares                                                                                                                                                                                                          │
│         depositedBT = numAssetsPerYieldToken(tokenAmount, rate);                                                                                                                                                                             │
│         mintedShares = numSharesToMint(depositedBT, rate);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         PrincipalShare(address(principalShare)).mint(recipient, mintedShares);                                                                                                                                                               │
│         YieldShare(address(yieldShare)).mint(recipient, mintedShares);                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function _deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                                                           │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 mintedShares,                                                                                                                                                                                                            │
│             uint256 depositedBT,                                                                                                                                                                                                             │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(!matured, "Maturity reached.");                                                                                                                                                                                              │
│         rate = updateInterestRate();                                                                                                                                                                                                         │
│         require(rate >= initialInterestRate, "Negative yield!");                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Collect fees if they are set, reducing the number of tokens for the sender                                                                                                                                                        │
│         // thus leaving more YBT in the TempusPool than there are minted TPS/TYS                                                                                                                                                             │
│         uint256 tokenAmount = yieldTokenAmount;                                                                                                                                                                                              │
│         uint256 depositFees = feesConfig.depositPercent;                                                                                                                                                                                     │
│         if (depositFees != 0) {                                                                                                                                                                                                              │
│             fee = tokenAmount.mulfV(depositFees, yieldBearingONE);                                                                                                                                                                           │
│             tokenAmount -= fee;                                                                                                                                                                                                              │
│             totalFees += fee;                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Issue appropriate shares                                                                                                                                                                                                          │
│         depositedBT = numAssetsPerYieldToken(tokenAmount, rate);                                                                                                                                                                             │
│         mintedShares = numSharesToMint(depositedBT, rate);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         PrincipalShare(address(principalShare)).mint(recipient, mintedShares);                                                                                                                                                               │
│         YieldShare(address(yieldShare)).mint(recipient, mintedShares);                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function redeemToBacking(                                                                                                                                                                                                                │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         address recipient                                                                                                                                                                                                                    │
│     )                                                                                                                                                                                                                                        │
│         external                                                                                                                                                                                                                             │
│         payable                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 redeemedBackingTokens,                                                                                                                                                                                                   │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);                                                                                                                                              │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function redeem(                                                                                                                                                                                                                         │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         address recipient                                                                                                                                                                                                                    │
│     )                                                                                                                                                                                                                                        │
│         external                                                                                                                                                                                                                             │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         redeemedYieldTokens = IERC20(yieldBearingToken).untrustedTransfer(recipient, redeemedYieldTokens);                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function burnShares(                                                                                                                                                                                                                     │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                                             │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                                                     │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Burn the appropriate shares                                                                                                                                                                                                       │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                                             │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                                                          │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                                                        │
│         totalFees += fee;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function burnShares(                                                                                                                                                                                                                     │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                                             │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                                                     │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Burn the appropriate shares                                                                                                                                                                                                       │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                                             │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                                                          │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                                                        │
│         totalFees += fee;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function redeem(                                                                                                                                                                                                                         │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         address recipient                                                                                                                                                                                                                    │
│     )                                                                                                                                                                                                                                        │
│         external                                                                                                                                                                                                                             │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         redeemedYieldTokens = IERC20(yieldBearingToken).untrustedTransfer(recipient, redeemedYieldTokens);                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
│     function burnShares(                                                                                                                                                                                                                     │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                                             │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                                                     │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Burn the appropriate shares                                                                                                                                                                                                       │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                                             │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                                                          │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                                                        │
│         totalFees += fee;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function redeemToBacking(                                                                                                                                                                                                                │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         address recipient                                                                                                                                                                                                                    │
│     )                                                                                                                                                                                                                                        │
│         external                                                                                                                                                                                                                             │
│         payable                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 redeemedBackingTokens,                                                                                                                                                                                                   │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);                                                                                                                                              │
│     }                                                                                                                                                                                                                                        │
│     function burnShares(                                                                                                                                                                                                                     │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                                             │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                                                     │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Burn the appropriate shares                                                                                                                                                                                                       │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                                             │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                                                          │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                                                        │
│         totalFees += fee;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getRedemptionAmounts(                                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         uint256 currentRate                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemableYieldTokens,                                                                                                                                                                                                   │
│             uint256 redeemableBackingTokens,                                                                                                                                                                                                 │
│             uint256 redeemFeeAmount,                                                                                                                                                                                                         │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         if (interestRate < initialInterestRate) {                                                                                                                                                                                            │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                                                │
│         } else {                                                                                                                                                                                                                             │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                                                           │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                                                      │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                                                     │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                                                            │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                                                │
│             if (matured && currentRate > interestRate) {                                                                                                                                                                                     │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                                                    │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                                                │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                                                         │
│                     exchangeRateONE                                                                                                                                                                                                          │
│                 );                                                                                                                                                                                                                           │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                                                     │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                                                 │
│         if (redeemFeePercent != 0) {                                                                                                                                                                                                         │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                                                       │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                                                       │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function getRedemptionAmounts(                                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         uint256 currentRate                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemableYieldTokens,                                                                                                                                                                                                   │
│             uint256 redeemableBackingTokens,                                                                                                                                                                                                 │
│             uint256 redeemFeeAmount,                                                                                                                                                                                                         │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         if (interestRate < initialInterestRate) {                                                                                                                                                                                            │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                                                │
│         } else {                                                                                                                                                                                                                             │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                                                           │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                                                      │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                                                     │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                                                            │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                                                │
│             if (matured && currentRate > interestRate) {                                                                                                                                                                                     │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                                                    │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                                                │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                                                         │
│                     exchangeRateONE                                                                                                                                                                                                          │
│                 );                                                                                                                                                                                                                           │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                                                     │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                                                 │
│         if (redeemFeePercent != 0) {                                                                                                                                                                                                         │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                                                       │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                                                       │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function estimatedRedeem(                                                                                                                                                                                                                │
│         uint256 principals,                                                                                                                                                                                                                  │
│         uint256 yields,                                                                                                                                                                                                                      │
│         bool toBackingToken                                                                                                                                                                                                                  │
│     ) public view override returns (uint256) {                                                                                                                                                                                               │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                                                         │
│         (uint256 yieldTokens, uint256 backingTokens, , ) = getRedemptionAmounts(principals, yields, currentRate);                                                                                                                            │
│         return toBackingToken ? backingTokens : yieldTokens;                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
│     function getRedemptionAmounts(                                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         uint256 currentRate                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemableYieldTokens,                                                                                                                                                                                                   │
│             uint256 redeemableBackingTokens,                                                                                                                                                                                                 │
│             uint256 redeemFeeAmount,                                                                                                                                                                                                         │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         if (interestRate < initialInterestRate) {                                                                                                                                                                                            │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                                                │
│         } else {                                                                                                                                                                                                                             │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                                                           │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                                                      │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                                                     │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                                                            │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                                                │
│             if (matured && currentRate > interestRate) {                                                                                                                                                                                     │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                                                    │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                                                │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                                                         │
│                     exchangeRateONE                                                                                                                                                                                                          │
│                 );                                                                                                                                                                                                                           │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                                                     │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                                                 │
│         if (redeemFeePercent != 0) {                                                                                                                                                                                                         │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                                                       │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                                                       │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function burnShares(                                                                                                                                                                                                                     │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                                             │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                                                     │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Burn the appropriate shares                                                                                                                                                                                                       │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                                             │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                                                          │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                                                        │
│         totalFees += fee;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function getRedemptionAmounts(                                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         uint256 currentRate                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemableYieldTokens,                                                                                                                                                                                                   │
│             uint256 redeemableBackingTokens,                                                                                                                                                                                                 │
│             uint256 redeemFeeAmount,                                                                                                                                                                                                         │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         if (interestRate < initialInterestRate) {                                                                                                                                                                                            │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                                                │
│         } else {                                                                                                                                                                                                                             │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                                                           │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                                                      │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                                                     │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                                                            │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                                                │
│             if (matured && currentRate > interestRate) {                                                                                                                                                                                     │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                                                    │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                                                │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                                                         │
│                     exchangeRateONE                                                                                                                                                                                                          │
│                 );                                                                                                                                                                                                                           │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                                                     │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                                                 │
│         if (redeemFeePercent != 0) {                                                                                                                                                                                                         │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                                                       │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                                                       │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                                                           │
│         if (matured) {                                                                                                                                                                                                                       │
│             return yieldCurrent;                                                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                                               │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                                                            │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                                                     │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                                                    │
│         // in case we have estimate for negative yield                                                                                                                                                                                       │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                                                    │
│             return interestRateToSharePrice(currYield);                                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                                                 │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                                                           │
│         if (matured) {                                                                                                                                                                                                                       │
│             return yieldCurrent;                                                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                                               │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                                                            │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                                                     │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                                                        │
│         uint one = exchangeRateONE;                                                                                                                                                                                                          │
│         // in case we have estimate for negative yield                                                                                                                                                                                       │
│         if (estYield < one) {                                                                                                                                                                                                                │
│             return uint256(0);                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                    │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                                                    │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                                                           │
│         if (matured) {                                                                                                                                                                                                                       │
│             return yieldCurrent;                                                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                                               │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                                                            │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                                                     │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                                                        │
│         uint one = exchangeRateONE;                                                                                                                                                                                                          │
│         // in case we have estimate for negative yield                                                                                                                                                                                       │
│         if (estYield < one) {                                                                                                                                                                                                                │
│             return uint256(0);                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                    │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                                                    │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                                                        │
│         uint one = exchangeRateONE;                                                                                                                                                                                                          │
│         // in case we have estimate for negative yield                                                                                                                                                                                       │
│         if (estYield < one) {                                                                                                                                                                                                                │
│             return uint256(0);                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                    │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                                                    │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                                                        │
│         uint one = exchangeRateONE;                                                                                                                                                                                                          │
│         // in case we have estimate for negative yield                                                                                                                                                                                       │
│         if (estYield < one) {                                                                                                                                                                                                                │
│             return uint256(0);                                                                                                                                                                                                               │
│         }                                                                                                                                                                                                                                    │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                                                    │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                                                    │
│         // in case we have estimate for negative yield                                                                                                                                                                                       │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                                                    │
│             return interestRateToSharePrice(currYield);                                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                                                 │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                                                    │
│         // in case we have estimate for negative yield                                                                                                                                                                                       │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                                                    │
│             return interestRateToSharePrice(currYield);                                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                                                 │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                                                    │
│         // in case we have estimate for negative yield                                                                                                                                                                                       │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                                                    │
│             return interestRateToSharePrice(currYield);                                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                                                 │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function estimatedMintedShares(uint256 amount, bool isBackingToken) public view override returns (uint256) {                                                                                                                             │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                                                         │
│         uint256 depositedBT = isBackingToken ? amount : numAssetsPerYieldToken(amount, currentRate);                                                                                                                                         │
│         return numSharesToMint(depositedBT, currentRate);                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function estimatedRedeem(                                                                                                                                                                                                                │
│         uint256 principals,                                                                                                                                                                                                                  │
│         uint256 yields,                                                                                                                                                                                                                      │
│         bool toBackingToken                                                                                                                                                                                                                  │
│     ) public view override returns (uint256) {                                                                                                                                                                                               │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                                                         │
│         (uint256 yieldTokens, uint256 backingTokens, , ) = getRedemptionAmounts(principals, yields, currentRate);                                                                                                                            │
│         return toBackingToken ? backingTokens : yieldTokens;                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                        │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                                              │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                                                  │
│         totalShares = newTotalShares;                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                                                          │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                                                            │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                                                        │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                                             │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                                                         │
│         // number of events.                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                                              │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                                                  │
│         totalShares = newTotalShares;                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                                                          │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                                                            │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                                                        │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                                             │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                                                         │
│         // number of events.                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                        │
│     function _submit(                                                                                                                                                                                                                        │
│         address /*_referral*/                                                                                                                                                                                                                │
│     ) internal returns (uint256) {                                                                                                                                                                                                           │
│         if (mockFailNextDepositOrRedeem) {                                                                                                                                                                                                   │
│             setFailNextDepositOrRedeem(false);                                                                                                                                                                                               │
│             revert("random mock failure from lido");                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         address sender = msg.sender;                                                                                                                                                                                                         │
│         uint256 deposit = msg.value;                                                                                                                                                                                                         │
│         require(deposit != 0, "ZERO_DEPOSIT");                                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint256 sharesAmount = StETH.getSharesByPooledEth(deposit);                                                                                                                                                                          │
│         if (sharesAmount == 0) {                                                                                                                                                                                                             │
│             // totalControlledEther is 0: either the first-ever deposit or complete slashing                                                                                                                                                 │
│             // assume that shares correspond to Ether 1-to-1                                                                                                                                                                                 │
│             sharesAmount = deposit;                                                                                                                                                                                                          │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         _mintShares(sender, sharesAmount);                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Store for submission                                                                                                                                                                                                              │
│         bufferedEther += deposit;                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         return sharesAmount;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                                              │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                                                  │
│         totalShares = newTotalShares;                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                                                          │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                                                            │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                                                        │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                                             │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                                                         │
│         // number of events.                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _submit(                                                                                                                                                                                                                        │
│         address /*_referral*/                                                                                                                                                                                                                │
│     ) internal returns (uint256) {                                                                                                                                                                                                           │
│         if (mockFailNextDepositOrRedeem) {                                                                                                                                                                                                   │
│             setFailNextDepositOrRedeem(false);                                                                                                                                                                                               │
│             revert("random mock failure from lido");                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         address sender = msg.sender;                                                                                                                                                                                                         │
│         uint256 deposit = msg.value;                                                                                                                                                                                                         │
│         require(deposit != 0, "ZERO_DEPOSIT");                                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint256 sharesAmount = StETH.getSharesByPooledEth(deposit);                                                                                                                                                                          │
│         if (sharesAmount == 0) {                                                                                                                                                                                                             │
│             // totalControlledEther is 0: either the first-ever deposit or complete slashing                                                                                                                                                 │
│             // assume that shares correspond to Ether 1-to-1                                                                                                                                                                                 │
│             sharesAmount = deposit;                                                                                                                                                                                                          │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         _mintShares(sender, sharesAmount);                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Store for submission                                                                                                                                                                                                              │
│         bufferedEther += deposit;                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         return sharesAmount;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                                              │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                                                  │
│         totalShares = newTotalShares;                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                                                          │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                                                            │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                                                        │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                                             │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                                                         │
│         // number of events.                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                        │
│     function distributeRewards(uint256 _totalRewards) internal {                                                                                                                                                                             │
│         uint256 fees = _totalRewards * feeBasis;                                                                                                                                                                                             │
│         uint256 sharesToMint = (fees * _getTotalShares()) / ((_getTotalPooledEther() * 1000) - fees);                                                                                                                                        │
│         _mintShares(address(this), sharesToMint);                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // Transfer to insurance fund                                                                                                                                                                                                        │
│         // Transfer to treasury                                                                                                                                                                                                              │
│     }                                                                                                                                                                                                                                        │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                                              │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                                                  │
│         totalShares = newTotalShares;                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                                                          │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                                                            │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                                                        │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                                             │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                                                         │
│         // number of events.                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function distributeRewards(uint256 _totalRewards) internal {                                                                                                                                                                             │
│         uint256 fees = _totalRewards * feeBasis;                                                                                                                                                                                             │
│         uint256 sharesToMint = (fees * _getTotalShares()) / ((_getTotalPooledEther() * 1000) - fees);                                                                                                                                        │
│         _mintShares(address(this), sharesToMint);                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // Transfer to insurance fund                                                                                                                                                                                                        │
│         // Transfer to treasury                                                                                                                                                                                                              │
│     }                                                                                                                                                                                                                                        │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                                              │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                                                  │
│         totalShares = newTotalShares;                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                                                          │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                                                            │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                                                        │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                                             │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                                                         │
│         // number of events.                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                        │
│     function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                                                │
│         require(_account != address(0), "BURN_FROM_THE_ZERO_ADDRESS");                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         uint256 accountShares = shares[_account];                                                                                                                                                                                            │
│         require(_sharesAmount <= accountShares, "BURN_AMOUNT_EXCEEDS_BALANCE");                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         newTotalShares = _getTotalShares() - _sharesAmount;                                                                                                                                                                                  │
│         totalShares = newTotalShares;                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         shares[_account] = accountShares - _sharesAmount;                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Notice: we're not emitting a Transfer event to the zero address here since shares burn                                                                                                                                            │
│         // works by redistributing the amount of tokens corresponding to the burned shares between                                                                                                                                           │
│         // all other token holders. The total supply of the token doesn't change as the result.                                                                                                                                              │
│         // This is equivalent to performing a send from `address` to each other token holder address,                                                                                                                                        │
│         // but we cannot reflect this as it would require sending an unbounded number of events.                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                  │
│ Code:                                                                                                                                                                                                                                        │
│     function withdraw(                                                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                                                     │
│         bytes32 /*_pubkeyHash*/                                                                                                                                                                                                              │
│     ) external {                                                                                                                                                                                                                             │
│         if (mockFailNextDepositOrRedeem) {                                                                                                                                                                                                   │
│             setFailNextDepositOrRedeem(false);                                                                                                                                                                                               │
│             revert("random mock failure from lido");                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         uint256 redeemable = StETH.getPooledEthByShares(_amount);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // Simplification: only allow withdrawing buffered ether.                                                                                                                                                                            │
│         require(redeemable <= bufferedEther, "Can only withdraw up to the buffered ether.");                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         // This validates that enough shares are owned by the account.                                                                                                                                                                       │
│         _burnShares(msg.sender, _amount);                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         payable(msg.sender).transfer(redeemable);                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                        │
│     function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                                                │
│         require(_account != address(0), "BURN_FROM_THE_ZERO_ADDRESS");                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         uint256 accountShares = shares[_account];                                                                                                                                                                                            │
│         require(_sharesAmount <= accountShares, "BURN_AMOUNT_EXCEEDS_BALANCE");                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         newTotalShares = _getTotalShares() - _sharesAmount;                                                                                                                                                                                  │
│         totalShares = newTotalShares;                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         shares[_account] = accountShares - _sharesAmount;                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Notice: we're not emitting a Transfer event to the zero address here since shares burn                                                                                                                                            │
│         // works by redistributing the amount of tokens corresponding to the burned shares between                                                                                                                                           │
│         // all other token holders. The total supply of the token doesn't change as the result.                                                                                                                                              │
│         // This is equivalent to performing a send from `address` to each other token holder address,                                                                                                                                        │
│         // but we cannot reflect this as it would require sending an unbounded number of events.                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function mintFresh(address minter, uint mintAmount) internal returns (uint errorCode, uint actualMintAmount) {                                                                                                                           │
│         uint err = comptroller.mintAllowed(address(this), minter, mintAmount);                                                                                                                                                               │
│         require(err == 0, "mint is not allowed");                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         uint exchangeRate = exchangeRateStored(); // exchangeRate has variable decimal precision                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         /*                                                                                                                                                                                                                                   │
│          *  We call `doTransferIn` for the minter and the mintAmount.                                                                                                                                                                        │
│          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.                                                                                                                                                       │
│          *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if                                                                                                                                                         │
│          *  side-effects occurred. The function returns the amount actually transferred,                                                                                                                                                     │
│          *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`                                                                                                                                                  │
│          *  of cash.                                                                                                                                                                                                                         │
│          */                                                                                                                                                                                                                                  │
│         actualMintAmount = doTransferIn(minter, mintAmount); // 18 decimal precision                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // exchange rate precision: 18 - 8 + Underlying Token Decimals                                                                                                                                                                       │
│         uint mintTokens = (actualMintAmount * 1e18) / exchangeRate; // (18 + 18) - 28 = 8 decimal precision                                                                                                                                  │
│         _mint(minter, mintTokens);                                                                                                                                                                                                           │
│         errorCode = 0;                                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function redeem(uint redeemTokens) external override returns (uint) {                                                                                                                                                                    │
│         ComptrollerMock mock = ComptrollerMock(address(comptroller));                                                                                                                                                                        │
│         if (mock.mockFailNextDepositOrRedeem()) {                                                                                                                                                                                            │
│             mock.setFailNextDepositOrRedeem(false);                                                                                                                                                                                          │
│             return 1;                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Amount of underlying asset to be redeemed:                                                                                                                                                                                        │
│         //  redeemAmount = redeemTokens x exchangeRate                                                                                                                                                                                       │
│         uint256 exchangeRate = exchangeRateStored();                                                                                                                                                                                         │
│         uint256 redeemAmount = (redeemTokens * exchangeRate) / 1e18;                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // burn the yield tokens                                                                                                                                                                                                             │
│         _burn(msg.sender, redeemTokens);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // transfer backing tokens to redeemer                                                                                                                                                                                               │
│         IERC20(underlying).safeTransfer(msg.sender, redeemAmount);                                                                                                                                                                           │
│         return 0; // success                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function redeem(uint redeemTokens) external override returns (uint) {                                                                                                                                                                    │
│         ComptrollerMock mock = ComptrollerMock(address(comptroller));                                                                                                                                                                        │
│         if (mock.mockFailNextDepositOrRedeem()) {                                                                                                                                                                                            │
│             mock.setFailNextDepositOrRedeem(false);                                                                                                                                                                                          │
│             return 1;                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Amount of underlying asset to be redeemed:                                                                                                                                                                                        │
│         //  redeemAmount = redeemTokens x exchangeRate                                                                                                                                                                                       │
│         uint256 exchangeRate = exchangeRateStored();                                                                                                                                                                                         │
│         uint256 redeemAmount = (redeemTokens * exchangeRate) / 1e18;                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // burn the yield tokens                                                                                                                                                                                                             │
│         _burn(msg.sender, redeemTokens);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // transfer backing tokens to redeemer                                                                                                                                                                                               │
│         IERC20(underlying).safeTransfer(msg.sender, redeemAmount);                                                                                                                                                                           │
│         return 0; // success                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function depositToUnderlying(uint256 backingAmount) internal override returns (uint256) {                                                                                                                                                │
│         require(msg.value == 0, "ETH deposits not supported");                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Pull user's Backing Tokens                                                                                                                                                                                                        │
│         backingAmount = IERC20(backingToken).untrustedTransferFrom(msg.sender, address(this), backingAmount);                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         // Deposit to Compound                                                                                                                                                                                                               │
│         IERC20(backingToken).safeIncreaseAllowance(address(cToken), backingAmount);                                                                                                                                                          │
│         require(cToken.mint(backingAmount) == 0, "CErc20 mint failed");                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         return IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function depositBacking(uint256 backingTokenAmount, address recipient)                                                                                                                                                                   │
│         external                                                                                                                                                                                                                             │
│         payable                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 mintedShares,                                                                                                                                                                                                            │
│             uint256 depositedYBT,                                                                                                                                                                                                            │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(backingTokenAmount > 0, "backingTokenAmount must be greater than 0");                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         depositedYBT = depositToUnderlying(backingTokenAmount);                                                                                                                                                                              │
│         assert(depositedYBT > 0);                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (mintedShares, , fee, rate) = _deposit(depositedYBT, recipient);                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
│     function depositToUnderlying(uint256 backingAmount) internal override returns (uint256) {                                                                                                                                                │
│         require(msg.value == 0, "ETH deposits not supported");                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Pull user's Backing Tokens                                                                                                                                                                                                        │
│         backingAmount = IERC20(backingToken).untrustedTransferFrom(msg.sender, address(this), backingAmount);                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         // Deposit to Compound                                                                                                                                                                                                               │
│         IERC20(backingToken).safeIncreaseAllowance(address(cToken), backingAmount);                                                                                                                                                          │
│         require(cToken.mint(backingAmount) == 0, "CErc20 mint failed");                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         return IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                                             │
│         internal                                                                                                                                                                                                                             │
│         override                                                                                                                                                                                                                             │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│         // tempus pool owns YBT                                                                                                                                                                                                              │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                                                 │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                                                        │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                                                            │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                                             │
│         internal                                                                                                                                                                                                                             │
│         override                                                                                                                                                                                                                             │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│         // tempus pool owns YBT                                                                                                                                                                                                              │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                                                 │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                                                        │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                                                            │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function redeemToBacking(                                                                                                                                                                                                                │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         address recipient                                                                                                                                                                                                                    │
│     )                                                                                                                                                                                                                                        │
│         external                                                                                                                                                                                                                             │
│         payable                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 redeemedBackingTokens,                                                                                                                                                                                                   │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);                                                                                                                                              │
│     }                                                                                                                                                                                                                                        │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                                             │
│         internal                                                                                                                                                                                                                             │
│         override                                                                                                                                                                                                                             │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│         // tempus pool owns YBT                                                                                                                                                                                                              │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                                                 │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                                                        │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                                                            │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function depositToUnderlying(uint256 amount) internal override returns (uint256) {                                                                                                                                                       │
│         require(msg.value == amount, "ETH value does not match provided amount");                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         uint256 preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                                                      │
│         lido.submit{value: msg.value}(referrer);                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         /// TODO: figure out why lido.submit returns a different value than this                                                                                                                                                             │
│         uint256 mintedTokens = IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         return mintedTokens;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function depositBacking(uint256 backingTokenAmount, address recipient)                                                                                                                                                                   │
│         external                                                                                                                                                                                                                             │
│         payable                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         onlyController                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256 mintedShares,                                                                                                                                                                                                            │
│             uint256 depositedYBT,                                                                                                                                                                                                            │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(backingTokenAmount > 0, "backingTokenAmount must be greater than 0");                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         depositedYBT = depositToUnderlying(backingTokenAmount);                                                                                                                                                                              │
│         assert(depositedYBT > 0);                                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (mintedShares, , fee, rate) = _deposit(depositedYBT, recipient);                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
│     function depositToUnderlying(uint256 amount) internal override returns (uint256) {                                                                                                                                                       │
│         require(msg.value == amount, "ETH value does not match provided amount");                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         uint256 preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                                                      │
│         lido.submit{value: msg.value}(referrer);                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         /// TODO: figure out why lido.submit returns a different value than this                                                                                                                                                             │
│         uint256 mintedTokens = IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         return mintedTokens;                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                                                     │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                                             │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                                                         │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                                                        │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                                             │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                                                     │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return amountOut;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                                                     │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                                             │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                                                         │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                                                        │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                                             │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                                                     │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return amountOut;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function getSwapAmountToEndWithEqualShares(                                                                                                                                                                                              │
│         uint256 principals,                                                                                                                                                                                                                  │
│         uint256 yields,                                                                                                                                                                                                                      │
│         uint256 threshold                                                                                                                                                                                                                    │
│     ) public view returns (uint256 amountIn) {                                                                                                                                                                                               │
│         (uint256 difference, bool yieldsIn) = (principals > yields)                                                                                                                                                                          │
│             ? (principals - yields, false)                                                                                                                                                                                                   │
│             : (yields - principals, true);                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         if (difference > threshold) {                                                                                                                                                                                                        │
│             uint256 principalsRate = tempusPool.principalShare().getPricePerFullShareStored();                                                                                                                                               │
│             uint256 yieldsRate = tempusPool.yieldShare().getPricePerFullShareStored();                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│             uint256 rate = yieldsIn                                                                                                                                                                                                          │
│                 ? (principalsRate * _TEMPUS_SHARE_PRECISION) / yieldsRate                                                                                                                                                                    │
│                 : (yieldsRate * _TEMPUS_SHARE_PRECISION) / principalsRate;                                                                                                                                                                   │
│             for (uint8 i = 0; i < 32; i++) {                                                                                                                                                                                                 │
│                 // if we have accurate rate this should hold                                                                                                                                                                                 │
│                 amountIn = (difference * _TEMPUS_SHARE_PRECISION) / (rate + _TEMPUS_SHARE_PRECISION);                                                                                                                                        │
│                 uint256 amountOut = getExpectedReturnGivenIn(amountIn, yieldsIn);                                                                                                                                                            │
│                 uint256 newPrincipals = yieldsIn ? (principals + amountOut) : (principals - amountIn);                                                                                                                                       │
│                 uint256 newYields = yieldsIn ? (yields - amountIn) : (yields + amountOut);                                                                                                                                                   │
│                 uint256 newDifference = (newPrincipals > newYields)                                                                                                                                                                          │
│                     ? (newPrincipals - newYields)                                                                                                                                                                                            │
│                     : (newYields - newPrincipals);                                                                                                                                                                                           │
│                 if (newDifference < threshold) {                                                                                                                                                                                             │
│                     return amountIn;                                                                                                                                                                                                         │
│                 } else {                                                                                                                                                                                                                     │
│                     rate = (amountOut * _TEMPUS_SHARE_PRECISION) / amountIn;                                                                                                                                                                 │
│                 }                                                                                                                                                                                                                            │
│             }                                                                                                                                                                                                                                │
│             revert("getSwapAmountToEndWithEqualShares did not converge.");                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                                                     │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                                             │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                                                         │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                                                        │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                                             │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                                                     │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return amountOut;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getSwapAmountToEndWithEqualShares(                                                                                                                                                                                              │
│         uint256 principals,                                                                                                                                                                                                                  │
│         uint256 yields,                                                                                                                                                                                                                      │
│         uint256 threshold                                                                                                                                                                                                                    │
│     ) public view returns (uint256 amountIn) {                                                                                                                                                                                               │
│         (uint256 difference, bool yieldsIn) = (principals > yields)                                                                                                                                                                          │
│             ? (principals - yields, false)                                                                                                                                                                                                   │
│             : (yields - principals, true);                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         if (difference > threshold) {                                                                                                                                                                                                        │
│             uint256 principalsRate = tempusPool.principalShare().getPricePerFullShareStored();                                                                                                                                               │
│             uint256 yieldsRate = tempusPool.yieldShare().getPricePerFullShareStored();                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│             uint256 rate = yieldsIn                                                                                                                                                                                                          │
│                 ? (principalsRate * _TEMPUS_SHARE_PRECISION) / yieldsRate                                                                                                                                                                    │
│                 : (yieldsRate * _TEMPUS_SHARE_PRECISION) / principalsRate;                                                                                                                                                                   │
│             for (uint8 i = 0; i < 32; i++) {                                                                                                                                                                                                 │
│                 // if we have accurate rate this should hold                                                                                                                                                                                 │
│                 amountIn = (difference * _TEMPUS_SHARE_PRECISION) / (rate + _TEMPUS_SHARE_PRECISION);                                                                                                                                        │
│                 uint256 amountOut = getExpectedReturnGivenIn(amountIn, yieldsIn);                                                                                                                                                            │
│                 uint256 newPrincipals = yieldsIn ? (principals + amountOut) : (principals - amountIn);                                                                                                                                       │
│                 uint256 newYields = yieldsIn ? (yields - amountIn) : (yields + amountOut);                                                                                                                                                   │
│                 uint256 newDifference = (newPrincipals > newYields)                                                                                                                                                                          │
│                     ? (newPrincipals - newYields)                                                                                                                                                                                            │
│                     : (newYields - newPrincipals);                                                                                                                                                                                           │
│                 if (newDifference < threshold) {                                                                                                                                                                                             │
│                     return amountIn;                                                                                                                                                                                                         │
│                 } else {                                                                                                                                                                                                                     │
│                     rate = (amountOut * _TEMPUS_SHARE_PRECISION) / amountIn;                                                                                                                                                                 │
│                 }                                                                                                                                                                                                                            │
│             }                                                                                                                                                                                                                                │
│             revert("getSwapAmountToEndWithEqualShares did not converge.");                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                                                     │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                                             │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                                                         │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                                                        │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                                             │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                                                     │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return amountOut;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getSwapAmountToEndWithEqualShares(                                                                                                                                                                                              │
│         uint256 principals,                                                                                                                                                                                                                  │
│         uint256 yields,                                                                                                                                                                                                                      │
│         uint256 threshold                                                                                                                                                                                                                    │
│     ) public view returns (uint256 amountIn) {                                                                                                                                                                                               │
│         (uint256 difference, bool yieldsIn) = (principals > yields)                                                                                                                                                                          │
│             ? (principals - yields, false)                                                                                                                                                                                                   │
│             : (yields - principals, true);                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         if (difference > threshold) {                                                                                                                                                                                                        │
│             uint256 principalsRate = tempusPool.principalShare().getPricePerFullShareStored();                                                                                                                                               │
│             uint256 yieldsRate = tempusPool.yieldShare().getPricePerFullShareStored();                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│             uint256 rate = yieldsIn                                                                                                                                                                                                          │
│                 ? (principalsRate * _TEMPUS_SHARE_PRECISION) / yieldsRate                                                                                                                                                                    │
│                 : (yieldsRate * _TEMPUS_SHARE_PRECISION) / principalsRate;                                                                                                                                                                   │
│             for (uint8 i = 0; i < 32; i++) {                                                                                                                                                                                                 │
│                 // if we have accurate rate this should hold                                                                                                                                                                                 │
│                 amountIn = (difference * _TEMPUS_SHARE_PRECISION) / (rate + _TEMPUS_SHARE_PRECISION);                                                                                                                                        │
│                 uint256 amountOut = getExpectedReturnGivenIn(amountIn, yieldsIn);                                                                                                                                                            │
│                 uint256 newPrincipals = yieldsIn ? (principals + amountOut) : (principals - amountIn);                                                                                                                                       │
│                 uint256 newYields = yieldsIn ? (yields - amountIn) : (yields + amountOut);                                                                                                                                                   │
│                 uint256 newDifference = (newPrincipals > newYields)                                                                                                                                                                          │
│                     ? (newPrincipals - newYields)                                                                                                                                                                                            │
│                     : (newYields - newPrincipals);                                                                                                                                                                                           │
│                 if (newDifference < threshold) {                                                                                                                                                                                             │
│                     return amountIn;                                                                                                                                                                                                         │
│                 } else {                                                                                                                                                                                                                     │
│                     rate = (amountOut * _TEMPUS_SHARE_PRECISION) / amountIn;                                                                                                                                                                 │
│                 }                                                                                                                                                                                                                            │
│             }                                                                                                                                                                                                                                │
│             revert("getSwapAmountToEndWithEqualShares did not converge.");                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getSwapAmountToEndWithEqualShares(                                                                                                                                                                                              │
│         uint256 principals,                                                                                                                                                                                                                  │
│         uint256 yields,                                                                                                                                                                                                                      │
│         uint256 threshold                                                                                                                                                                                                                    │
│     ) public view returns (uint256 amountIn) {                                                                                                                                                                                               │
│         (uint256 difference, bool yieldsIn) = (principals > yields)                                                                                                                                                                          │
│             ? (principals - yields, false)                                                                                                                                                                                                   │
│             : (yields - principals, true);                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         if (difference > threshold) {                                                                                                                                                                                                        │
│             uint256 principalsRate = tempusPool.principalShare().getPricePerFullShareStored();                                                                                                                                               │
│             uint256 yieldsRate = tempusPool.yieldShare().getPricePerFullShareStored();                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│             uint256 rate = yieldsIn                                                                                                                                                                                                          │
│                 ? (principalsRate * _TEMPUS_SHARE_PRECISION) / yieldsRate                                                                                                                                                                    │
│                 : (yieldsRate * _TEMPUS_SHARE_PRECISION) / principalsRate;                                                                                                                                                                   │
│             for (uint8 i = 0; i < 32; i++) {                                                                                                                                                                                                 │
│                 // if we have accurate rate this should hold                                                                                                                                                                                 │
│                 amountIn = (difference * _TEMPUS_SHARE_PRECISION) / (rate + _TEMPUS_SHARE_PRECISION);                                                                                                                                        │
│                 uint256 amountOut = getExpectedReturnGivenIn(amountIn, yieldsIn);                                                                                                                                                            │
│                 uint256 newPrincipals = yieldsIn ? (principals + amountOut) : (principals - amountIn);                                                                                                                                       │
│                 uint256 newYields = yieldsIn ? (yields - amountIn) : (yields + amountOut);                                                                                                                                                   │
│                 uint256 newDifference = (newPrincipals > newYields)                                                                                                                                                                          │
│                     ? (newPrincipals - newYields)                                                                                                                                                                                            │
│                     : (newYields - newPrincipals);                                                                                                                                                                                           │
│                 if (newDifference < threshold) {                                                                                                                                                                                             │
│                     return amountIn;                                                                                                                                                                                                         │
│                 } else {                                                                                                                                                                                                                     │
│                     rate = (amountOut * _TEMPUS_SHARE_PRECISION) / amountIn;                                                                                                                                                                 │
│                 }                                                                                                                                                                                                                            │
│             }                                                                                                                                                                                                                                │
│             revert("getSwapAmountToEndWithEqualShares did not converge.");                                                                                                                                                                   │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                                                  │
│         external                                                                                                                                                                                                                             │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256 lpTokens)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                    │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                                                      │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                                                     │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                                               │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                                                 │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                                             │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                                                │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                 │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                                                          │
│         if (_isNotPaused()) {                                                                                                                                                                                                                │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                                               │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                                 │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             protocolSwapFeePercentage                                                                                                                                                                                                        │
│         );                                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No", "3": "No"}                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                                                  │
│         external                                                                                                                                                                                                                             │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256 lpTokens)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                    │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                                                      │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                                                     │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                                               │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                                                 │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                                             │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                                                │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                 │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                                                          │
│         if (_isNotPaused()) {                                                                                                                                                                                                                │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                                               │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                                 │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             protocolSwapFeePercentage                                                                                                                                                                                                        │
│         );                                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedTokensOutGivenBPTIn(uint256 bptAmountIn)                                                                                                                                                                             │
│         external                                                                                                                                                                                                                             │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256 principals, uint256 yields)                                                                                                                                                                                         │
│     {                                                                                                                                                                                                                                        │
│         // We don't need to scale balances down here                                                                                                                                                                                         │
│         // as calculation for amounts out is based on btpAmountIn / totalSupply() ratio                                                                                                                                                      │
│         // Adjusting balances with rate, and then undoing it would just cause additional calculations                                                                                                                                        │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                                                        │
│         (principals, yields) = (address(_token0) == address(tempusPool.principalShare()))                                                                                                                                                    │
│             ? (amountsOut[0], amountsOut[1])                                                                                                                                                                                                 │
│             : (amountsOut[1], amountsOut[0]);                                                                                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No", "3": "No"}                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedTokensOutGivenBPTIn(uint256 bptAmountIn)                                                                                                                                                                             │
│         external                                                                                                                                                                                                                             │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256 principals, uint256 yields)                                                                                                                                                                                         │
│     {                                                                                                                                                                                                                                        │
│         // We don't need to scale balances down here                                                                                                                                                                                         │
│         // as calculation for amounts out is based on btpAmountIn / totalSupply() ratio                                                                                                                                                      │
│         // Adjusting balances with rate, and then undoing it would just cause additional calculations                                                                                                                                        │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                                                        │
│         (principals, yields) = (address(_token0) == address(tempusPool.principalShare()))                                                                                                                                                    │
│             ? (amountsOut[0], amountsOut[1])                                                                                                                                                                                                 │
│             : (amountsOut[1], amountsOut[0]);                                                                                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedLPTokensForTokensIn(uint256[] memory amountsIn) external view returns (uint256) {                                                                                                                                    │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                                                │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         return                                                                                                                                                                                                                               │
│             (balances[0] == 0)                                                                                                                                                                                                               │
│                 ? StableMath._calculateInvariant(currentAmp, amountsIn, true)                                                                                                                                                                │
│                 : StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                                  │
│                     currentAmp,                                                                                                                                                                                                              │
│                     balances,                                                                                                                                                                                                                │
│                     amountsIn,                                                                                                                                                                                                               │
│                     totalSupply(),                                                                                                                                                                                                           │
│                     getSwapFeePercentage()                                                                                                                                                                                                   │
│                 );                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No", "3": "No"}                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedLPTokensForTokensIn(uint256[] memory amountsIn) external view returns (uint256) {                                                                                                                                    │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                                                │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         return                                                                                                                                                                                                                               │
│             (balances[0] == 0)                                                                                                                                                                                                               │
│                 ? StableMath._calculateInvariant(currentAmp, amountsIn, true)                                                                                                                                                                │
│                 : StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                                  │
│                     currentAmp,                                                                                                                                                                                                              │
│                     balances,                                                                                                                                                                                                                │
│                     amountsIn,                                                                                                                                                                                                               │
│                     totalSupply(),                                                                                                                                                                                                           │
│                     getSwapFeePercentage()                                                                                                                                                                                                   │
│                 );                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                                                            │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                     │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsIn,                                                                                                                                                                                                                       │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                                                            │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                     │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsIn,                                                                                                                                                                                                                       │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _doJoin(                                                                                                                                                                                                                        │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256 bptAmountOut, uint256[] memory amountsIn) {                                                                                                                                                                   │
│         JoinKind kind = userData.joinKind();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         if (kind == JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {                                                                                                                                                                                  │
│             return _joinExactTokensInForBPTOut(balances, scalingFactors, userData);                                                                                                                                                          │
│         } else {                                                                                                                                                                                                                             │
│             _revert(Errors.UNHANDLED_JOIN_KIND);                                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                                                            │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                     │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsIn,                                                                                                                                                                                                                       │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _doJoin(                                                                                                                                                                                                                        │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256 bptAmountOut, uint256[] memory amountsIn) {                                                                                                                                                                   │
│         JoinKind kind = userData.joinKind();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         if (kind == JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {                                                                                                                                                                                  │
│             return _joinExactTokensInForBPTOut(balances, scalingFactors, userData);                                                                                                                                                          │
│         } else {                                                                                                                                                                                                                             │
│             _revert(Errors.UNHANDLED_JOIN_KIND);                                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                                                            │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                     │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsIn,                                                                                                                                                                                                                       │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)                                                                                                                                                   │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256, uint256[] memory)                                                                                                                                                                                                  │
│     {                                                                                                                                                                                                                                        │
│         // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted                                                                                                                        │
│         // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.                                                                                                                                 │
│         // This particular exit function is the only one that remains available because it is the simplest one, and                                                                                                                          │
│         // therefore the one with the lowest likelihood of errors.                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountIn = userData.exactBptInForTokensOut();                                                                                                                                                                             │
│         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                                                        │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)                                                                                                                                                   │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256, uint256[] memory)                                                                                                                                                                                                  │
│     {                                                                                                                                                                                                                                        │
│         // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted                                                                                                                        │
│         // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.                                                                                                                                 │
│         // This particular exit function is the only one that remains available because it is the simplest one, and                                                                                                                          │
│         // therefore the one with the lowest likelihood of errors.                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountIn = userData.exactBptInForTokensOut();                                                                                                                                                                             │
│         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                                                        │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _doExit(                                                                                                                                                                                                                        │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         ExitKind kind = userData.exitKind();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {                                                                                                                                                                                  │
│             return _exitExactBPTInForTokensOut(balances, userData);                                                                                                                                                                          │
│         } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {                                                                                                                                                                           │
│             return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);                                                                                                                                                          │
│         } else {                                                                                                                                                                                                                             │
│             revert("Unhandled exit kind.");                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)                                                                                                                                                   │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256, uint256[] memory)                                                                                                                                                                                                  │
│     {                                                                                                                                                                                                                                        │
│         // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted                                                                                                                        │
│         // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.                                                                                                                                 │
│         // This particular exit function is the only one that remains available because it is the simplest one, and                                                                                                                          │
│         // therefore the one with the lowest likelihood of errors.                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountIn = userData.exactBptInForTokensOut();                                                                                                                                                                             │
│         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                                                        │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _doExit(                                                                                                                                                                                                                        │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         ExitKind kind = userData.exitKind();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {                                                                                                                                                                                  │
│             return _exitExactBPTInForTokensOut(balances, userData);                                                                                                                                                                          │
│         } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {                                                                                                                                                                           │
│             return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);                                                                                                                                                          │
│         } else {                                                                                                                                                                                                                             │
│             revert("Unhandled exit kind.");                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)                                                                                                                                                   │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256, uint256[] memory)                                                                                                                                                                                                  │
│     {                                                                                                                                                                                                                                        │
│         // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted                                                                                                                        │
│         // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.                                                                                                                                 │
│         // This particular exit function is the only one that remains available because it is the simplest one, and                                                                                                                          │
│         // therefore the one with the lowest likelihood of errors.                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountIn = userData.exactBptInForTokensOut();                                                                                                                                                                             │
│         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                                                        │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         // This exit function is disabled if the contract is paused.                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                                               │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                      │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         // This exit function is disabled if the contract is paused.                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                                               │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                      │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _doExit(                                                                                                                                                                                                                        │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         ExitKind kind = userData.exitKind();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {                                                                                                                                                                                  │
│             return _exitExactBPTInForTokensOut(balances, userData);                                                                                                                                                                          │
│         } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {                                                                                                                                                                           │
│             return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);                                                                                                                                                          │
│         } else {                                                                                                                                                                                                                             │
│             revert("Unhandled exit kind.");                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         // This exit function is disabled if the contract is paused.                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                                               │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                      │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _doExit(                                                                                                                                                                                                                        │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         ExitKind kind = userData.exitKind();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {                                                                                                                                                                                  │
│             return _exitExactBPTInForTokensOut(balances, userData);                                                                                                                                                                          │
│         } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {                                                                                                                                                                           │
│             return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);                                                                                                                                                          │
│         } else {                                                                                                                                                                                                                             │
│             revert("Unhandled exit kind.");                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         // This exit function is disabled if the contract is paused.                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                                               │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                      │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _onExitPool(                                                                                                                                                                                                                    │
│         bytes32,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256,                                                                                                                                                                                                                             │
│         uint256 protocolSwapFeePercentage,                                                                                                                                                                                                   │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         virtual                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 bptAmountIn,                                                                                                                                                                                                             │
│             uint256[] memory amountsOut,                                                                                                                                                                                                     │
│             uint256[] memory dueProtocolFeeAmounts                                                                                                                                                                                           │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                                                      │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens                                                                                                                       │
│         // out) remain functional.                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         if (_isNotPaused()) {                                                                                                                                                                                                                │
│             // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous                                                                                                                      │
│             // join or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids                                                                                                                              │
│             // spending gas calculating fee amounts during each individual swap                                                                                                                                                              │
│             dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                                               │
│             balances.sub(dueProtocolFeeAmounts);                                                                                                                                                                                             │
│         } else {                                                                                                                                                                                                                             │
│             // If the contract is paused, swap protocol fee amounts are not charged to avoid extra calculations and                                                                                                                          │
│             // reduce the potential for errors.                                                                                                                                                                                              │
│             dueProtocolFeeAmounts = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         (bptAmountIn, amountsOut) = _doExit(balances, scalingFactors, userData);                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Update the invariant with the balances the Pool will have after the exit, in order to compute the                                                                                                                                 │
│         // protocol swap fee amounts due in future joins and exits.                                                                                                                                                                          │
│         _updateInvariantAfterExit(balances, amountsOut);                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         amountsOut.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                 │
│         dueProtocolFeeAmounts.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _onExitPool(                                                                                                                                                                                                                    │
│         bytes32,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256,                                                                                                                                                                                                                             │
│         uint256 protocolSwapFeePercentage,                                                                                                                                                                                                   │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         virtual                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 bptAmountIn,                                                                                                                                                                                                             │
│             uint256[] memory amountsOut,                                                                                                                                                                                                     │
│             uint256[] memory dueProtocolFeeAmounts                                                                                                                                                                                           │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                                                      │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens                                                                                                                       │
│         // out) remain functional.                                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         if (_isNotPaused()) {                                                                                                                                                                                                                │
│             // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous                                                                                                                      │
│             // join or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids                                                                                                                              │
│             // spending gas calculating fee amounts during each individual swap                                                                                                                                                              │
│             dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                                               │
│             balances.sub(dueProtocolFeeAmounts);                                                                                                                                                                                             │
│         } else {                                                                                                                                                                                                                             │
│             // If the contract is paused, swap protocol fee amounts are not charged to avoid extra calculations and                                                                                                                          │
│             // reduce the potential for errors.                                                                                                                                                                                              │
│             dueProtocolFeeAmounts = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         (bptAmountIn, amountsOut) = _doExit(balances, scalingFactors, userData);                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Update the invariant with the balances the Pool will have after the exit, in order to compute the                                                                                                                                 │
│         // protocol swap fee amounts due in future joins and exits.                                                                                                                                                                          │
│         _updateInvariantAfterExit(balances, amountsOut);                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         amountsOut.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                 │
│         dueProtocolFeeAmounts.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _onInitializePool(                                                                                                                                                                                                              │
│         bytes32,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) internal virtual override whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                           │
│         // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent                                                                                                                            │
│         // initialization in this case.                                                                                                                                                                                                      │
│         TempusAMM.JoinKind kind = userData.joinKind();                                                                                                                                                                                       │
│         _require(kind == TempusAMM.JoinKind.INIT, Errors.UNINITIALIZED);                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         uint256[] memory amountsIn = userData.initialAmountsIn();                                                                                                                                                                            │
│         InputHelpers.ensureInputLengthMatch(amountsIn.length, _TOTAL_TOKENS);                                                                                                                                                                │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                                                      │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         uint256 invariantAfterJoin = StableMath._calculateInvariant(currentAmp, amountsIn, true);                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // Set the initial BPT to the value of the invariant.                                                                                                                                                                                │
│         uint256 bptAmountOut = invariantAfterJoin;                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         _updateLastInvariant(invariantAfterJoin, currentAmp);                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         amountsIn.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _onInitializePool(                                                                                                                                                                                                              │
│         bytes32,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) internal virtual override whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                           │
│         // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent                                                                                                                            │
│         // initialization in this case.                                                                                                                                                                                                      │
│         TempusAMM.JoinKind kind = userData.joinKind();                                                                                                                                                                                       │
│         _require(kind == TempusAMM.JoinKind.INIT, Errors.UNINITIALIZED);                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         uint256[] memory amountsIn = userData.initialAmountsIn();                                                                                                                                                                            │
│         InputHelpers.ensureInputLengthMatch(amountsIn.length, _TOTAL_TOKENS);                                                                                                                                                                │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                                                      │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         uint256 invariantAfterJoin = StableMath._calculateInvariant(currentAmp, amountsIn, true);                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // Set the initial BPT to the value of the invariant.                                                                                                                                                                                │
│         uint256 bptAmountOut = invariantAfterJoin;                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         _updateLastInvariant(invariantAfterJoin, currentAmp);                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         amountsIn.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         // This exit function is disabled if the contract is paused.                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                                               │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                      │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         // This exit function is disabled if the contract is paused.                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                                               │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                      │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                                                            │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                     │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsIn,                                                                                                                                                                                                                       │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                                                    │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                                                          │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                                                           │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                                                            │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                     │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsIn,                                                                                                                                                                                                                       │
│             totalSupply(),                                                                                                                                                                                                                   │
│             getSwapFeePercentage()                                                                                                                                                                                                           │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _onJoinPool(                                                                                                                                                                                                                    │
│         bytes32,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256,                                                                                                                                                                                                                             │
│         uint256 protocolSwapFeePercentage,                                                                                                                                                                                                   │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         virtual                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         whenNotPaused                                                                                                                                                                                                                        │
│         beforeMaturity                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256,                                                                                                                                                                                                                         │
│             uint256[] memory,                                                                                                                                                                                                                │
│             uint256[] memory                                                                                                                                                                                                                 │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                                                      │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous join                                                                                                                     │
│         // or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids spending gas to                                                                                                                       │
│         // calculate the fee amounts during each individual swap.                                                                                                                                                                            │
│         uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Update current balances by subtracting the protocol fee amounts                                                                                                                                                                   │
│         balances.sub(dueProtocolFeeAmounts);                                                                                                                                                                                                 │
│         (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(balances, scalingFactors, userData);                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Update the invariant with the balances the Pool will have after the join, in order to compute the                                                                                                                                 │
│         // protocol swap fee amounts due in future joins and exits.                                                                                                                                                                          │
│         _updateInvariantAfterJoin(balances, amountsIn);                                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         amountsIn.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│         dueProtocolFeeAmounts.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _onJoinPool(                                                                                                                                                                                                                    │
│         bytes32,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         address,                                                                                                                                                                                                                             │
│         uint256[] memory balances,                                                                                                                                                                                                           │
│         uint256,                                                                                                                                                                                                                             │
│         uint256 protocolSwapFeePercentage,                                                                                                                                                                                                   │
│         uint256[] memory scalingFactors,                                                                                                                                                                                                     │
│         bytes memory userData                                                                                                                                                                                                                │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         virtual                                                                                                                                                                                                                              │
│         override                                                                                                                                                                                                                             │
│         whenNotPaused                                                                                                                                                                                                                        │
│         beforeMaturity                                                                                                                                                                                                                       │
│         returns (                                                                                                                                                                                                                            │
│             uint256,                                                                                                                                                                                                                         │
│             uint256[] memory,                                                                                                                                                                                                                │
│             uint256[] memory                                                                                                                                                                                                                 │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                                                      │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous join                                                                                                                     │
│         // or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids spending gas to                                                                                                                       │
│         // calculate the fee amounts during each individual swap.                                                                                                                                                                            │
│         uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Update current balances by subtracting the protocol fee amounts                                                                                                                                                                   │
│         balances.sub(dueProtocolFeeAmounts);                                                                                                                                                                                                 │
│         (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(balances, scalingFactors, userData);                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Update the invariant with the balances the Pool will have after the join, in order to compute the                                                                                                                                 │
│         // protocol swap fee amounts due in future joins and exits.                                                                                                                                                                          │
│         _updateInvariantAfterJoin(balances, amountsIn);                                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         amountsIn.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│         dueProtocolFeeAmounts.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                                                           │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                                                           │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                                                           │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                                                     │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                                             │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                                                         │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                                                        │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                                             │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                                                     │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return amountOut;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                                                     │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                                             │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                                                         │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                                                        │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                                             │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                                                     │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         return amountOut;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function getRate() public view override returns (uint256) {                                                                                                                                                                              │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // When calculating the current BPT rate, we may not have paid the protocol fees, therefore                                                                                                                                          │
│         // the invariant should be smaller than its current value. Then, we round down overall.                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(balances, _scalingFactors());                                                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, false);                                                                                                                                                     │
│         return invariant.divDown(totalSupply());                                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getRate() public view override returns (uint256) {                                                                                                                                                                              │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // When calculating the current BPT rate, we may not have paid the protocol fees, therefore                                                                                                                                          │
│         // the invariant should be smaller than its current value. Then, we round down overall.                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(balances, _scalingFactors());                                                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, false);                                                                                                                                                     │
│         return invariant.divDown(totalSupply());                                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                                                  │
│         external                                                                                                                                                                                                                             │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256 lpTokens)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                    │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                                                      │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                                                     │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                                               │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                                                 │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                                             │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                                                │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                 │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                                                          │
│         if (_isNotPaused()) {                                                                                                                                                                                                                │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                                               │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                                 │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             protocolSwapFeePercentage                                                                                                                                                                                                        │
│         );                                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                                                  │
│         external                                                                                                                                                                                                                             │
│         view                                                                                                                                                                                                                                 │
│         returns (uint256 lpTokens)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                    │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                                                      │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                                                     │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                                               │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                                                 │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                                                           │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                                             │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                                                │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                 │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                                                          │
│         if (_isNotPaused()) {                                                                                                                                                                                                                │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                                               │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                                                 │
│             currentAmp,                                                                                                                                                                                                                      │
│             balances,                                                                                                                                                                                                                        │
│             amountsOut,                                                                                                                                                                                                                      │
│             totalSupply(),                                                                                                                                                                                                                   │
│             protocolSwapFeePercentage                                                                                                                                                                                                        │
│         );                                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedLPTokensForTokensIn(uint256[] memory amountsIn) external view returns (uint256) {                                                                                                                                    │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                                                │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         return                                                                                                                                                                                                                               │
│             (balances[0] == 0)                                                                                                                                                                                                               │
│                 ? StableMath._calculateInvariant(currentAmp, amountsIn, true)                                                                                                                                                                │
│                 : StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                                  │
│                     currentAmp,                                                                                                                                                                                                              │
│                     balances,                                                                                                                                                                                                                │
│                     amountsIn,                                                                                                                                                                                                               │
│                     totalSupply(),                                                                                                                                                                                                           │
│                     getSwapFeePercentage()                                                                                                                                                                                                   │
│                 );                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function getExpectedLPTokensForTokensIn(uint256[] memory amountsIn) external view returns (uint256) {                                                                                                                                    │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                                                │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                   │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         return                                                                                                                                                                                                                               │
│             (balances[0] == 0)                                                                                                                                                                                                               │
│                 ? StableMath._calculateInvariant(currentAmp, amountsIn, true)                                                                                                                                                                │
│                 : StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                                                  │
│                     currentAmp,                                                                                                                                                                                                              │
│                     balances,                                                                                                                                                                                                                │
│                     amountsIn,                                                                                                                                                                                                               │
│                     totalSupply(),                                                                                                                                                                                                           │
│                     getSwapFeePercentage()                                                                                                                                                                                                   │
│                 );                                                                                                                                                                                                                           │
│     }                                                                                                                                                                                                                                        │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                                                │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                                               │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                                                     │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                                                     │
│         return rates;                                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function getRate() public view override returns (uint256) {                                                                                                                                                                              │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // When calculating the current BPT rate, we may not have paid the protocol fees, therefore                                                                                                                                          │
│         // the invariant should be smaller than its current value. Then, we round down overall.                                                                                                                                              │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         _upscaleArray(balances, _scalingFactors());                                                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                                                       │
│         uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, false);                                                                                                                                                     │
│         return invariant.divDown(totalSupply());                                                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No", "3": "No"}                                                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {                                                                                                                                 │
│         _require(rawEndValue >= _MIN_AMP, Errors.MIN_AMP);                                                                                                                                                                                   │
│         _require(rawEndValue <= _MAX_AMP, Errors.MAX_AMP);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         uint256 duration = Math.sub(endTime, block.timestamp);                                                                                                                                                                               │
│         _require(duration >= _MIN_UPDATE_TIME, Errors.AMP_END_TIME_TOO_CLOSE);                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();                                                                                                                                                              │
│         _require(!isUpdating, Errors.AMP_ONGOING_UPDATE);                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         uint256 endValue = Math.mul(rawEndValue, _AMP_PRECISION);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // daily rate = (endValue / currentValue) / duration * 1 day                                                                                                                                                                         │
│         // We perform all multiplications first to not reduce precision, and round the division up as we want to avoid                                                                                                                       │
│         // large rates. Note that these are regular integer multiplications and divisions, not fixed point.                                                                                                                                  │
│         uint256 dailyRate = endValue > currentValue                                                                                                                                                                                          │
│             ? Math.divUp(Math.mul(1 days, endValue), Math.mul(currentValue, duration))                                                                                                                                                       │
│             : Math.divUp(Math.mul(1 days, currentValue), Math.mul(endValue, duration));                                                                                                                                                      │
│         _require(dailyRate <= _MAX_AMP_UPDATE_DAILY_RATE, Errors.AMP_RATE_TOO_HIGH);                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         _setAmplificationData(currentValue, endValue, block.timestamp, endTime);                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {                                                                                                                                 │
│         _require(rawEndValue >= _MIN_AMP, Errors.MIN_AMP);                                                                                                                                                                                   │
│         _require(rawEndValue <= _MAX_AMP, Errors.MAX_AMP);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         uint256 duration = Math.sub(endTime, block.timestamp);                                                                                                                                                                               │
│         _require(duration >= _MIN_UPDATE_TIME, Errors.AMP_END_TIME_TOO_CLOSE);                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();                                                                                                                                                              │
│         _require(!isUpdating, Errors.AMP_ONGOING_UPDATE);                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         uint256 endValue = Math.mul(rawEndValue, _AMP_PRECISION);                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // daily rate = (endValue / currentValue) / duration * 1 day                                                                                                                                                                         │
│         // We perform all multiplications first to not reduce precision, and round the division up as we want to avoid                                                                                                                       │
│         // large rates. Note that these are regular integer multiplications and divisions, not fixed point.                                                                                                                                  │
│         uint256 dailyRate = endValue > currentValue                                                                                                                                                                                          │
│             ? Math.divUp(Math.mul(1 days, endValue), Math.mul(currentValue, duration))                                                                                                                                                       │
│             : Math.divUp(Math.mul(1 days, currentValue), Math.mul(endValue, duration));                                                                                                                                                      │
│         _require(dailyRate <= _MAX_AMP_UPDATE_DAILY_RATE, Errors.AMP_RATE_TOO_HIGH);                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         _setAmplificationData(currentValue, endValue, block.timestamp, endTime);                                                                                                                                                             │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                                                           │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 mintedShares,                                                                                                                                                                                                            │
│             uint256 depositedBT,                                                                                                                                                                                                             │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(!matured, "Maturity reached.");                                                                                                                                                                                              │
│         rate = updateInterestRate();                                                                                                                                                                                                         │
│         require(rate >= initialInterestRate, "Negative yield!");                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Collect fees if they are set, reducing the number of tokens for the sender                                                                                                                                                        │
│         // thus leaving more YBT in the TempusPool than there are minted TPS/TYS                                                                                                                                                             │
│         uint256 tokenAmount = yieldTokenAmount;                                                                                                                                                                                              │
│         uint256 depositFees = feesConfig.depositPercent;                                                                                                                                                                                     │
│         if (depositFees != 0) {                                                                                                                                                                                                              │
│             fee = tokenAmount.mulfV(depositFees, yieldBearingONE);                                                                                                                                                                           │
│             tokenAmount -= fee;                                                                                                                                                                                                              │
│             totalFees += fee;                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Issue appropriate shares                                                                                                                                                                                                          │
│         depositedBT = numAssetsPerYieldToken(tokenAmount, rate);                                                                                                                                                                             │
│         mintedShares = numSharesToMint(depositedBT, rate);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         PrincipalShare(address(principalShare)).mint(recipient, mintedShares);                                                                                                                                                               │
│         YieldShare(address(yieldShare)).mint(recipient, mintedShares);                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate in the given code is `rate = updateInterestRate();`.                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function _deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                                                           │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 mintedShares,                                                                                                                                                                                                            │
│             uint256 depositedBT,                                                                                                                                                                                                             │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 rate                                                                                                                                                                                                                     │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(!matured, "Maturity reached.");                                                                                                                                                                                              │
│         rate = updateInterestRate();                                                                                                                                                                                                         │
│         require(rate >= initialInterestRate, "Negative yield!");                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Collect fees if they are set, reducing the number of tokens for the sender                                                                                                                                                        │
│         // thus leaving more YBT in the TempusPool than there are minted TPS/TYS                                                                                                                                                             │
│         uint256 tokenAmount = yieldTokenAmount;                                                                                                                                                                                              │
│         uint256 depositFees = feesConfig.depositPercent;                                                                                                                                                                                     │
│         if (depositFees != 0) {                                                                                                                                                                                                              │
│             fee = tokenAmount.mulfV(depositFees, yieldBearingONE);                                                                                                                                                                           │
│             tokenAmount -= fee;                                                                                                                                                                                                              │
│             totalFees += fee;                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Issue appropriate shares                                                                                                                                                                                                          │
│         depositedBT = numAssetsPerYieldToken(tokenAmount, rate);                                                                                                                                                                             │
│         mintedShares = numSharesToMint(depositedBT, rate);                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         PrincipalShare(address(principalShare)).mint(recipient, mintedShares);                                                                                                                                                               │
│         YieldShare(address(yieldShare)).mint(recipient, mintedShares);                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward in the given code is `rate = updateInterestRate();`.                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:57:34] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/TempusPool.sol, current function: _deposit, current vul: wrong-order-interest            tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function burnShares(                                                                                                                                                                                                                     │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                                             │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                                                     │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Burn the appropriate shares                                                                                                                                                                                                       │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                                             │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                                                          │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                                                        │
│         totalFees += fee;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate in the given code is `uint256 currentRate = updateInterestRate();`.                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function burnShares(                                                                                                                                                                                                                     │
│         address from,                                                                                                                                                                                                                        │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         internal                                                                                                                                                                                                                             │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemedYieldTokens,                                                                                                                                                                                                     │
│             uint256 fee,                                                                                                                                                                                                                     │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                                             │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                                                     │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Burn the appropriate shares                                                                                                                                                                                                       │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                                             │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                                                          │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                                                        │
│         totalFees += fee;                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 currentRate = updateInterestRate();`                                                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:57:37] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/TempusPool.sol, current function: burnShares, current vul: wrong-order-interest          tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function getRedemptionAmounts(                                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         uint256 currentRate                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemableYieldTokens,                                                                                                                                                                                                   │
│             uint256 redeemableBackingTokens,                                                                                                                                                                                                 │
│             uint256 redeemFeeAmount,                                                                                                                                                                                                         │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         if (interestRate < initialInterestRate) {                                                                                                                                                                                            │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                                                │
│         } else {                                                                                                                                                                                                                             │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                                                           │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                                                      │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                                                     │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                                                            │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                                                │
│             if (matured && currentRate > interestRate) {                                                                                                                                                                                     │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                                                    │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                                                │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                                                         │
│                     exchangeRateONE                                                                                                                                                                                                          │
│                 );                                                                                                                                                                                                                           │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                                                     │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                                                 │
│         if (redeemFeePercent != 0) {                                                                                                                                                                                                         │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                                                       │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                                                       │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `interestRate = effectiveRate(currentRate);`                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function getRedemptionAmounts(                                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                                             │
│         uint256 yieldAmount,                                                                                                                                                                                                                 │
│         uint256 currentRate                                                                                                                                                                                                                  │
│     )                                                                                                                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│         view                                                                                                                                                                                                                                 │
│         returns (                                                                                                                                                                                                                            │
│             uint256 redeemableYieldTokens,                                                                                                                                                                                                   │
│             uint256 redeemableBackingTokens,                                                                                                                                                                                                 │
│             uint256 redeemFeeAmount,                                                                                                                                                                                                         │
│             uint256 interestRate                                                                                                                                                                                                             │
│         )                                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         if (interestRate < initialInterestRate) {                                                                                                                                                                                            │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                                                │
│         } else {                                                                                                                                                                                                                             │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                                                           │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                                                      │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                                                     │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                                                            │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                                                │
│             if (matured && currentRate > interestRate) {                                                                                                                                                                                     │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                                                    │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                                                │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                                                         │
│                     exchangeRateONE                                                                                                                                                                                                          │
│                 );                                                                                                                                                                                                                           │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                                                     │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                                                 │
│         if (redeemFeePercent != 0) {                                                                                                                                                                                                         │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                                                       │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                                                       │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `interestRate = effectiveRate(currentRate);`                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:57:39] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/TempusPool.sol, current function: getRedemptionAmounts, current vul:                     tasks.py:260
                             wrong-order-interest                                                                                                                                                                                               
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"totalShares":"This variable holds the value of total minted share or amount."}, "VariableB":{"_getTotalShares()":"This function returns the total supply/liquidity and is used by the conditional branch to determine if the  │
│ supply/liquidity is 0."}, "VariableC":{"_sharesAmount":"This variable holds the value of the deposit/mint/add amount."}}                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:57:42] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/mocks/lido/StETH.sol, current function: _mintShares, current vul: first-deposit          tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"sharesAmount":"This variable holds the value of total minted share or amount."}, "VariableB":{"sharesAmount":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the        │
│ supply/liquidity is 0."}, "VariableC":{"deposit":"This variable holds the value of the deposit/mint/add amount."}}                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:57:45] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/mocks/lido/StETH.sol, current function: _mintShares, current vul: first-deposit          tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function redeem(uint redeemTokens) external override returns (uint) {                                                                                                                                                                    │
│         ComptrollerMock mock = ComptrollerMock(address(comptroller));                                                                                                                                                                        │
│         if (mock.mockFailNextDepositOrRedeem()) {                                                                                                                                                                                            │
│             mock.setFailNextDepositOrRedeem(false);                                                                                                                                                                                          │
│             return 1;                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Amount of underlying asset to be redeemed:                                                                                                                                                                                        │
│         //  redeemAmount = redeemTokens x exchangeRate                                                                                                                                                                                       │
│         uint256 exchangeRate = exchangeRateStored();                                                                                                                                                                                         │
│         uint256 redeemAmount = (redeemTokens * exchangeRate) / 1e18;                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // burn the yield tokens                                                                                                                                                                                                             │
│         _burn(msg.sender, redeemTokens);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // transfer backing tokens to redeemer                                                                                                                                                                                               │
│         IERC20(underlying).safeTransfer(msg.sender, redeemAmount);                                                                                                                                                                           │
│         return 0; // success                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate in the given code is: `uint256 exchangeRate = exchangeRateStored();`                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function redeem(uint redeemTokens) external override returns (uint) {                                                                                                                                                                    │
│         ComptrollerMock mock = ComptrollerMock(address(comptroller));                                                                                                                                                                        │
│         if (mock.mockFailNextDepositOrRedeem()) {                                                                                                                                                                                            │
│             mock.setFailNextDepositOrRedeem(false);                                                                                                                                                                                          │
│             return 1;                                                                                                                                                                                                                        │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Amount of underlying asset to be redeemed:                                                                                                                                                                                        │
│         //  redeemAmount = redeemTokens x exchangeRate                                                                                                                                                                                       │
│         uint256 exchangeRate = exchangeRateStored();                                                                                                                                                                                         │
│         uint256 redeemAmount = (redeemTokens * exchangeRate) / 1e18;                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // burn the yield tokens                                                                                                                                                                                                             │
│         _burn(msg.sender, redeemTokens);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // transfer backing tokens to redeemer                                                                                                                                                                                               │
│         IERC20(underlying).safeTransfer(msg.sender, redeemAmount);                                                                                                                                                                           │
│         return 0; // success                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward in the given code is:                                                                                                                             │
│ ```                                                                                                                                                                                                                                          │
│ uint256 exchangeRate = exchangeRateStored();                                                                                                                                                                                                 │
│ ```                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:57:47] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/mocks/compound/CErc20.sol, current function: redeem, current vul: wrong-order-interest   tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                                             │
│         internal                                                                                                                                                                                                                             │
│         override                                                                                                                                                                                                                             │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│         // tempus pool owns YBT                                                                                                                                                                                                              │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                                                 │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                                                        │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                                                            │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate in the given code is `updateInterestRate()`.                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                                             │
│         internal                                                                                                                                                                                                                             │
│         override                                                                                                                                                                                                                             │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│         // tempus pool owns YBT                                                                                                                                                                                                              │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                                                 │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                                                        │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                                                            │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward in the given code is `uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());`.                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:57:51] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/pools/CompoundTempusPool.sol, current function: withdrawFromUnderlyingProtocol, current  tasks.py:260
                             vul: wrong-order-interest                                                                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves or the balance of tokens in the pool.", "currentAmp":"This variable holds the amplification parameter used in the liquidity calculation.", "amount":"This variable holds   │
│ the amount of tokens to be swapped.", "tokenIn.getPricePerFullShareStored()":"This function returns the exchange rate or price per full share of the input token.", "tokenOut.getPricePerFullShareStored()":"This function returns the       │
│ exchange rate or price per full share of the output token."}, "VariableB":{"amountOut":"This variable holds the calculated value or price of LP token after the swap."}}                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:57:56] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: getExpectedReturnGivenIn, current vul:              tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"principalsRate":"This variable holds the price per full share of the principal token in the TempusPool.", "yieldsRate":"This variable holds the price per full share of the yield token in the TempusPool.", "rate":"This     │
│ variable holds the calculated exchange rate between the principal and yield tokens."}, "VariableB":{"amountIn":"This variable holds the calculated value of LP token."}}                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:00] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: getExpectedReturnGivenIn, current vul:              tasks.py:359
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"principalsRate":"This variable holds the price per full share of the principal token in the TempusPool.", "yieldsRate":"This variable holds the price per full share of the yield token in the TempusPool.", "rate":"This     │
│ variable holds the calculated rate between the principal and yield tokens.", "newPrincipals":"This variable holds the updated balance of the principal tokens after the swap.", "newYields":"This variable holds the updated balance of the  │
│ yield tokens after the swap."}, "VariableB":{"amountIn":"This variable holds the calculated value of LP token."}}                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:03] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: getSwapAmountToEndWithEqualShares, current vul:     tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the balance of the tokens in the pool. It is used in the calculation of the liquidity pool tokens (LP tokens).", "amountsOut":"This variable holds the amounts of tokens that will be          │
│ outputted. It is used in the calculation of the liquidity pool tokens (LP tokens).", "totalSupply":"This function returns the total supply of the liquidity pool tokens. It is used in the calculation of the liquidity pool tokens (LP      │
│ tokens)."}, "VariableB":{"lpTokens":"This variable holds the calculated value of the liquidity pool tokens (LP tokens)."}}                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:34] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: getExpectedBPTInGivenTokensOut, current vul:        tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves or the balance of the tokens in the pool.", "totalSupply":"This function returns the total supply of the LP tokens.", "_calcTokensOutGivenExactBptIn":"This function       │
│ calculates the amount of tokens that will be received for a given amount of LP tokens."}, "VariableB":{"amountsOut":"This variable holds the calculated value or price of LP tokens."}}                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:37] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: getExpectedTokensOutGivenBPTIn, current vul:        tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves or the balance of the custom tokens in the pool.", "amountsIn":"This variable holds the amount of tokens to be added to the pool.", "totalSupply()":"This function returns │
│ the total supply of LP tokens in the pool.", "_getAmplificationParameter()":"This function returns the current amplification parameter used in the calculation of the invariant.", "getSwapFeePercentage()":"This function returns the swap  │
│ fee percentage."}, "VariableB":{"_calculateInvariant":"This function calculates the value of LP tokens when the balance is zero.", "_calcBptOutGivenExactTokensIn":"This function calculates the value of LP tokens given the exact tokens   │
│ in."}}                                                                                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:42] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: getExpectedLPTokensForTokensIn, current vul:        tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"bptAmountOut":"This variable holds the calculated           │
│ value/price of LP token."}}                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:44] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _joinExactTokensInForBPTOut, current vul:           tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"Market reserves/AMMprice/exchangeRate or the custom token balanceOf/totalSupply/amount/liquidity calculation", "totalSupply()":"Market reserves/AMMprice/exchangeRate or the custom token                          │
│ balanceOf/totalSupply/amount/liquidity calculation"}, "VariableB":{"amountsOut":"Calculated value/price of LP token"}}                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:48] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _exitExactBPTInForTokensOut, current vul:           tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{}}                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:49] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _exitExactBPTInForTokensOut, current vul:           tasks.py:359
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation", "scalingFactors":"This variable is used in the liquidity calculation",      │
│ "amountsOut":"This variable holds the amount of tokens to be outputted", "totalSupply":"This function returns the total supply of the tokens", "_getTokenRates":"This function is used in the calculation of the token rates",               │
│ "_getAmplificationParameter":"This function is used in the calculation of the amplification parameter", "getSwapFeePercentage":"This function returns the swap fee percentage"}, "VariableB":{"bptAmountIn":"This variable holds the         │
│ calculated value/price of LP token"}}                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:53] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _exitBPTInForExactTokensOut, current vul:           tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{}}                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:54] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _exitBPTInForExactTokensOut, current vul:           tasks.py:359
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"rates":"This variable holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"rates":"This variable holds the calculated value/price of LP   │
│ token."}}                                                                                                                                                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:56] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRates, current vul: price-manipulation     tasks.py:260
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves or the custom token balance. It is an array of balances for each token in the pool. It is used in various calculations throughout the function, including calculating due  │
│ protocol fee amounts and updating the invariant after an exit."}, "VariableB":{"bptAmountIn":"This variable holds the calculated value of LP token. It is the amount of BPT tokens that are being taken out of the pool during an exit."}}   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:58:59] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRates, current vul: price-manipulation     tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"amountsIn":"This variable holds the initial amounts of tokens to be added to the pool. It is used in the calculation of the invariant, which is used to calculate the price of the LP token. The 'amountsIn' variable is      │
│ upscaled by the 'scalingFactors' and then multiplied by the 'tokenRates' to get the actual amounts of tokens in the pool."},                                                                                                                 │
│  "VariableB":{"bptAmountOut":"This variable holds the calculated value of the LP token. It is set to the value of the invariant after the join operation."}}                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:02] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRates, current vul: price-manipulation     tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"bptAmountIn":"This variable holds the calculated            │
│ value/price of LP token."}}                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:04] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRates, current vul: price-manipulation     tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"bptAmountOut":"This variable holds the calculated           │
│ value/price of LP token."}}                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:06] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRates, current vul: price-manipulation     tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves or the custom token balance. It is an array of balances for each token in the pool. It is used to calculate the amount of tokens to be added or removed from the pool      │
│ during a join or exit event.", "tokenRates":"This variable holds the exchange rate or price for each token in the pool. It is used to adjust the balances of the tokens during a join or exit event.", "dueProtocolFeeAmounts":"This         │
│ variable holds the calculated protocol swap fee amounts. It is used to update the current balances by subtracting the protocol fee amounts."}, "VariableB":{"bptAmountOut":"This variable holds the calculated value or price of LP token.   │
│ It is the amount of Balancer Pool Tokens (BPT) that will be minted and given to the user in a join event."}}                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:12] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRates, current vul: price-manipulation     tasks.py:359
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"rates":"This array holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"rates":"This array holds the calculated value/price of LP         │
│ token."}}                                                                                                                                                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:14] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRatesStored, current vul:                  tasks.py:260
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                                                    
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves or the balance of tokens in the pool.", "currentAmp":"This variable holds the amplification parameter used in the liquidity calculation.", "amount":"This variable holds   │
│ the amount of tokens to be swapped.", "tokenIn.getPricePerFullShareStored()":"This function returns the exchange rate or price per full share of the input token.", "tokenOut.getPricePerFullShareStored()":"This function returns the       │
│ exchange rate or price per full share of the output token."}, "VariableB":{"amountOut":"This variable holds the calculated value or price of LP token after the swap."}}                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:19] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRatesStored, current vul:                  tasks.py:359
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves or the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"invariant":"This variable holds the calculated value/price of LP token."}}        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:21] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRatesStored, current vul:                  tasks.py:359
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the balance of the tokens in the pool. It is used to calculate the amount of LP tokens that will be minted for the given input amounts.","amountsOut":"This variable holds the amounts of      │
│ tokens that will be taken out of the pool. It is used to calculate the amount of LP tokens that will be minted for the given input amounts.","totalSupply":"This function returns the total supply of LP tokens. It is used to calculate the │
│ amount of LP tokens that will be minted for the given input amounts."}, "VariableB":{"lpTokens":"This variable holds the calculated value of LP tokens that will be minted for the given input amounts."}}                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:25] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRatesStored, current vul:                  tasks.py:359
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"balances":"This variable holds the market reserves or the balance of the tokens in the pool.", "amountsIn":"This variable holds the amount of tokens to be added to the pool.", "totalSupply()":"This function returns the    │
│ total supply of the LP tokens in the pool.", "_getTokenRatesStored()":"This function returns the exchange rates for the tokens.", "_getAmplificationParameter()":"This function returns the amplification parameter used in the invariant    │
│ calculation.", "getSwapFeePercentage()":"This function returns the swap fee percentage."}, "VariableB":{"_calculateInvariant":"This function calculates the invariant, which represents the value of LP tokens when the balance of tokens in │
│ the pool is zero.", "_calcBptOutGivenExactTokensIn":"This function calculates the amount of LP tokens to be minted given the exact amount of tokens added to the pool."}}                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:59:31] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                                                            tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current function: _getTokenRatesStored, current vul:                  tasks.py:359
                             price-manipulation                                                                                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                                              tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                                                    
                                 falcon_instance, function2_text)                                                                                                                                                                               
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                                                   
                                                                                                                                                                                                                                                
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                  Summary                   
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value             ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 37                │
│ Contracts            │ 40                │
│ Functions            │ 100               │
│ Lines of Code        │ 4483              │
│ Used Time            │ 621.7347259521484 │
│ Estimated Cost (USD) │ 0.084247          │
└──────────────────────┴───────────────────┘
