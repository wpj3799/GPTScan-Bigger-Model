

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[16:39:02] Loaded 10 rules                                                                                                                                                                                                          tasks.py:119
[12/08/24 16:39:02] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-08-yield-main)                                                                     subprocess.py:41
                    ERROR    CryticCompile: 'npx' returned non-zero exit code 126                                                                                                                                               subprocess.py:60
                    ERROR    CryticCompile: sh: 1: hardhat: Permission denied                                                                                                                                                   subprocess.py:68
                    INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-08-yield-main)                                                            subprocess.py:41
[12/08/24 16:39:03] ERROR    CryticCompile: 'npx' returned non-zero exit code 126                                                                                                                                               subprocess.py:60
                    ERROR    CryticCompile: sh: 1: hardhat: Permission denied                                                                                                                                                   subprocess.py:68
                    INFO     CryticCompile: Problem executing hardhat: sh: 1: hardhat: Permission denied                                                                                                                          hardhat.py:327
                                                                                                                                                                                                                                                
                    INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-08-yield-main)                                                           subprocess.py:41
                    ERROR    CryticCompile: 'npx' returned non-zero exit code 126                                                                                                                                               subprocess.py:60
                    ERROR    CryticCompile: sh: 1: hardhat: Permission denied                                                                                                                                                   subprocess.py:68
[12/08/24 16:39:07] ERROR    ContractSolcParsing: Impossible to generate IR for PoolFactory.falconConstructorConstantVariables:                                                                                                  contract.py:392
                              'CompilationUnit' object has no attribute 'bytecode_init'                                                                                                                                                         
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _join(address user, uint128 amount)                                                                                                                                                                                             │
│         internal                                                                                                                                                                                                                             │
│         returns (uint128)                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         IERC20 token = IERC20(asset);                                                                                                                                                                                                        │
│         uint256 _storedBalance = storedBalance;                                                                                                                                                                                              │
│         uint256 available = token.balanceOf(address(this)) - _storedBalance; // Fine to panic if this underflows                                                                                                                             │
│         storedBalance = _storedBalance + amount;                                                                                                                                                                                             │
│         unchecked { if (available < amount) token.safeTransferFrom(user, address(this), amount - available); }                                                                                                                               │
│         return amount;                                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)                                                                                                                                     │
│         external override                                                                                                                                                                                                                    │
│         returns(bool)                                                                                                                                                                                                                        │
│     {                                                                                                                                                                                                                                        │
│         require(token == asset, "Unsupported currency");                                                                                                                                                                                     │
│         uint128 _amount = amount.u128();                                                                                                                                                                                                     │
│         uint128 _fee = _flashFee(amount).u128();                                                                                                                                                                                             │
│         _exit(address(receiver), _amount);                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         require(receiver.onFlashLoan(msg.sender, token, _amount, _fee, data) == FLASH_LOAN_RETURN, "Non-compliant borrower");                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _join(address(receiver), _amount + _fee);                                                                                                                                                                                            │
│         return true;                                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
│     function _join(address user, uint128 amount)                                                                                                                                                                                             │
│         internal                                                                                                                                                                                                                             │
│         returns (uint128)                                                                                                                                                                                                                    │
│     {                                                                                                                                                                                                                                        │
│         IERC20 token = IERC20(asset);                                                                                                                                                                                                        │
│         uint256 _storedBalance = storedBalance;                                                                                                                                                                                              │
│         uint256 available = token.balanceOf(address(this)) - _storedBalance; // Fine to panic if this underflows                                                                                                                             │
│         storedBalance = _storedBalance + amount;                                                                                                                                                                                             │
│         unchecked { if (available < amount) token.safeTransferFrom(user, address(this), amount - available); }                                                                                                                               │
│         return amount;                                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _burn(address from, uint256 amount)                                                                                                                                                                                             │
│         internal override                                                                                                                                                                                                                    │
│         returns (bool)                                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                                                        │
│         // First use any tokens locked in this contract                                                                                                                                                                                      │
│         uint256 available = _balanceOf;                                                                                                                                                                                                      │
│         if (available >= amount) {                                                                                                                                                                                                           │
│             return super._burn(address(this), amount);                                                                                                                                                                                       │
│         } else {                                                                                                                                                                                                                             │
│             if (available > 0 ) super._burn(address(this), available);                                                                                                                                                                       │
│             unchecked { _decreaseAllowance(from, amount - available); }                                                                                                                                                                      │
│             unchecked { return super._burn(from, amount - available); }                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)                                                                                                                                     │
│         external override                                                                                                                                                                                                                    │
│         beforeMaturity                                                                                                                                                                                                                       │
│         returns(bool)                                                                                                                                                                                                                        │
│     {                                                                                                                                                                                                                                        │
│         require(token == address(this), "Unsupported currency");                                                                                                                                                                             │
│         _mint(address(receiver), amount);                                                                                                                                                                                                    │
│         require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, "Non-compliant borrower");                                                                                                                    │
│         _burn(address(receiver), amount);                                                                                                                                                                                                    │
│         return true;                                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
│     function _burn(address from, uint256 amount)                                                                                                                                                                                             │
│         internal override                                                                                                                                                                                                                    │
│         returns (bool)                                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                                                        │
│         // First use any tokens locked in this contract                                                                                                                                                                                      │
│         uint256 available = _balanceOf;                                                                                                                                                                                                      │
│         if (available >= amount) {                                                                                                                                                                                                           │
│             return super._burn(address(this), amount);                                                                                                                                                                                       │
│         } else {                                                                                                                                                                                                                             │
│             if (available > 0 ) super._burn(address(this), available);                                                                                                                                                                       │
│             unchecked { _decreaseAllowance(from, amount - available); }                                                                                                                                                                      │
│             unchecked { return super._burn(from, amount - available); }                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _burnInternal(address to, bool tradeToBase, uint256 minBaseOut, uint256 minFYTokenOut)                                                                                                                                          │
│         internal                                                                                                                                                                                                                             │
│         returns (uint256 tokensBurned, uint256 tokenOut, uint256 fyTokenOut)                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         tokensBurned = _balanceOf;                                                                                                                                                                                                           │
│         uint256 supply = _totalSupply;                                                                                                                                                                                                       │
│         uint256 fyTokenBalance = fyToken.balanceOf(address(this));          // use the real balance rather than the virtual one                                                                                                              │
│         uint256 baseBalance = base.balanceOf(address(this));                                                                                                                                                                                 │
│         (uint112 _baseCached, uint112 _fyTokenCached) =                                                                                                                                                                                      │
│             (baseCached, fyTokenCached);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // Calculate trade                                                                                                                                                                                                                   │
│         tokenOut = (tokensBurned * baseBalance) / supply;                                                                                                                                                                                    │
│         fyTokenOut = (tokensBurned * fyTokenBalance) / supply;                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         if (tradeToBase) {                                                                                                                                                                                                                   │
│             (int128 _k, int128 _g2) = (k2, g2);                                                                                                                                                                                              │
│             tokenOut += YieldMath.baseOutForFYTokenIn(                      // This is a virtual sell                                                                                                                                        │
│                 _baseCached - tokenOut.u128(),                              // Cache, minus virtual burn                                                                                                                                     │
│                 _fyTokenCached - fyTokenOut.u128(),                         // Cache, minus virtual burn                                                                                                                                     │
│                 fyTokenOut.u128(),                                          // Sell the virtual fyToken obtained                                                                                                                             │
│                 maturity - uint32(block.timestamp),                         // This can't be called after maturity                                                                                                                           │
│                 _k,                                                                                                                                                                                                                          │
│                 _g2                                                                                                                                                                                                                          │
│             );                                                                                                                                                                                                                               │
│             fyTokenOut = 0;                                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Slippage                                                                                                                                                                                                                          │
│         require (tokenOut >= minBaseOut, "Pool: Not enough base tokens obtained");                                                                                                                                                           │
│         require (fyTokenOut >= minFYTokenOut, "Pool: Not enough fyToken obtained");                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         // Update TWAR                                                                                                                                                                                                                       │
│         _update(                                                                                                                                                                                                                             │
│             (baseBalance - tokenOut).u128(),                                                                                                                                                                                                 │
│             (fyTokenBalance - fyTokenOut + supply - tokensBurned).u128(),                                                                                                                                                                    │
│             _baseCached,                                                                                                                                                                                                                     │
│             _fyTokenCached                                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Transfer assets                                                                                                                                                                                                                   │
│         _burn(address(this), tokensBurned);                                                                                                                                                                                                  │
│         base.safeTransfer(to, tokenOut);                                                                                                                                                                                                     │
│         if (fyTokenOut > 0) IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         emit Liquidity(maturity, msg.sender, to, tokenOut.i256(), fyTokenOut.i256(), -(tokensBurned.i256()));                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
│     function _burn(address from, uint256 amount)                                                                                                                                                                                             │
│         internal override                                                                                                                                                                                                                    │
│         returns (bool)                                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                                                        │
│         // First use any tokens locked in this contract                                                                                                                                                                                      │
│         uint256 available = _balanceOf;                                                                                                                                                                                                      │
│         if (available >= amount) {                                                                                                                                                                                                           │
│             return super._burn(address(this), amount);                                                                                                                                                                                       │
│         } else {                                                                                                                                                                                                                             │
│             if (available > 0 ) super._burn(address(this), available);                                                                                                                                                                       │
│             unchecked { _decreaseAllowance(from, amount - available); }                                                                                                                                                                      │
│             unchecked { return super._burn(from, amount - available); }                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _burnInternal(address to, bool tradeToBase, uint256 minBaseOut, uint256 minFYTokenOut)                                                                                                                                          │
│         internal                                                                                                                                                                                                                             │
│         returns (uint256 tokensBurned, uint256 tokenOut, uint256 fyTokenOut)                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         tokensBurned = _balanceOf;                                                                                                                                                                                                           │
│         uint256 supply = _totalSupply;                                                                                                                                                                                                       │
│         uint256 fyTokenBalance = fyToken.balanceOf(address(this));          // use the real balance rather than the virtual one                                                                                                              │
│         uint256 baseBalance = base.balanceOf(address(this));                                                                                                                                                                                 │
│         (uint112 _baseCached, uint112 _fyTokenCached) =                                                                                                                                                                                      │
│             (baseCached, fyTokenCached);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // Calculate trade                                                                                                                                                                                                                   │
│         tokenOut = (tokensBurned * baseBalance) / supply;                                                                                                                                                                                    │
│         fyTokenOut = (tokensBurned * fyTokenBalance) / supply;                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         if (tradeToBase) {                                                                                                                                                                                                                   │
│             (int128 _k, int128 _g2) = (k2, g2);                                                                                                                                                                                              │
│             tokenOut += YieldMath.baseOutForFYTokenIn(                      // This is a virtual sell                                                                                                                                        │
│                 _baseCached - tokenOut.u128(),                              // Cache, minus virtual burn                                                                                                                                     │
│                 _fyTokenCached - fyTokenOut.u128(),                         // Cache, minus virtual burn                                                                                                                                     │
│                 fyTokenOut.u128(),                                          // Sell the virtual fyToken obtained                                                                                                                             │
│                 maturity - uint32(block.timestamp),                         // This can't be called after maturity                                                                                                                           │
│                 _k,                                                                                                                                                                                                                          │
│                 _g2                                                                                                                                                                                                                          │
│             );                                                                                                                                                                                                                               │
│             fyTokenOut = 0;                                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Slippage                                                                                                                                                                                                                          │
│         require (tokenOut >= minBaseOut, "Pool: Not enough base tokens obtained");                                                                                                                                                           │
│         require (fyTokenOut >= minFYTokenOut, "Pool: Not enough fyToken obtained");                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         // Update TWAR                                                                                                                                                                                                                       │
│         _update(                                                                                                                                                                                                                             │
│             (baseBalance - tokenOut).u128(),                                                                                                                                                                                                 │
│             (fyTokenBalance - fyTokenOut + supply - tokensBurned).u128(),                                                                                                                                                                    │
│             _baseCached,                                                                                                                                                                                                                     │
│             _fyTokenCached                                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Transfer assets                                                                                                                                                                                                                   │
│         _burn(address(this), tokensBurned);                                                                                                                                                                                                  │
│         base.safeTransfer(to, tokenOut);                                                                                                                                                                                                     │
│         if (fyTokenOut > 0) IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         emit Liquidity(maturity, msg.sender, to, tokenOut.i256(), fyTokenOut.i256(), -(tokensBurned.i256()));                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
│     function _burn(address from, uint256 amount)                                                                                                                                                                                             │
│         internal override                                                                                                                                                                                                                    │
│         returns (bool)                                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                                                        │
│         // First use any tokens locked in this contract                                                                                                                                                                                      │
│         uint256 available = _balanceOf;                                                                                                                                                                                                      │
│         if (available >= amount) {                                                                                                                                                                                                           │
│             return super._burn(address(this), amount);                                                                                                                                                                                       │
│         } else {                                                                                                                                                                                                                             │
│             if (available > 0 ) super._burn(address(this), available);                                                                                                                                                                       │
│             unchecked { _decreaseAllowance(from, amount - available); }                                                                                                                                                                      │
│             unchecked { return super._burn(from, amount - available); }                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function redeem(address to, uint256 amount)                                                                                                                                                                                              │
│         external override                                                                                                                                                                                                                    │
│         afterMaturity                                                                                                                                                                                                                        │
│         returns (uint256 redeemed)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         _burn(msg.sender, amount);                                                                                                                                                                                                           │
│         redeemed = amount.wmul(_accrual());                                                                                                                                                                                                  │
│         join.exit(to, redeemed.u128());                                                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         emit Redeemed(msg.sender, to, amount, redeemed);                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
│     function _burn(address from, uint256 amount)                                                                                                                                                                                             │
│         internal override                                                                                                                                                                                                                    │
│         returns (bool)                                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                                                        │
│         // First use any tokens locked in this contract                                                                                                                                                                                      │
│         uint256 available = _balanceOf;                                                                                                                                                                                                      │
│         if (available >= amount) {                                                                                                                                                                                                           │
│             return super._burn(address(this), amount);                                                                                                                                                                                       │
│         } else {                                                                                                                                                                                                                             │
│             if (available > 0 ) super._burn(address(this), available);                                                                                                                                                                       │
│             unchecked { _decreaseAllowance(from, amount - available); }                                                                                                                                                                      │
│             unchecked { return super._burn(from, amount - available); }                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function burn(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         returns (uint256 withdrawal)                                                                                                                                                                                                         │
│     {                                                                                                                                                                                                                                        │
│         // strategy * burnt/supply = withdrawal                                                                                                                                                                                              │
│         uint256 burnt = _balanceOf;                                                                                                                                                                                                          │
│         withdrawal = cached * burnt / _totalSupply;                                                                                                                                                                                          │
│         cached -= withdrawal;                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _burn(address(this), burnt);                                                                                                                                                                                                         │
│         IERC20(address(pool)).safeTransfer(to, withdrawal);                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                        │
│     function _burn(address from, uint256 amount)                                                                                                                                                                                             │
│         internal override                                                                                                                                                                                                                    │
│         returns (bool)                                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                                                        │
│         // First use any tokens locked in this contract                                                                                                                                                                                      │
│         uint256 available = _balanceOf;                                                                                                                                                                                                      │
│         if (available >= amount) {                                                                                                                                                                                                           │
│             return super._burn(address(this), amount);                                                                                                                                                                                       │
│         } else {                                                                                                                                                                                                                             │
│             if (available > 0 ) super._burn(address(this), available);                                                                                                                                                                       │
│             unchecked { _decreaseAllowance(from, amount - available); }                                                                                                                                                                      │
│             unchecked { return super._burn(from, amount - available); }                                                                                                                                                                      │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) external auth {                                                                                                                         │
│         require (address(oracle) != address(0), "Oracle required");                                                                                                                                                                          │
│         require (rateSource != address(0), "Rate source required");                                                                                                                                                                          │
│         require (chiSource != address(0), "Chi source required");                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         oracle.setSource(assetId, RATE.b6(), rateSource);                                                                                                                                                                                    │
│         oracle.setSource(assetId, CHI.b6(), chiSource);                                                                                                                                                                                      │
│         cauldron.setRateOracle(assetId, IOracle(address(oracle)));                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         AccessControl baseJoin = AccessControl(address(ladle.joins(assetId)));                                                                                                                                                               │
│         baseJoin.grantRole(JOIN, witch); // Give the Witch permission to join base                                                                                                                                                           │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function addSeries(                                                                                                                                                                                                                      │
│         bytes6 seriesId,                                                                                                                                                                                                                     │
│         bytes6 baseId,                                                                                                                                                                                                                       │
│         uint32 maturity,                                                                                                                                                                                                                     │
│         bytes6[] memory ilkIds,                                                                                                                                                                                                              │
│         string memory name,                                                                                                                                                                                                                  │
│         string memory symbol                                                                                                                                                                                                                 │
│     ) external auth {                                                                                                                                                                                                                        │
│         address base = cauldron.assets(baseId);                                                                                                                                                                                              │
│         require(base != address(0), "Base not found");                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         IJoin baseJoin = ladle.joins(baseId);                                                                                                                                                                                                │
│         require(address(baseJoin) != address(0), "Join not found");                                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         IOracle oracle = cauldron.rateOracles(baseId);                                                                                                                                                                                       │
│         require(address(oracle) != address(0), "Chi oracle not found");                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         AccessControl fyToken = AccessControl(fyTokenFactory.createFYToken(                                                                                                                                                                  │
│             baseId,                                                                                                                                                                                                                          │
│             oracle,                                                                                                                                                                                                                          │
│             baseJoin,                                                                                                                                                                                                                        │
│             maturity,                                                                                                                                                                                                                        │
│             name,     // Derive from base and maturity, perhaps                                                                                                                                                                              │
│             symbol    // Derive from base and maturity, perhaps                                                                                                                                                                              │
│         ));                                                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Allow the fyToken to pull from the base join for redemption                                                                                                                                                                       │
│         bytes4[] memory sigs = new bytes4[](1);                                                                                                                                                                                              │
│         sigs[0] = EXIT;                                                                                                                                                                                                                      │
│         AccessControl(address(baseJoin)).grantRoles(sigs, address(fyToken));                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         // Allow the ladle to issue and cancel fyToken                                                                                                                                                                                       │
│         sigs = new bytes4[](2);                                                                                                                                                                                                              │
│         sigs[0] = MINT;                                                                                                                                                                                                                      │
│         sigs[1] = BURN;                                                                                                                                                                                                                      │
│         fyToken.grantRoles(sigs, address(ladle));                                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         // Pass ownership of the fyToken to msg.sender                                                                                                                                                                                       │
│         fyToken.grantRole(fyToken.ROOT(), msg.sender);                                                                                                                                                                                       │
│         fyToken.renounceRole(fyToken.ROOT(), address(this));                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         // Add fyToken/series to the Cauldron and approve ilks for the series                                                                                                                                                                │
│         cauldron.addSeries(seriesId, baseId, IFYToken(address(fyToken)));                                                                                                                                                                    │
│         cauldron.addIlks(seriesId, ilkIds);                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Create the pool for the base and fyToken                                                                                                                                                                                          │
│         poolFactory.createPool(base, address(fyToken));                                                                                                                                                                                      │
│         IOwnable pool = IOwnable(poolFactory.calculatePoolAddress(base, address(fyToken)));                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         // Pass ownership of pool to msg.sender                                                                                                                                                                                              │
│         pool.transferOwnership(msg.sender);                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Register pool in Ladle                                                                                                                                                                                                            │
│         ladle.addPool(seriesId, address(pool));                                                                                                                                                                                              │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function setRateOracle(bytes6 baseId, IOracle oracle)                                                                                                                                                                                    │
│         external                                                                                                                                                                                                                             │
│         auth                                                                                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│         require (assets != address(0), "Base not found");                                                                                                                                                                                    │
│         rateOracles = oracle;                                                                                                                                                                                                                │
│         emit RateOracleAdded(baseId, address(oracle));                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)                                                                                                                                                                     │
│         external                                                                                                                                                                                                                             │
│         auth                                                                                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│         require (seriesId != bytes6(0), "Series id is zero");                                                                                                                                                                                │
│         address base = assets;                                                                                                                                                                                                               │
│         require (base != address(0), "Base not found");                                                                                                                                                                                      │
│         require (fyToken != IFYToken(address(0)), "Series need a fyToken");                                                                                                                                                                  │
│         require (fyToken.underlying() == base, "Mismatched series and base");                                                                                                                                                                │
│         require (rateOracles != IOracle(address(0)), "Rate oracle not found");                                                                                                                                                               │
│         require (series.fyToken == IFYToken(address(0)), "Id already used");                                                                                                                                                                 │
│         series = DataTypes.Series({                                                                                                                                                                                                          │
│             fyToken: fyToken,                                                                                                                                                                                                                │
│             maturity: fyToken.maturity().u32(),                                                                                                                                                                                              │
│             baseId: baseId                                                                                                                                                                                                                   │
│         });                                                                                                                                                                                                                                  │
│         emit SeriesAdded(seriesId, baseId, address(fyToken));                                                                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function mature(bytes6 seriesId)                                                                                                                                                                                                         │
│         external                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         require (ratesAtMaturity == 0, "Already matured");                                                                                                                                                                                   │
│         DataTypes.Series memory series_ = series;                                                                                                                                                                                            │
│         _mature(seriesId, series_);                                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _mature(bytes6 seriesId, DataTypes.Series memory series_)                                                                                                                                                                       │
│         internal                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         require (uint32(block.timestamp) >= series_.maturity, "Only after maturity");                                                                                                                                                        │
│         IOracle rateOracle = rateOracles;                                                                                                                                                                                                    │
│         (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18);                                                                                                                                                   │
│         ratesAtMaturity = rateAtMaturity;                                                                                                                                                                                                    │
│         emit SeriesMatured(seriesId, rateAtMaturity);                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function _mature(bytes6 seriesId, DataTypes.Series memory series_)                                                                                                                                                                       │
│         internal                                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         require (uint32(block.timestamp) >= series_.maturity, "Only after maturity");                                                                                                                                                        │
│         IOracle rateOracle = rateOracles;                                                                                                                                                                                                    │
│         (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18);                                                                                                                                                   │
│         ratesAtMaturity = rateAtMaturity;                                                                                                                                                                                                    │
│         emit SeriesMatured(seriesId, rateAtMaturity);                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _accrual(bytes6 seriesId, DataTypes.Series memory series_)                                                                                                                                                                      │
│         private                                                                                                                                                                                                                              │
│         returns (uint256 accrual_)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         uint256 rateAtMaturity = ratesAtMaturity;                                                                                                                                                                                            │
│         if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.                                                                                                                    │
│             _mature(seriesId, series_);                                                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                                             │
│             IOracle rateOracle = rateOracles;                                                                                                                                                                                                │
│             (uint256 rate,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18);                                                                                                                                                         │
│             accrual_ = rate.wdiv(rateAtMaturity);                                                                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│         accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function _accrual(bytes6 seriesId, DataTypes.Series memory series_)                                                                                                                                                                      │
│         private                                                                                                                                                                                                                              │
│         returns (uint256 accrual_)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         uint256 rateAtMaturity = ratesAtMaturity;                                                                                                                                                                                            │
│         if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.                                                                                                                    │
│             _mature(seriesId, series_);                                                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                                             │
│             IOracle rateOracle = rateOracles;                                                                                                                                                                                                │
│             (uint256 rate,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18);                                                                                                                                                         │
│             accrual_ = rate.wdiv(rateAtMaturity);                                                                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│         accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function repayLadle(bytes12 vaultId_)                                                                                                                                                                                                    │
│         external payable                                                                                                                                                                                                                     │
│         returns (uint256 repaid)                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);                                                                                                                                                                │
│         DataTypes.Series memory series = getSeries(vault.seriesId);                                                                                                                                                                          │
│         DataTypes.Balances memory balances = cauldron.balances(vaultId);                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         uint256 amount = series.fyToken.balanceOf(address(this));                                                                                                                                                                            │
│         repaid = amount <= balances.art ? amount : balances.art;                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Update accounting                                                                                                                                                                                                                 │
│         cauldron.pour(vaultId, 0, -(repaid.u128().i128()));                                                                                                                                                                                  │
│         series.fyToken.burn(address(this), repaid);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function retrieve(bytes6 id, bool isAsset, address to)                                                                                                                                                                                   │
│         external payable                                                                                                                                                                                                                     │
│         returns (uint256 amount)                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         IERC20 token = IERC20(findToken(id, isAsset));                                                                                                                                                                                       │
│         amount = token.balanceOf(address(this));                                                                                                                                                                                             │
│         token.safeTransfer(to, amount);                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function exitEther(address payable to)                                                                                                                                                                                                   │
│         external payable                                                                                                                                                                                                                     │
│         returns (uint256 ethTransferred)                                                                                                                                                                                                     │
│     {                                                                                                                                                                                                                                        │
│         ethTransferred = weth.balanceOf(address(this));                                                                                                                                                                                      │
│         weth.withdraw(ethTransferred);                                                                                                                                                                                                       │
│         to.safeTransferETH(ethTransferred);                                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 kind, uint256 amount)                                                                                                                                                                                 │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), kind.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 kind, uint256 amount)                                                                                                                                                                                 │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), kind.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                                │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                                │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 kind, uint256 amount)                                                                                                                                                                                │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), kind.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 kind, uint256 amount)                                                                                                                                                                                │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), kind.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price = 1e18;                                                                                                                                                                                                                │
│         bytes6 base_ = base.b6();                                                                                                                                                                                                            │
│         bytes6 quote_ = quote.b6();                                                                                                                                                                                                          │
│         bytes6[] memory path = paths;                                                                                                                                                                                                        │
│         for (uint256 p = 0; p < path.length; p++) {                                                                                                                                                                                          │
│             (price, updateTime) = _peek(base_, path, price, updateTime);                                                                                                                                                                     │
│             base_ = path;                                                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│         (price, updateTime) = _peek(base_, quote_, price, updateTime);                                                                                                                                                                       │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price = 1e18;                                                                                                                                                                                                                │
│         bytes6 base_ = base.b6();                                                                                                                                                                                                            │
│         bytes6 quote_ = quote.b6();                                                                                                                                                                                                          │
│         bytes6[] memory path = paths;                                                                                                                                                                                                        │
│         for (uint256 p = 0; p < path.length; p++) {                                                                                                                                                                                          │
│             (price, updateTime) = _peek(base_, path, price, updateTime);                                                                                                                                                                     │
│             base_ = path;                                                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│         (price, updateTime) = _peek(base_, quote_, price, updateTime);                                                                                                                                                                       │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 kind, uint256 amount)                                                                                                                                                                                 │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), kind.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 kind, uint256 amount)                                                                                                                                                                                 │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), kind.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                                │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                                │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 kind, uint256 amount)                                                                                                                                                                                │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), kind.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 kind, uint256 amount)                                                                                                                                                                                │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), kind.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _peek(base.b6(), quote.b6());                                                                                                                                                                                  │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price = 1e18;                                                                                                                                                                                                                │
│         bytes6 base_ = base.b6();                                                                                                                                                                                                            │
│         bytes6 quote_ = quote.b6();                                                                                                                                                                                                          │
│         bytes6[] memory path = paths;                                                                                                                                                                                                        │
│         for (uint256 p = 0; p < path.length; p++) {                                                                                                                                                                                          │
│             (price, updateTime) = _peek(base_, path, price, updateTime);                                                                                                                                                                     │
│             base_ = path;                                                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│         (price, updateTime) = _peek(base_, quote_, price, updateTime);                                                                                                                                                                       │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function peek(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                               │
│         external view virtual override                                                                                                                                                                                                       │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price = 1e18;                                                                                                                                                                                                                │
│         bytes6 base_ = base.b6();                                                                                                                                                                                                            │
│         bytes6 quote_ = quote.b6();                                                                                                                                                                                                          │
│         bytes6[] memory path = paths;                                                                                                                                                                                                        │
│         for (uint256 p = 0; p < path.length; p++) {                                                                                                                                                                                          │
│             (price, updateTime) = _peek(base_, path, price, updateTime);                                                                                                                                                                     │
│             base_ = path;                                                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│         (price, updateTime) = _peek(base_, quote_, price, updateTime);                                                                                                                                                                       │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                                │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price = 1e18;                                                                                                                                                                                                                │
│         bytes6 base_ = base.b6();                                                                                                                                                                                                            │
│         bytes6 quote_ = quote.b6();                                                                                                                                                                                                          │
│         bytes6[] memory path = paths;                                                                                                                                                                                                        │
│         for (uint256 p = 0; p < path.length; p++) {                                                                                                                                                                                          │
│             (price, updateTime) = _get(base_, path, price, updateTime);                                                                                                                                                                      │
│             base_ = path;                                                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│         (price, updateTime) = _get(base_, quote_, price, updateTime);                                                                                                                                                                        │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                                │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price = 1e18;                                                                                                                                                                                                                │
│         bytes6 base_ = base.b6();                                                                                                                                                                                                            │
│         bytes6 quote_ = quote.b6();                                                                                                                                                                                                          │
│         bytes6[] memory path = paths;                                                                                                                                                                                                        │
│         for (uint256 p = 0; p < path.length; p++) {                                                                                                                                                                                          │
│             (price, updateTime) = _get(base_, path, price, updateTime);                                                                                                                                                                      │
│             base_ = path;                                                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│         (price, updateTime) = _get(base_, quote_, price, updateTime);                                                                                                                                                                        │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                                │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _get(base.b6(), quote.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes"}                                                                                                                                                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function get(bytes32 base, bytes32 quote, uint256 amount)                                                                                                                                                                                │
│         external virtual override                                                                                                                                                                                                            │
│         returns (uint256 value, uint256 updateTime)                                                                                                                                                                                          │
│     {                                                                                                                                                                                                                                        │
│         uint256 price;                                                                                                                                                                                                                       │
│         (price, updateTime) = _get(base.b6(), quote.b6());                                                                                                                                                                                   │
│         value = price * amount / 1e18;                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _setSource(bytes6 cTokenId, bytes6 underlying, address source) internal {                                                                                                                                                       │
│         uint8 decimals_ = 18; // Does the borrowing rate have 18 decimals?                                                                                                                                                                   │
│         require (decimals_ <= 18, "Unsupported decimals");                                                                                                                                                                                   │
│         sources = Source({                                                                                                                                                                                                                   │
│             source: source,                                                                                                                                                                                                                  │
│             decimals: decimals_,                                                                                                                                                                                                             │
│             inverse: false                                                                                                                                                                                                                   │
│         });                                                                                                                                                                                                                                  │
│         sources = Source({                                                                                                                                                                                                                   │
│             source: source,                                                                                                                                                                                                                  │
│             decimals: decimals_,                                                                                                                                                                                                             │
│             inverse: true                                                                                                                                                                                                                    │
│         });                                                                                                                                                                                                                                  │
│         emit SourceSet(cTokenId, underlying, source);                                                                                                                                                                                        │
│         emit SourceSet(underlying, cTokenId, source);                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No"}                                                                                                                                                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _mintInternal(address to, bool calculateFromBase, uint256 fyTokenToBuy, uint256 minTokensMinted)                                                                                                                                │
│         internal                                                                                                                                                                                                                             │
│         returns (uint256, uint256, uint256)                                                                                                                                                                                                  │
│     {                                                                                                                                                                                                                                        │
│         // Gather data                                                                                                                                                                                                                       │
│         uint256 supply = _totalSupply;                                                                                                                                                                                                       │
│         (uint112 _baseCached, uint112 _fyTokenCached) =                                                                                                                                                                                      │
│             (baseCached, fyTokenCached);                                                                                                                                                                                                     │
│         uint256 _realFYTokenCached = _fyTokenCached - supply;    // The fyToken cache includes the virtual fyToken, equal to the supply                                                                                                      │
│                                                                                                                                                                                                                                              │
│         // Calculate trade                                                                                                                                                                                                                   │
│         uint256 tokensMinted;                                                                                                                                                                                                                │
│         uint256 baseIn;                                                                                                                                                                                                                      │
│         uint256 baseReturned;                                                                                                                                                                                                                │
│         uint256 fyTokenIn;                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         if (supply == 0) {                                                                                                                                                                                                                   │
│             require (calculateFromBase && fyTokenToBuy == 0, "Pool: Initialize only from base");                                                                                                                                             │
│             baseIn = base.balanceOf(address(this)) - _baseCached;                                                                                                                                                                            │
│             tokensMinted = baseIn;   // If supply == 0 we are initializing the pool and tokensMinted == baseIn; fyTokenIn == 0                                                                                                               │
│         } else {                                                                                                                                                                                                                             │
│             // There is an optional virtual trade before the mint                                                                                                                                                                            │
│             uint256 baseToSell;                                                                                                                                                                                                              │
│             if (fyTokenToBuy > 0) {     // calculateFromBase == true and fyTokenToBuy > 0 can't happen in this implementation. To implement a virtual trade and calculateFromBase the trade would need to be a BaseToBuy parameter.          │
│                 baseToSell = _buyFYTokenPreview(                                                                                                                                                                                             │
│                     fyTokenToBuy.u128(),                                                                                                                                                                                                     │
│                     _baseCached,                                                                                                                                                                                                             │
│                     _fyTokenCached                                                                                                                                                                                                           │
│                 );                                                                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│             if (calculateFromBase) {   // We use all the available base tokens, surplus is in fyTokens                                                                                                                                       │
│                 baseIn = base.balanceOf(address(this)) - _baseCached;                                                                                                                                                                        │
│                 tokensMinted = (supply * baseIn) / _baseCached;                                                                                                                                                                              │
│                 fyTokenIn = (_realFYTokenCached * tokensMinted) / supply;                                                                                                                                                                    │
│                 require(_realFYTokenCached + fyTokenIn <= fyToken.balanceOf(address(this)), "Pool: Not enough fyToken in");                                                                                                                  │
│             } else {                   // We use all the available fyTokens, plus a virtual trade if it happened, surplus is in base tokens                                                                                                  │
│                 fyTokenIn = fyToken.balanceOf(address(this)) - _realFYTokenCached;                                                                                                                                                           │
│                 tokensMinted = (supply * (fyTokenToBuy + fyTokenIn)) / (_realFYTokenCached - fyTokenToBuy);                                                                                                                                  │
│                 baseIn = baseToSell + ((_baseCached + baseToSell) * tokensMinted) / supply;                                                                                                                                                  │
│                 uint256 _baseBalance = base.balanceOf(address(this));                                                                                                                                                                        │
│                 require(_baseBalance - _baseCached >= baseIn, "Pool: Not enough base token in");                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│                 // If we did a trade means we came in through `mintWithBase`, and want to return the base token surplus                                                                                                                      │
│                 if (fyTokenToBuy > 0) baseReturned = (_baseBalance - _baseCached) - baseIn;                                                                                                                                                  │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Slippage                                                                                                                                                                                                                          │
│         require (tokensMinted >= minTokensMinted, "Pool: Not enough tokens minted");                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Update TWAR                                                                                                                                                                                                                       │
│         _update(                                                                                                                                                                                                                             │
│             (_baseCached + baseIn).u128(),                                                                                                                                                                                                   │
│             (_fyTokenCached + fyTokenIn + tokensMinted).u128(), // Account for the "virtual" fyToken from the new minted LP tokens                                                                                                           │
│             _baseCached,                                                                                                                                                                                                                     │
│             _fyTokenCached                                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Execute mint                                                                                                                                                                                                                      │
│         _mint(to, tokensMinted);                                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Return any unused base if we did a trade, meaning slippage was involved.                                                                                                                                                          │
│         if (supply > 0 && fyTokenToBuy > 0) base.safeTransfer(to, baseReturned);                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         emit Liquidity(maturity, msg.sender, to, -(baseIn.i256()), -(fyTokenIn.i256()), tokensMinted.i256());                                                                                                                                │
│         return (baseIn, fyTokenIn, tokensMinted);                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _mintInternal(address to, bool calculateFromBase, uint256 fyTokenToBuy, uint256 minTokensMinted)                                                                                                                                │
│         internal                                                                                                                                                                                                                             │
│         returns (uint256, uint256, uint256)                                                                                                                                                                                                  │
│     {                                                                                                                                                                                                                                        │
│         // Gather data                                                                                                                                                                                                                       │
│         uint256 supply = _totalSupply;                                                                                                                                                                                                       │
│         (uint112 _baseCached, uint112 _fyTokenCached) =                                                                                                                                                                                      │
│             (baseCached, fyTokenCached);                                                                                                                                                                                                     │
│         uint256 _realFYTokenCached = _fyTokenCached - supply;    // The fyToken cache includes the virtual fyToken, equal to the supply                                                                                                      │
│                                                                                                                                                                                                                                              │
│         // Calculate trade                                                                                                                                                                                                                   │
│         uint256 tokensMinted;                                                                                                                                                                                                                │
│         uint256 baseIn;                                                                                                                                                                                                                      │
│         uint256 baseReturned;                                                                                                                                                                                                                │
│         uint256 fyTokenIn;                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         if (supply == 0) {                                                                                                                                                                                                                   │
│             require (calculateFromBase && fyTokenToBuy == 0, "Pool: Initialize only from base");                                                                                                                                             │
│             baseIn = base.balanceOf(address(this)) - _baseCached;                                                                                                                                                                            │
│             tokensMinted = baseIn;   // If supply == 0 we are initializing the pool and tokensMinted == baseIn; fyTokenIn == 0                                                                                                               │
│         } else {                                                                                                                                                                                                                             │
│             // There is an optional virtual trade before the mint                                                                                                                                                                            │
│             uint256 baseToSell;                                                                                                                                                                                                              │
│             if (fyTokenToBuy > 0) {     // calculateFromBase == true and fyTokenToBuy > 0 can't happen in this implementation. To implement a virtual trade and calculateFromBase the trade would need to be a BaseToBuy parameter.          │
│                 baseToSell = _buyFYTokenPreview(                                                                                                                                                                                             │
│                     fyTokenToBuy.u128(),                                                                                                                                                                                                     │
│                     _baseCached,                                                                                                                                                                                                             │
│                     _fyTokenCached                                                                                                                                                                                                           │
│                 );                                                                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│             if (calculateFromBase) {   // We use all the available base tokens, surplus is in fyTokens                                                                                                                                       │
│                 baseIn = base.balanceOf(address(this)) - _baseCached;                                                                                                                                                                        │
│                 tokensMinted = (supply * baseIn) / _baseCached;                                                                                                                                                                              │
│                 fyTokenIn = (_realFYTokenCached * tokensMinted) / supply;                                                                                                                                                                    │
│                 require(_realFYTokenCached + fyTokenIn <= fyToken.balanceOf(address(this)), "Pool: Not enough fyToken in");                                                                                                                  │
│             } else {                   // We use all the available fyTokens, plus a virtual trade if it happened, surplus is in base tokens                                                                                                  │
│                 fyTokenIn = fyToken.balanceOf(address(this)) - _realFYTokenCached;                                                                                                                                                           │
│                 tokensMinted = (supply * (fyTokenToBuy + fyTokenIn)) / (_realFYTokenCached - fyTokenToBuy);                                                                                                                                  │
│                 baseIn = baseToSell + ((_baseCached + baseToSell) * tokensMinted) / supply;                                                                                                                                                  │
│                 uint256 _baseBalance = base.balanceOf(address(this));                                                                                                                                                                        │
│                 require(_baseBalance - _baseCached >= baseIn, "Pool: Not enough base token in");                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│                 // If we did a trade means we came in through `mintWithBase`, and want to return the base token surplus                                                                                                                      │
│                 if (fyTokenToBuy > 0) baseReturned = (_baseBalance - _baseCached) - baseIn;                                                                                                                                                  │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Slippage                                                                                                                                                                                                                          │
│         require (tokensMinted >= minTokensMinted, "Pool: Not enough tokens minted");                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Update TWAR                                                                                                                                                                                                                       │
│         _update(                                                                                                                                                                                                                             │
│             (_baseCached + baseIn).u128(),                                                                                                                                                                                                   │
│             (_fyTokenCached + fyTokenIn + tokensMinted).u128(), // Account for the "virtual" fyToken from the new minted LP tokens                                                                                                           │
│             _baseCached,                                                                                                                                                                                                                     │
│             _fyTokenCached                                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Execute mint                                                                                                                                                                                                                      │
│         _mint(to, tokensMinted);                                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Return any unused base if we did a trade, meaning slippage was involved.                                                                                                                                                          │
│         if (supply > 0 && fyTokenToBuy > 0) base.safeTransfer(to, baseReturned);                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         emit Liquidity(maturity, msg.sender, to, -(baseIn.i256()), -(fyTokenIn.i256()), tokensMinted.i256());                                                                                                                                │
│         return (baseIn, fyTokenIn, tokensMinted);                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _mintInternal(address to, bool calculateFromBase, uint256 fyTokenToBuy, uint256 minTokensMinted)                                                                                                                                │
│         internal                                                                                                                                                                                                                             │
│         returns (uint256, uint256, uint256)                                                                                                                                                                                                  │
│     {                                                                                                                                                                                                                                        │
│         // Gather data                                                                                                                                                                                                                       │
│         uint256 supply = _totalSupply;                                                                                                                                                                                                       │
│         (uint112 _baseCached, uint112 _fyTokenCached) =                                                                                                                                                                                      │
│             (baseCached, fyTokenCached);                                                                                                                                                                                                     │
│         uint256 _realFYTokenCached = _fyTokenCached - supply;    // The fyToken cache includes the virtual fyToken, equal to the supply                                                                                                      │
│                                                                                                                                                                                                                                              │
│         // Calculate trade                                                                                                                                                                                                                   │
│         uint256 tokensMinted;                                                                                                                                                                                                                │
│         uint256 baseIn;                                                                                                                                                                                                                      │
│         uint256 baseReturned;                                                                                                                                                                                                                │
│         uint256 fyTokenIn;                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         if (supply == 0) {                                                                                                                                                                                                                   │
│             require (calculateFromBase && fyTokenToBuy == 0, "Pool: Initialize only from base");                                                                                                                                             │
│             baseIn = base.balanceOf(address(this)) - _baseCached;                                                                                                                                                                            │
│             tokensMinted = baseIn;   // If supply == 0 we are initializing the pool and tokensMinted == baseIn; fyTokenIn == 0                                                                                                               │
│         } else {                                                                                                                                                                                                                             │
│             // There is an optional virtual trade before the mint                                                                                                                                                                            │
│             uint256 baseToSell;                                                                                                                                                                                                              │
│             if (fyTokenToBuy > 0) {     // calculateFromBase == true and fyTokenToBuy > 0 can't happen in this implementation. To implement a virtual trade and calculateFromBase the trade would need to be a BaseToBuy parameter.          │
│                 baseToSell = _buyFYTokenPreview(                                                                                                                                                                                             │
│                     fyTokenToBuy.u128(),                                                                                                                                                                                                     │
│                     _baseCached,                                                                                                                                                                                                             │
│                     _fyTokenCached                                                                                                                                                                                                           │
│                 );                                                                                                                                                                                                                           │
│             }                                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│             if (calculateFromBase) {   // We use all the available base tokens, surplus is in fyTokens                                                                                                                                       │
│                 baseIn = base.balanceOf(address(this)) - _baseCached;                                                                                                                                                                        │
│                 tokensMinted = (supply * baseIn) / _baseCached;                                                                                                                                                                              │
│                 fyTokenIn = (_realFYTokenCached * tokensMinted) / supply;                                                                                                                                                                    │
│                 require(_realFYTokenCached + fyTokenIn <= fyToken.balanceOf(address(this)), "Pool: Not enough fyToken in");                                                                                                                  │
│             } else {                   // We use all the available fyTokens, plus a virtual trade if it happened, surplus is in base tokens                                                                                                  │
│                 fyTokenIn = fyToken.balanceOf(address(this)) - _realFYTokenCached;                                                                                                                                                           │
│                 tokensMinted = (supply * (fyTokenToBuy + fyTokenIn)) / (_realFYTokenCached - fyTokenToBuy);                                                                                                                                  │
│                 baseIn = baseToSell + ((_baseCached + baseToSell) * tokensMinted) / supply;                                                                                                                                                  │
│                 uint256 _baseBalance = base.balanceOf(address(this));                                                                                                                                                                        │
│                 require(_baseBalance - _baseCached >= baseIn, "Pool: Not enough base token in");                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│                 // If we did a trade means we came in through `mintWithBase`, and want to return the base token surplus                                                                                                                      │
│                 if (fyTokenToBuy > 0) baseReturned = (_baseBalance - _baseCached) - baseIn;                                                                                                                                                  │
│             }                                                                                                                                                                                                                                │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Slippage                                                                                                                                                                                                                          │
│         require (tokensMinted >= minTokensMinted, "Pool: Not enough tokens minted");                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         // Update TWAR                                                                                                                                                                                                                       │
│         _update(                                                                                                                                                                                                                             │
│             (_baseCached + baseIn).u128(),                                                                                                                                                                                                   │
│             (_fyTokenCached + fyTokenIn + tokensMinted).u128(), // Account for the "virtual" fyToken from the new minted LP tokens                                                                                                           │
│             _baseCached,                                                                                                                                                                                                                     │
│             _fyTokenCached                                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Execute mint                                                                                                                                                                                                                      │
│         _mint(to, tokensMinted);                                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Return any unused base if we did a trade, meaning slippage was involved.                                                                                                                                                          │
│         if (supply > 0 && fyTokenToBuy > 0) base.safeTransfer(to, baseReturned);                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         emit Liquidity(maturity, msg.sender, to, -(baseIn.i256()), -(fyTokenIn.i256()), tokensMinted.i256());                                                                                                                                │
│         return (baseIn, fyTokenIn, tokensMinted);                                                                                                                                                                                            │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _burnInternal(address to, bool tradeToBase, uint256 minBaseOut, uint256 minFYTokenOut)                                                                                                                                          │
│         internal                                                                                                                                                                                                                             │
│         returns (uint256 tokensBurned, uint256 tokenOut, uint256 fyTokenOut)                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         tokensBurned = _balanceOf;                                                                                                                                                                                                           │
│         uint256 supply = _totalSupply;                                                                                                                                                                                                       │
│         uint256 fyTokenBalance = fyToken.balanceOf(address(this));          // use the real balance rather than the virtual one                                                                                                              │
│         uint256 baseBalance = base.balanceOf(address(this));                                                                                                                                                                                 │
│         (uint112 _baseCached, uint112 _fyTokenCached) =                                                                                                                                                                                      │
│             (baseCached, fyTokenCached);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // Calculate trade                                                                                                                                                                                                                   │
│         tokenOut = (tokensBurned * baseBalance) / supply;                                                                                                                                                                                    │
│         fyTokenOut = (tokensBurned * fyTokenBalance) / supply;                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         if (tradeToBase) {                                                                                                                                                                                                                   │
│             (int128 _k, int128 _g2) = (k2, g2);                                                                                                                                                                                              │
│             tokenOut += YieldMath.baseOutForFYTokenIn(                      // This is a virtual sell                                                                                                                                        │
│                 _baseCached - tokenOut.u128(),                              // Cache, minus virtual burn                                                                                                                                     │
│                 _fyTokenCached - fyTokenOut.u128(),                         // Cache, minus virtual burn                                                                                                                                     │
│                 fyTokenOut.u128(),                                          // Sell the virtual fyToken obtained                                                                                                                             │
│                 maturity - uint32(block.timestamp),                         // This can't be called after maturity                                                                                                                           │
│                 _k,                                                                                                                                                                                                                          │
│                 _g2                                                                                                                                                                                                                          │
│             );                                                                                                                                                                                                                               │
│             fyTokenOut = 0;                                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Slippage                                                                                                                                                                                                                          │
│         require (tokenOut >= minBaseOut, "Pool: Not enough base tokens obtained");                                                                                                                                                           │
│         require (fyTokenOut >= minFYTokenOut, "Pool: Not enough fyToken obtained");                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         // Update TWAR                                                                                                                                                                                                                       │
│         _update(                                                                                                                                                                                                                             │
│             (baseBalance - tokenOut).u128(),                                                                                                                                                                                                 │
│             (fyTokenBalance - fyTokenOut + supply - tokensBurned).u128(),                                                                                                                                                                    │
│             _baseCached,                                                                                                                                                                                                                     │
│             _fyTokenCached                                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Transfer assets                                                                                                                                                                                                                   │
│         _burn(address(this), tokensBurned);                                                                                                                                                                                                  │
│         base.safeTransfer(to, tokenOut);                                                                                                                                                                                                     │
│         if (fyTokenOut > 0) IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         emit Liquidity(maturity, msg.sender, to, tokenOut.i256(), fyTokenOut.i256(), -(tokensBurned.i256()));                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "Yes"}                                                                                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function _burnInternal(address to, bool tradeToBase, uint256 minBaseOut, uint256 minFYTokenOut)                                                                                                                                          │
│         internal                                                                                                                                                                                                                             │
│         returns (uint256 tokensBurned, uint256 tokenOut, uint256 fyTokenOut)                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         tokensBurned = _balanceOf;                                                                                                                                                                                                           │
│         uint256 supply = _totalSupply;                                                                                                                                                                                                       │
│         uint256 fyTokenBalance = fyToken.balanceOf(address(this));          // use the real balance rather than the virtual one                                                                                                              │
│         uint256 baseBalance = base.balanceOf(address(this));                                                                                                                                                                                 │
│         (uint112 _baseCached, uint112 _fyTokenCached) =                                                                                                                                                                                      │
│             (baseCached, fyTokenCached);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // Calculate trade                                                                                                                                                                                                                   │
│         tokenOut = (tokensBurned * baseBalance) / supply;                                                                                                                                                                                    │
│         fyTokenOut = (tokensBurned * fyTokenBalance) / supply;                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         if (tradeToBase) {                                                                                                                                                                                                                   │
│             (int128 _k, int128 _g2) = (k2, g2);                                                                                                                                                                                              │
│             tokenOut += YieldMath.baseOutForFYTokenIn(                      // This is a virtual sell                                                                                                                                        │
│                 _baseCached - tokenOut.u128(),                              // Cache, minus virtual burn                                                                                                                                     │
│                 _fyTokenCached - fyTokenOut.u128(),                         // Cache, minus virtual burn                                                                                                                                     │
│                 fyTokenOut.u128(),                                          // Sell the virtual fyToken obtained                                                                                                                             │
│                 maturity - uint32(block.timestamp),                         // This can't be called after maturity                                                                                                                           │
│                 _k,                                                                                                                                                                                                                          │
│                 _g2                                                                                                                                                                                                                          │
│             );                                                                                                                                                                                                                               │
│             fyTokenOut = 0;                                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Slippage                                                                                                                                                                                                                          │
│         require (tokenOut >= minBaseOut, "Pool: Not enough base tokens obtained");                                                                                                                                                           │
│         require (fyTokenOut >= minFYTokenOut, "Pool: Not enough fyToken obtained");                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         // Update TWAR                                                                                                                                                                                                                       │
│         _update(                                                                                                                                                                                                                             │
│             (baseBalance - tokenOut).u128(),                                                                                                                                                                                                 │
│             (fyTokenBalance - fyTokenOut + supply - tokensBurned).u128(),                                                                                                                                                                    │
│             _baseCached,                                                                                                                                                                                                                     │
│             _fyTokenCached                                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Transfer assets                                                                                                                                                                                                                   │
│         _burn(address(this), tokensBurned);                                                                                                                                                                                                  │
│         base.safeTransfer(to, tokenOut);                                                                                                                                                                                                     │
│         if (fyTokenOut > 0) IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         emit Liquidity(maturity, msg.sender, to, tokenOut.i256(), fyTokenOut.i256(), -(tokensBurned.i256()));                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _burnInternal(address to, bool tradeToBase, uint256 minBaseOut, uint256 minFYTokenOut)                                                                                                                                          │
│         internal                                                                                                                                                                                                                             │
│         returns (uint256 tokensBurned, uint256 tokenOut, uint256 fyTokenOut)                                                                                                                                                                 │
│     {                                                                                                                                                                                                                                        │
│                                                                                                                                                                                                                                              │
│         tokensBurned = _balanceOf;                                                                                                                                                                                                           │
│         uint256 supply = _totalSupply;                                                                                                                                                                                                       │
│         uint256 fyTokenBalance = fyToken.balanceOf(address(this));          // use the real balance rather than the virtual one                                                                                                              │
│         uint256 baseBalance = base.balanceOf(address(this));                                                                                                                                                                                 │
│         (uint112 _baseCached, uint112 _fyTokenCached) =                                                                                                                                                                                      │
│             (baseCached, fyTokenCached);                                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         // Calculate trade                                                                                                                                                                                                                   │
│         tokenOut = (tokensBurned * baseBalance) / supply;                                                                                                                                                                                    │
│         fyTokenOut = (tokensBurned * fyTokenBalance) / supply;                                                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         if (tradeToBase) {                                                                                                                                                                                                                   │
│             (int128 _k, int128 _g2) = (k2, g2);                                                                                                                                                                                              │
│             tokenOut += YieldMath.baseOutForFYTokenIn(                      // This is a virtual sell                                                                                                                                        │
│                 _baseCached - tokenOut.u128(),                              // Cache, minus virtual burn                                                                                                                                     │
│                 _fyTokenCached - fyTokenOut.u128(),                         // Cache, minus virtual burn                                                                                                                                     │
│                 fyTokenOut.u128(),                                          // Sell the virtual fyToken obtained                                                                                                                             │
│                 maturity - uint32(block.timestamp),                         // This can't be called after maturity                                                                                                                           │
│                 _k,                                                                                                                                                                                                                          │
│                 _g2                                                                                                                                                                                                                          │
│             );                                                                                                                                                                                                                               │
│             fyTokenOut = 0;                                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Slippage                                                                                                                                                                                                                          │
│         require (tokenOut >= minBaseOut, "Pool: Not enough base tokens obtained");                                                                                                                                                           │
│         require (fyTokenOut >= minFYTokenOut, "Pool: Not enough fyToken obtained");                                                                                                                                                          │
│                                                                                                                                                                                                                                              │
│         // Update TWAR                                                                                                                                                                                                                       │
│         _update(                                                                                                                                                                                                                             │
│             (baseBalance - tokenOut).u128(),                                                                                                                                                                                                 │
│             (fyTokenBalance - fyTokenOut + supply - tokensBurned).u128(),                                                                                                                                                                    │
│             _baseCached,                                                                                                                                                                                                                     │
│             _fyTokenCached                                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         // Transfer assets                                                                                                                                                                                                                   │
│         _burn(address(this), tokensBurned);                                                                                                                                                                                                  │
│         base.safeTransfer(to, tokenOut);                                                                                                                                                                                                     │
│         if (fyTokenOut > 0) IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         emit Liquidity(maturity, msg.sender, to, tokenOut.i256(), fyTokenOut.i256(), -(tokensBurned.i256()));                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function startPool()                                                                                                                                                                                                                     │
│         public                                                                                                                                                                                                                               │
│     {                                                                                                                                                                                                                                        │
│         require(pool == IPool(address(0)), "Current pool exists");                                                                                                                                                                           │
│         require(nextPool != IPool(address(0)), "Next pool not set");                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         pool = nextPool;                                                                                                                                                                                                                     │
│         fyToken = pool.fyToken();                                                                                                                                                                                                            │
│         seriesId = nextSeriesId;                                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         delete nextPool;                                                                                                                                                                                                                     │
│         delete nextSeriesId;                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         (vaultId, ) = ladle.build(seriesId, baseId, 0);                                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         // Find pool proportion p = tokenReserves/(tokenReserves + fyTokenReserves)                                                                                                                                                          │
│         // Deposit (investment * p) base to borrow (investment * p) fyToken                                                                                                                                                                  │
│         //   (investment * p) fyToken + (investment * (1 - p)) base = investment                                                                                                                                                             │
│         //   (investment * p) / ((investment * p) + (investment * (1 - p))) = p                                                                                                                                                              │
│         //   (investment * (1 - p)) / ((investment * p) + (investment * (1 - p))) = 1 - p                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         uint256 baseBalance = base.balanceOf(address(this));                                                                                                                                                                                 │
│         require(baseBalance > 0, "No funds to start with");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         uint256 baseInPool = base.balanceOf(address(pool));                                                                                                                                                                                  │
│         uint256 fyTokenInPool = fyToken.balanceOf(address(pool));                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         uint256 baseToPool = (baseBalance * baseInPool) / (baseInPool + fyTokenInPool);  // Rounds down                                                                                                                                      │
│         uint256 fyTokenToPool = baseBalance - baseToPool;        // fyTokenToPool is rounded up                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         // Borrow fyToken with base as collateral                                                                                                                                                                                            │
│         base.safeTransfer(baseJoin, fyTokenToPool);                                                                                                                                                                                          │
│         int128 fyTokenToPool_ = fyTokenToPool.u128().i128();                                                                                                                                                                                 │
│         ladle.pour(vaultId, address(pool), fyTokenToPool_, fyTokenToPool_);                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Mint LP tokens with (investment * p) fyToken and (investment * (1 - p)) base                                                                                                                                                      │
│         base.safeTransfer(address(pool), baseToPool);                                                                                                                                                                                        │
│         (,, cached) = pool.mint(address(this), true, 0); // We don't care about slippage                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (_totalSupply == 0) _mint(msg.sender, cached); // Initialize the strategy if needed                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         emit PoolStarted(address(pool));                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "Yes", "2": "No", "3": "Yes"}                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function startPool()                                                                                                                                                                                                                     │
│         public                                                                                                                                                                                                                               │
│     {                                                                                                                                                                                                                                        │
│         require(pool == IPool(address(0)), "Current pool exists");                                                                                                                                                                           │
│         require(nextPool != IPool(address(0)), "Next pool not set");                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         pool = nextPool;                                                                                                                                                                                                                     │
│         fyToken = pool.fyToken();                                                                                                                                                                                                            │
│         seriesId = nextSeriesId;                                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         delete nextPool;                                                                                                                                                                                                                     │
│         delete nextSeriesId;                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         (vaultId, ) = ladle.build(seriesId, baseId, 0);                                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         // Find pool proportion p = tokenReserves/(tokenReserves + fyTokenReserves)                                                                                                                                                          │
│         // Deposit (investment * p) base to borrow (investment * p) fyToken                                                                                                                                                                  │
│         //   (investment * p) fyToken + (investment * (1 - p)) base = investment                                                                                                                                                             │
│         //   (investment * p) / ((investment * p) + (investment * (1 - p))) = p                                                                                                                                                              │
│         //   (investment * (1 - p)) / ((investment * p) + (investment * (1 - p))) = 1 - p                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         uint256 baseBalance = base.balanceOf(address(this));                                                                                                                                                                                 │
│         require(baseBalance > 0, "No funds to start with");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         uint256 baseInPool = base.balanceOf(address(pool));                                                                                                                                                                                  │
│         uint256 fyTokenInPool = fyToken.balanceOf(address(pool));                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         uint256 baseToPool = (baseBalance * baseInPool) / (baseInPool + fyTokenInPool);  // Rounds down                                                                                                                                      │
│         uint256 fyTokenToPool = baseBalance - baseToPool;        // fyTokenToPool is rounded up                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         // Borrow fyToken with base as collateral                                                                                                                                                                                            │
│         base.safeTransfer(baseJoin, fyTokenToPool);                                                                                                                                                                                          │
│         int128 fyTokenToPool_ = fyTokenToPool.u128().i128();                                                                                                                                                                                 │
│         ladle.pour(vaultId, address(pool), fyTokenToPool_, fyTokenToPool_);                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Mint LP tokens with (investment * p) fyToken and (investment * (1 - p)) base                                                                                                                                                      │
│         base.safeTransfer(address(pool), baseToPool);                                                                                                                                                                                        │
│         (,, cached) = pool.mint(address(this), true, 0); // We don't care about slippage                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (_totalSupply == 0) _mint(msg.sender, cached); // Initialize the strategy if needed                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         emit PoolStarted(address(pool));                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function startPool()                                                                                                                                                                                                                     │
│         public                                                                                                                                                                                                                               │
│     {                                                                                                                                                                                                                                        │
│         require(pool == IPool(address(0)), "Current pool exists");                                                                                                                                                                           │
│         require(nextPool != IPool(address(0)), "Next pool not set");                                                                                                                                                                         │
│                                                                                                                                                                                                                                              │
│         pool = nextPool;                                                                                                                                                                                                                     │
│         fyToken = pool.fyToken();                                                                                                                                                                                                            │
│         seriesId = nextSeriesId;                                                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         delete nextPool;                                                                                                                                                                                                                     │
│         delete nextSeriesId;                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                                              │
│         (vaultId, ) = ladle.build(seriesId, baseId, 0);                                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         // Find pool proportion p = tokenReserves/(tokenReserves + fyTokenReserves)                                                                                                                                                          │
│         // Deposit (investment * p) base to borrow (investment * p) fyToken                                                                                                                                                                  │
│         //   (investment * p) fyToken + (investment * (1 - p)) base = investment                                                                                                                                                             │
│         //   (investment * p) / ((investment * p) + (investment * (1 - p))) = p                                                                                                                                                              │
│         //   (investment * (1 - p)) / ((investment * p) + (investment * (1 - p))) = 1 - p                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         uint256 baseBalance = base.balanceOf(address(this));                                                                                                                                                                                 │
│         require(baseBalance > 0, "No funds to start with");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         uint256 baseInPool = base.balanceOf(address(pool));                                                                                                                                                                                  │
│         uint256 fyTokenInPool = fyToken.balanceOf(address(pool));                                                                                                                                                                            │
│                                                                                                                                                                                                                                              │
│         uint256 baseToPool = (baseBalance * baseInPool) / (baseInPool + fyTokenInPool);  // Rounds down                                                                                                                                      │
│         uint256 fyTokenToPool = baseBalance - baseToPool;        // fyTokenToPool is rounded up                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         // Borrow fyToken with base as collateral                                                                                                                                                                                            │
│         base.safeTransfer(baseJoin, fyTokenToPool);                                                                                                                                                                                          │
│         int128 fyTokenToPool_ = fyTokenToPool.u128().i128();                                                                                                                                                                                 │
│         ladle.pour(vaultId, address(pool), fyTokenToPool_, fyTokenToPool_);                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         // Mint LP tokens with (investment * p) fyToken and (investment * (1 - p)) base                                                                                                                                                      │
│         base.safeTransfer(address(pool), baseToPool);                                                                                                                                                                                        │
│         (,, cached) = pool.mint(address(this), true, 0); // We don't care about slippage                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (_totalSupply == 0) _mint(msg.sender, cached); // Initialize the strategy if needed                                                                                                                                               │
│                                                                                                                                                                                                                                              │
│         emit PoolStarted(address(pool));                                                                                                                                                                                                     │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ Code:                                                                                                                                                                                                                                        │
│     function endPool()                                                                                                                                                                                                                       │
│         public                                                                                                                                                                                                                               │
│         afterMaturity                                                                                                                                                                                                                        │
│     {                                                                                                                                                                                                                                        │
│         uint256 toDivest = pool.balanceOf(address(this));                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Burn lpTokens                                                                                                                                                                                                                     │
│         IERC20(address(pool)).safeTransfer(address(pool), toDivest);                                                                                                                                                                         │
│         (,, uint256 fyTokenDivested) = pool.burn(address(this), 0, 0); // We don't care about slippage                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // Repay with fyToken as much as possible                                                                                                                                                                                            │
│         DataTypes.Balances memory balances_ = cauldron.balances(vaultId);                                                                                                                                                                    │
│         uint256 debt = balances_.art;                                                                                                                                                                                                        │
│         uint256 toRepay = (debt >= fyTokenDivested) ? fyTokenDivested : debt;                                                                                                                                                                │
│         if (toRepay > 0) {                                                                                                                                                                                                                   │
│             IERC20(address(fyToken)).safeTransfer(address(fyToken), toRepay);                                                                                                                                                                │
│             int128 toRepay_ = toRepay.u128().i128();                                                                                                                                                                                         │
│             ladle.pour(vaultId, address(this), 0, -toRepay_);                                                                                                                                                                                │
│             debt -= toRepay;                                                                                                                                                                                                                 │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Redeem any fyToken surplus                                                                                                                                                                                                        │
│         uint256 toRedeem = fyTokenDivested - toRepay;                                                                                                                                                                                        │
│         if (toRedeem > 0) {                                                                                                                                                                                                                  │
│             IERC20(address(fyToken)).safeTransfer(address(fyToken), toRedeem);                                                                                                                                                               │
│             fyToken.redeem(address(this), toRedeem);                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Repay with underlying if there is still any debt                                                                                                                                                                                  │
│         if (debt > 0) {                                                                                                                                                                                                                      │
│             base.safeTransfer(address(baseJoin), cauldron.debtToBase(seriesId, debt.u128())); // The strategy can't lose money due to the pool invariant, there will always be enough if we get here.                                        │
│             int128 debt_ = debt.u128().i128();                                                                                                                                                                                               │
│             ladle.close(vaultId, address(this), 0, -debt_);   // Takes a fyToken amount as art parameter                                                                                                                                     │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Withdraw all collateral                                                                                                                                                                                                           │
│         ladle.pour(vaultId, address(this), -(balances_.ink.i128()), 0);                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         emit PoolEnded(address(pool));                                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // Clear up                                                                                                                                                                                                                          │
│         delete pool;                                                                                                                                                                                                                         │
│         delete fyToken;                                                                                                                                                                                                                      │
│         delete seriesId;                                                                                                                                                                                                                     │
│         delete cached;                                                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         ladle.destroy(vaultId);                                                                                                                                                                                                              │
│         delete vaultId;                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function endPool()                                                                                                                                                                                                                       │
│         public                                                                                                                                                                                                                               │
│         afterMaturity                                                                                                                                                                                                                        │
│     {                                                                                                                                                                                                                                        │
│         uint256 toDivest = pool.balanceOf(address(this));                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Burn lpTokens                                                                                                                                                                                                                     │
│         IERC20(address(pool)).safeTransfer(address(pool), toDivest);                                                                                                                                                                         │
│         (,, uint256 fyTokenDivested) = pool.burn(address(this), 0, 0); // We don't care about slippage                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // Repay with fyToken as much as possible                                                                                                                                                                                            │
│         DataTypes.Balances memory balances_ = cauldron.balances(vaultId);                                                                                                                                                                    │
│         uint256 debt = balances_.art;                                                                                                                                                                                                        │
│         uint256 toRepay = (debt >= fyTokenDivested) ? fyTokenDivested : debt;                                                                                                                                                                │
│         if (toRepay > 0) {                                                                                                                                                                                                                   │
│             IERC20(address(fyToken)).safeTransfer(address(fyToken), toRepay);                                                                                                                                                                │
│             int128 toRepay_ = toRepay.u128().i128();                                                                                                                                                                                         │
│             ladle.pour(vaultId, address(this), 0, -toRepay_);                                                                                                                                                                                │
│             debt -= toRepay;                                                                                                                                                                                                                 │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Redeem any fyToken surplus                                                                                                                                                                                                        │
│         uint256 toRedeem = fyTokenDivested - toRepay;                                                                                                                                                                                        │
│         if (toRedeem > 0) {                                                                                                                                                                                                                  │
│             IERC20(address(fyToken)).safeTransfer(address(fyToken), toRedeem);                                                                                                                                                               │
│             fyToken.redeem(address(this), toRedeem);                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Repay with underlying if there is still any debt                                                                                                                                                                                  │
│         if (debt > 0) {                                                                                                                                                                                                                      │
│             base.safeTransfer(address(baseJoin), cauldron.debtToBase(seriesId, debt.u128())); // The strategy can't lose money due to the pool invariant, there will always be enough if we get here.                                        │
│             int128 debt_ = debt.u128().i128();                                                                                                                                                                                               │
│             ladle.close(vaultId, address(this), 0, -debt_);   // Takes a fyToken amount as art parameter                                                                                                                                     │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Withdraw all collateral                                                                                                                                                                                                           │
│         ladle.pour(vaultId, address(this), -(balances_.ink.i128()), 0);                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         emit PoolEnded(address(pool));                                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // Clear up                                                                                                                                                                                                                          │
│         delete pool;                                                                                                                                                                                                                         │
│         delete fyToken;                                                                                                                                                                                                                      │
│         delete seriesId;                                                                                                                                                                                                                     │
│         delete cached;                                                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         ladle.destroy(vaultId);                                                                                                                                                                                                              │
│         delete vaultId;                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ mint or vest or collect token/liquidity/earning and assign them to the address recipient or to variable,                                                                                                                                     │
│ Code:                                                                                                                                                                                                                                        │
│     function mint(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         beforeMaturity                                                                                                                                                                                                                       │
│         returns (uint256 minted)                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         // minted = supply * value(deposit) / value(strategy)                                                                                                                                                                                │
│         uint256 deposit = pool.balanceOf(address(this)) - cached;                                                                                                                                                                            │
│         minted = _totalSupply * deposit / cached;                                                                                                                                                                                            │
│         cached += deposit;                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _mint(to, minted);                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No", "3": "Yes", "4": "Yes"}                                                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function mint(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         beforeMaturity                                                                                                                                                                                                                       │
│         returns (uint256 minted)                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         // minted = supply * value(deposit) / value(strategy)                                                                                                                                                                                │
│         uint256 deposit = pool.balanceOf(address(this)) - cached;                                                                                                                                                                            │
│         minted = _totalSupply * deposit / cached;                                                                                                                                                                                            │
│         cached += deposit;                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _mint(to, minted);                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: mint or vest or collect token/liquidity/earning and assign them to the address recipient or to variable, and this operation could be front run to benefit the account/address that can be controlled by the parameter and has no  │
│ sender check in the function code                                                                                                                                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function mint(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         beforeMaturity                                                                                                                                                                                                                       │
│         returns (uint256 minted)                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         // minted = supply * value(deposit) / value(strategy)                                                                                                                                                                                │
│         uint256 deposit = pool.balanceOf(address(this)) - cached;                                                                                                                                                                            │
│         minted = _totalSupply * deposit / cached;                                                                                                                                                                                            │
│         cached += deposit;                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _mint(to, minted);                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│     {                                                                                                                                                                                                                                        │
│         DataTypes.Series memory series;                                                                                                                                                                                                      │
│         if (art != 0) series = getSeries(vault.seriesId);                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         int128 fee;                                                                                                                                                                                                                          │
│         if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Update accounting                                                                                                                                                                                                                 │
│         cauldron.pour(vaultId, ink, art + fee);                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         // Manage collateral                                                                                                                                                                                                                 │
│         if (ink != 0) {                                                                                                                                                                                                                      │
│             IJoin ilkJoin = getJoin(vault.ilkId);                                                                                                                                                                                            │
│             if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));                                                                                                                                                                            │
│             if (ink < 0) ilkJoin.exit(to, uint128(-ink));                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Manage debt tokens                                                                                                                                                                                                                │
│         if (art != 0) {                                                                                                                                                                                                                      │
│             if (art > 0) series.fyToken.mint(to, uint128(art));                                                                                                                                                                              │
│             else series.fyToken.burn(msg.sender, uint128(-art));                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function mint(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         beforeMaturity                                                                                                                                                                                                                       │
│         returns (uint256 minted)                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         // minted = supply * value(deposit) / value(strategy)                                                                                                                                                                                │
│         uint256 deposit = pool.balanceOf(address(this)) - cached;                                                                                                                                                                            │
│         minted = _totalSupply * deposit / cached;                                                                                                                                                                                            │
│         cached += deposit;                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _mint(to, minted);                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│     {                                                                                                                                                                                                                                        │
│         DataTypes.Series memory series;                                                                                                                                                                                                      │
│         if (art != 0) series = getSeries(vault.seriesId);                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         int128 fee;                                                                                                                                                                                                                          │
│         if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Update accounting                                                                                                                                                                                                                 │
│         cauldron.pour(vaultId, ink, art + fee);                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         // Manage collateral                                                                                                                                                                                                                 │
│         if (ink != 0) {                                                                                                                                                                                                                      │
│             IJoin ilkJoin = getJoin(vault.ilkId);                                                                                                                                                                                            │
│             if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));                                                                                                                                                                            │
│             if (ink < 0) ilkJoin.exit(to, uint128(-ink));                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Manage debt tokens                                                                                                                                                                                                                │
│         if (art != 0) {                                                                                                                                                                                                                      │
│             if (art > 0) series.fyToken.mint(to, uint128(art));                                                                                                                                                                              │
│             else series.fyToken.burn(msg.sender, uint128(-art));                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function mint(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         beforeMaturity                                                                                                                                                                                                                       │
│         returns (uint256 minted)                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         // minted = supply * value(deposit) / value(strategy)                                                                                                                                                                                │
│         uint256 deposit = pool.balanceOf(address(this)) - cached;                                                                                                                                                                            │
│         minted = _totalSupply * deposit / cached;                                                                                                                                                                                            │
│         cached += deposit;                                                                                                                                                                                                                   │
│                                                                                                                                                                                                                                              │
│         _mint(to, minted);                                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                                                       │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function burn(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         returns (uint256 withdrawal)                                                                                                                                                                                                         │
│     {                                                                                                                                                                                                                                        │
│         // strategy * burnt/supply = withdrawal                                                                                                                                                                                              │
│         uint256 burnt = _balanceOf;                                                                                                                                                                                                          │
│         withdrawal = cached * burnt / _totalSupply;                                                                                                                                                                                          │
│         cached -= withdrawal;                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _burn(address(this), burnt);                                                                                                                                                                                                         │
│         IERC20(address(pool)).safeTransfer(to, withdrawal);                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes", "3": "No"}                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                                                   │
│ Code:                                                                                                                                                                                                                                        │
│     function burn(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         returns (uint256 withdrawal)                                                                                                                                                                                                         │
│     {                                                                                                                                                                                                                                        │
│         // strategy * burnt/supply = withdrawal                                                                                                                                                                                              │
│         uint256 burnt = _balanceOf;                                                                                                                                                                                                          │
│         withdrawal = cached * burnt / _totalSupply;                                                                                                                                                                                          │
│         cached -= withdrawal;                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _burn(address(this), burnt);                                                                                                                                                                                                         │
│         IERC20(address(pool)).safeTransfer(to, withdrawal);                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function repayLadle(bytes12 vaultId_)                                                                                                                                                                                                    │
│         external payable                                                                                                                                                                                                                     │
│         returns (uint256 repaid)                                                                                                                                                                                                             │
│     {                                                                                                                                                                                                                                        │
│         (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);                                                                                                                                                                │
│         DataTypes.Series memory series = getSeries(vault.seriesId);                                                                                                                                                                          │
│         DataTypes.Balances memory balances = cauldron.balances(vaultId);                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         uint256 amount = series.fyToken.balanceOf(address(this));                                                                                                                                                                            │
│         repaid = amount <= balances.art ? amount : balances.art;                                                                                                                                                                             │
│                                                                                                                                                                                                                                              │
│         // Update accounting                                                                                                                                                                                                                 │
│         cauldron.pour(vaultId, 0, -(repaid.u128().i128()));                                                                                                                                                                                  │
│         series.fyToken.burn(address(this), repaid);                                                                                                                                                                                          │
│     }                                                                                                                                                                                                                                        │
│     function burn(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         returns (uint256 withdrawal)                                                                                                                                                                                                         │
│     {                                                                                                                                                                                                                                        │
│         // strategy * burnt/supply = withdrawal                                                                                                                                                                                              │
│         uint256 burnt = _balanceOf;                                                                                                                                                                                                          │
│         withdrawal = cached * burnt / _totalSupply;                                                                                                                                                                                          │
│         cached -= withdrawal;                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _burn(address(this), burnt);                                                                                                                                                                                                         │
│         IERC20(address(pool)).safeTransfer(to, withdrawal);                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "No"}                                                                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                                                 │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                                             │
│ Code:                                                                                                                                                                                                                                        │
│     function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│     {                                                                                                                                                                                                                                        │
│         DataTypes.Series memory series;                                                                                                                                                                                                      │
│         if (art != 0) series = getSeries(vault.seriesId);                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         int128 fee;                                                                                                                                                                                                                          │
│         if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Update accounting                                                                                                                                                                                                                 │
│         cauldron.pour(vaultId, ink, art + fee);                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         // Manage collateral                                                                                                                                                                                                                 │
│         if (ink != 0) {                                                                                                                                                                                                                      │
│             IJoin ilkJoin = getJoin(vault.ilkId);                                                                                                                                                                                            │
│             if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));                                                                                                                                                                            │
│             if (ink < 0) ilkJoin.exit(to, uint128(-ink));                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Manage debt tokens                                                                                                                                                                                                                │
│         if (art != 0) {                                                                                                                                                                                                                      │
│             if (art > 0) series.fyToken.mint(to, uint128(art));                                                                                                                                                                              │
│             else series.fyToken.burn(msg.sender, uint128(-art));                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function burn(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         returns (uint256 withdrawal)                                                                                                                                                                                                         │
│     {                                                                                                                                                                                                                                        │
│         // strategy * burnt/supply = withdrawal                                                                                                                                                                                              │
│         uint256 burnt = _balanceOf;                                                                                                                                                                                                          │
│         withdrawal = cached * burnt / _totalSupply;                                                                                                                                                                                          │
│         cached -= withdrawal;                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _burn(address(this), burnt);                                                                                                                                                                                                         │
│         IERC20(address(pool)).safeTransfer(to, withdrawal);                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"1": "No", "2": "Yes"}                                                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ───────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                                                            │
│ Code:                                                                                                                                                                                                                                        │
│     function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)                                                                                                                                        │
│         private                                                                                                                                                                                                                              │
│     {                                                                                                                                                                                                                                        │
│         DataTypes.Series memory series;                                                                                                                                                                                                      │
│         if (art != 0) series = getSeries(vault.seriesId);                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         int128 fee;                                                                                                                                                                                                                          │
│         if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Update accounting                                                                                                                                                                                                                 │
│         cauldron.pour(vaultId, ink, art + fee);                                                                                                                                                                                              │
│                                                                                                                                                                                                                                              │
│         // Manage collateral                                                                                                                                                                                                                 │
│         if (ink != 0) {                                                                                                                                                                                                                      │
│             IJoin ilkJoin = getJoin(vault.ilkId);                                                                                                                                                                                            │
│             if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));                                                                                                                                                                            │
│             if (ink < 0) ilkJoin.exit(to, uint128(-ink));                                                                                                                                                                                    │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Manage debt tokens                                                                                                                                                                                                                │
│         if (art != 0) {                                                                                                                                                                                                                      │
│             if (art > 0) series.fyToken.mint(to, uint128(art));                                                                                                                                                                              │
│             else series.fyToken.burn(msg.sender, uint128(-art));                                                                                                                                                                             │
│         }                                                                                                                                                                                                                                    │
│     }                                                                                                                                                                                                                                        │
│     function burn(address to)                                                                                                                                                                                                                │
│         public                                                                                                                                                                                                                               │
│         returns (uint256 withdrawal)                                                                                                                                                                                                         │
│     {                                                                                                                                                                                                                                        │
│         // strategy * burnt/supply = withdrawal                                                                                                                                                                                              │
│         uint256 burnt = _balanceOf;                                                                                                                                                                                                          │
│         withdrawal = cached * burnt / _totalSupply;                                                                                                                                                                                          │
│         cached -= withdrawal;                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                              │
│         _burn(address(this), burnt);                                                                                                                                                                                                         │
│         IERC20(address(pool)).safeTransfer(to, withdrawal);                                                                                                                                                                                  │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{}}                                                                                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"baseBalance":"This variable holds the balance of the base token in the contract address.","fyTokenBalance":"This variable holds the balance of the fyToken in the contract address.","supply":"This variable holds the total  │
│ supply of the tokens.","tokensBurned":"This variable calculates the amount of tokens to be burned based on the balance of the contract address.","tokenOut":"This variable calculates the amount of base tokens to be outputted based on the │
│ tokens burned and the base balance.","fyTokenOut":"This variable calculates the amount of fyTokens to be outputted based on the tokens burned and the fyToken balance."}, "VariableB":{"tokenOut":"This variable holds the calculated value  │
│ of LP token."}}                                                                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   find_data_dependency   
┏━━━━━━━━━━┳━━━━━━━━━━━━━┓
┃ Argument ┃ Value       ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━┩
│ arg[0]   │ baseBalance │
│ arg[1]   │ tokenOut    │
└──────────┴─────────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _accrual(bytes6 seriesId, DataTypes.Series memory series_)                                                                                                                                                                      │
│         private                                                                                                                                                                                                                              │
│         returns (uint256 accrual_)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         uint256 rateAtMaturity = ratesAtMaturity;                                                                                                                                                                                            │
│         if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.                                                                                                                    │
│             _mature(seriesId, series_);                                                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                                             │
│             IOracle rateOracle = rateOracles;                                                                                                                                                                                                │
│             (uint256 rate,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18);                                                                                                                                                         │
│             accrual_ = rate.wdiv(rateAtMaturity);                                                                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│         accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate in the given code is `_mature(seriesId, series_);`.                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function _accrual(bytes6 seriesId, DataTypes.Series memory series_)                                                                                                                                                                      │
│         private                                                                                                                                                                                                                              │
│         returns (uint256 accrual_)                                                                                                                                                                                                           │
│     {                                                                                                                                                                                                                                        │
│         uint256 rateAtMaturity = ratesAtMaturity;                                                                                                                                                                                            │
│         if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.                                                                                                                    │
│             _mature(seriesId, series_);                                                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                                             │
│             IOracle rateOracle = rateOracles;                                                                                                                                                                                                │
│             (uint256 rate,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18);                                                                                                                                                         │
│             accrual_ = rate.wdiv(rateAtMaturity);                                                                                                                                                                                            │
│         }                                                                                                                                                                                                                                    │
│         accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)                                                                                                                                │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward in the given code is `uint256 rateAtMaturity = ratesAtMaturity;`.                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
               order_first_b                
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                         ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                            │
│ arg[1]   │ [_mature(seriesId, series_);] │
└──────────┴───────────────────────────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate in the given code is `if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();`.                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {                                                                                                                                            │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         address source = sources;                                                                                                                                                                                                            │
│         require (source != address(0), "Source not found");                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();                                                                                                                                                             │
│         else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();                                                                                                                                                  │
│         else revert("Unknown oracle type");                                                                                                                                                                                                  │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         price = rawPrice * SCALE_FACTOR;                                                                                                                                                                                                     │
│         updateTime = block.timestamp;                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `rawPrice = CTokenInterface(source).borrowIndex();`                                                                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                                      order_first_b                                      
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                                                      ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                                                                         │
│ arg[1]   │ [if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();] │
└──────────┴────────────────────────────────────────────────────────────────────────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"rawPrice":"This variable holds the market reserves/AMMprice/exchangeRate. It gets its value from either the borrowIndex or exchangeRateStored function of the CTokenInterface."}, "VariableB":{"price":"This variable holds   │
│ the calculated value/price of LP token. It is calculated by multiplying the rawPrice with the SCALE_FACTOR."}}                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
 find_data_dependency  
┏━━━━━━━━━━┳━━━━━━━━━━┓
┃ Argument ┃ Value    ┃
┡━━━━━━━━━━╇━━━━━━━━━━┩
│ arg[0]   │ rawPrice │
│ arg[1]   │ price    │
└──────────┴──────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"value":"Calculated value of LP token"}}                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"Variable name":"price", "Description":"This variable holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"Variable name":"value",         │
│ "Description":"This variable holds the calculated value/price of LP token."}}                                                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"value":"Calculated value of LP token"}}                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"value":"Calculated value of LP token"}}                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"value":"Calculated value of LP token"}}                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"price":"This variable holds the market reserves/AMMprice/exchangeRate or the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"value":"This variable holds the calculated value/price of LP   │
│ token."}}                                                                                                                                                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
find_data_dependency
┏━━━━━━━━━━┳━━━━━━━┓
┃ Argument ┃ Value ┃
┡━━━━━━━━━━╇━━━━━━━┩
│ arg[0]   │ price │
│ arg[1]   │ value │
└──────────┴───────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `rawPrice = CTokenInterface(source.source).exchangeRateStored();`                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {                                                                                                                                           │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateStored();                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `rawPrice = CTokenInterface(source.source).exchangeRateStored();`                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                                 order_first_b                                  
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                                             ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                                                                │
│ arg[1]   │ [rawPrice = CTokenInterface(source.source).exchangeRateStored();] │
└──────────┴───────────────────────────────────────────────────────────────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"rawPrice":"This variable holds the exchange rate of the token pair from the Compound protocol."}, "VariableB":{"price":"This variable holds the calculated value/price of LP token."}}                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
 find_data_dependency  
┏━━━━━━━━━━┳━━━━━━━━━━┓
┃ Argument ┃ Value    ┃
┡━━━━━━━━━━╇━━━━━━━━━━┩
│ arg[0]   │ rawPrice │
│ arg[1]   │ price    │
└──────────┴──────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"value":"Calculated value of LP token"}}                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"Variable name":"value","Description":"Holds the calculated value/price of LP token"}}                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"price":"This variable holds the market reserves/AMMprice/exchangeRate or the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"value":"This variable holds the calculated value/price of LP   │
│ token."}}                                                                                                                                                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
find_data_dependency
┏━━━━━━━━━━┳━━━━━━━┓
┃ Argument ┃ Value ┃
┡━━━━━━━━━━╇━━━━━━━┩
│ arg[0]   │ price │
│ arg[1]   │ value │
└──────────┴───────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"value":"Calculated value of LP token"}}                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"value":"Calculated value of LP token"}}                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"price":"This variable holds the market reserves/AMMprice/exchangeRate or the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"value":"This variable holds the calculated value/price of LP   │
│ token."}}                                                                                                                                                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
find_data_dependency
┏━━━━━━━━━━┳━━━━━━━┓
┃ Argument ┃ Value ┃
┡━━━━━━━━━━╇━━━━━━━┩
│ arg[0]   │ price │
│ arg[1]   │ value │
└──────────┴───────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"rawPrice":"This variable holds the current exchange rate of the token pair from the Compound protocol."}, "VariableB":{"price":"This variable holds the calculated value/price of LP token."}}                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
 find_data_dependency  
┏━━━━━━━━━━┳━━━━━━━━━━┓
┃ Argument ┃ Value    ┃
┡━━━━━━━━━━╇━━━━━━━━━━┩
│ arg[0]   │ rawPrice │
│ arg[1]   │ price    │
└──────────┴──────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `rawPrice = CTokenInterface(source.source).exchangeRateCurrent();`                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {                                                                                                                                                 │
│         uint256 rawPrice;                                                                                                                                                                                                                    │
│         Source memory source = sources;                                                                                                                                                                                                      │
│         require (source.source != address(0), "Source not found");                                                                                                                                                                           │
│                                                                                                                                                                                                                                              │
│         rawPrice = CTokenInterface(source.source).exchangeRateCurrent();                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         require(rawPrice > 0, "Compound price is zero");                                                                                                                                                                                     │
│                                                                                                                                                                                                                                              │
│         if (source.inverse == true) {                                                                                                                                                                                                        │
│             price = 10 ** (source.decimals + 18) / uint(rawPrice);                                                                                                                                                                           │
│         } else {                                                                                                                                                                                                                             │
│             price = uint(rawPrice) * 10 ** (18 - source.decimals);                                                                                                                                                                           │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         updateTime = block.timestamp; // We should get the timestamp                                                                                                                                                                         │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `rawPrice = CTokenInterface(source.source).exchangeRateCurrent();`                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                                  order_first_b                                  
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                                              ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                                                                 │
│ arg[1]   │ [rawPrice = CTokenInterface(source.source).exchangeRateCurrent();] │
└──────────┴────────────────────────────────────────────────────────────────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"price":"This variable holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation."}, "VariableB":{"value":"This variable holds the calculated value/price of LP   │
│ token."}}                                                                                                                                                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
find_data_dependency
┏━━━━━━━━━━┳━━━━━━━┓
┃ Argument ┃ Value ┃
┡━━━━━━━━━━╇━━━━━━━┩
│ arg[0]   │ price │
│ arg[1]   │ value │
└──────────┴───────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{}, "VariableB":{"value":"Calculated value of LP token"}}                                                                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"_baseCached":"This variable holds the cached value of the base token balance","_fyTokenCached":"This variable holds the cached value of the fyToken balance","base.balanceOf(address(this))":"This function call retrieves    │
│ the current balance of the base token in the contract","fyToken.balanceOf(address(this))":"This function call retrieves the current balance of the fyToken in the contract","_totalSupply":"This variable holds the total supply of the LP   │
│ tokens","_buyFYTokenPreview":"This function calculates the amount of base tokens needed to buy a certain amount of fyTokens"},"VariableB":{"tokensMinted":"This variable holds the calculated amount of LP tokens to be minted"}}            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   find_data_dependency    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ _baseCached  │
│ arg[1]   │ tokensMinted │
└──────────┴──────────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"tokensMinted":"This variable holds the value of total minted share or amount."}, "VariableB":{"supply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the              │
│ supply/liquidity is 0."}, "VariableC":{"baseIn":"This variable holds the value of the deposit/mint/add amount."}}                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:41:03] INFO     static_check: first_deposit_check: VariableA: tokensMinted; VariableB: supply; VariableC: baseIn                                                                                                static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ supply       │
│ arg[1]   │ baseIn       │
│ arg[2]   │ tokensMinted │
└──────────┴──────────────┘
                    ERROR    falcon_adapter: Traceback (most recent call last):                                                                                                                                            falcon_adapter.py:146
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/falcon_adapter.py", line 139, in first_deposit_check                                                                                                  
                                 left_part = text[:text.index("=")].strip()                                                                                                                                                                     
                             ValueError: substring not found                                                                                                                                                                                    
                                                                                                                                                                                                                                                
                    ERROR    falcon_adapter: Traceback (most recent call last):                                                                                                                                            falcon_adapter.py:146
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/falcon_adapter.py", line 139, in first_deposit_check                                                                                                  
                                 left_part = text[:text.index("=")].strip()                                                                                                                                                                     
                             ValueError: substring not found                                                                                                                                                                                    
                                                                                                                                                                                                                                                
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"tokensBurned":"This variable holds the balance of the contract itself, which can be interpreted as the total liquidity in the contract.","supply":"This variable holds the total supply of the                                │
│ tokens.","fyTokenBalance":"This variable holds the balance of fyToken in the contract, which can be interpreted as the reserve of fyToken.","baseBalance":"This variable holds the balance of base token in the contract, which can be       │
│ interpreted as the reserve of base token.","tokenOut":"This variable calculates the amount of base tokens to be traded out based on the proportion of tokens burned to the total supply.","fyTokenOut":"This variable calculates the amount  │
│ of fyTokens to be traded out based on the proportion of tokens burned to the total supply."}, "VariableB":{"tokenOut":"This variable holds the calculated value of LP token in terms of base token."}}                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   find_data_dependency    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ tokensBurned │
│ arg[1]   │ tokenOut     │
└──────────┴──────────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"baseInPool":"This variable holds the balance of the base token in the pool.", "fyTokenInPool":"This variable holds the balance of the fyToken in the pool.", "baseToPool":"This variable calculates the amount of base token  │
│ to be added to the pool.", "fyTokenToPool":"This variable calculates the amount of fyToken to be added to the pool."}, "VariableB":{"cached":"This variable holds the calculated value of LP token."}}                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
  find_data_dependency   
┏━━━━━━━━━━┳━━━━━━━━━━━━┓
┃ Argument ┃ Value      ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━┩
│ arg[0]   │ baseInPool │
│ arg[1]   │ cached     │
└──────────┴────────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {"VariableA":{"cached":"This variable holds the value of total minted share or amount."}, "VariableB":{"_totalSupply":"This variable holds the total supply/liquidity and is used by the conditional branch to determine if the              │
│ supply/liquidity is 0."}, "VariableC":{"baseToPool":"This variable holds the value of the deposit/mint/add amount."}}                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 16:41:14] INFO     static_check: first_deposit_check: VariableA: cached; VariableB: _totalSupply; VariableC: baseToPool                                                                                            static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ _totalSupply │
│ arg[1]   │ baseToPool   │
│ arg[2]   │ cached       │
└──────────┴──────────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                                                 │
│ Code:                                                                                                                                                                                                                                        │
│     function endPool()                                                                                                                                                                                                                       │
│         public                                                                                                                                                                                                                               │
│         afterMaturity                                                                                                                                                                                                                        │
│     {                                                                                                                                                                                                                                        │
│         uint256 toDivest = pool.balanceOf(address(this));                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Burn lpTokens                                                                                                                                                                                                                     │
│         IERC20(address(pool)).safeTransfer(address(pool), toDivest);                                                                                                                                                                         │
│         (,, uint256 fyTokenDivested) = pool.burn(address(this), 0, 0); // We don't care about slippage                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // Repay with fyToken as much as possible                                                                                                                                                                                            │
│         DataTypes.Balances memory balances_ = cauldron.balances(vaultId);                                                                                                                                                                    │
│         uint256 debt = balances_.art;                                                                                                                                                                                                        │
│         uint256 toRepay = (debt >= fyTokenDivested) ? fyTokenDivested : debt;                                                                                                                                                                │
│         if (toRepay > 0) {                                                                                                                                                                                                                   │
│             IERC20(address(fyToken)).safeTransfer(address(fyToken), toRepay);                                                                                                                                                                │
│             int128 toRepay_ = toRepay.u128().i128();                                                                                                                                                                                         │
│             ladle.pour(vaultId, address(this), 0, -toRepay_);                                                                                                                                                                                │
│             debt -= toRepay;                                                                                                                                                                                                                 │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Redeem any fyToken surplus                                                                                                                                                                                                        │
│         uint256 toRedeem = fyTokenDivested - toRepay;                                                                                                                                                                                        │
│         if (toRedeem > 0) {                                                                                                                                                                                                                  │
│             IERC20(address(fyToken)).safeTransfer(address(fyToken), toRedeem);                                                                                                                                                               │
│             fyToken.redeem(address(this), toRedeem);                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Repay with underlying if there is still any debt                                                                                                                                                                                  │
│         if (debt > 0) {                                                                                                                                                                                                                      │
│             base.safeTransfer(address(baseJoin), cauldron.debtToBase(seriesId, debt.u128())); // The strategy can't lose money due to the pool invariant, there will always be enough if we get here.                                        │
│             int128 debt_ = debt.u128().i128();                                                                                                                                                                                               │
│             ladle.close(vaultId, address(this), 0, -debt_);   // Takes a fyToken amount as art parameter                                                                                                                                     │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Withdraw all collateral                                                                                                                                                                                                           │
│         ladle.pour(vaultId, address(this), -(balances_.ink.i128()), 0);                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         emit PoolEnded(address(pool));                                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // Clear up                                                                                                                                                                                                                          │
│         delete pool;                                                                                                                                                                                                                         │
│         delete fyToken;                                                                                                                                                                                                                      │
│         delete seriesId;                                                                                                                                                                                                                     │
│         delete cached;                                                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         ladle.destroy(vaultId);                                                                                                                                                                                                              │
│         delete vaultId;                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate in the given code is `ladle.pour(vaultId, address(this), 0, -toRepay_);`.                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with backquotes.                  │
│ Code:                                                                                                                                                                                                                                        │
│     function endPool()                                                                                                                                                                                                                       │
│         public                                                                                                                                                                                                                               │
│         afterMaturity                                                                                                                                                                                                                        │
│     {                                                                                                                                                                                                                                        │
│         uint256 toDivest = pool.balanceOf(address(this));                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Burn lpTokens                                                                                                                                                                                                                     │
│         IERC20(address(pool)).safeTransfer(address(pool), toDivest);                                                                                                                                                                         │
│         (,, uint256 fyTokenDivested) = pool.burn(address(this), 0, 0); // We don't care about slippage                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // Repay with fyToken as much as possible                                                                                                                                                                                            │
│         DataTypes.Balances memory balances_ = cauldron.balances(vaultId);                                                                                                                                                                    │
│         uint256 debt = balances_.art;                                                                                                                                                                                                        │
│         uint256 toRepay = (debt >= fyTokenDivested) ? fyTokenDivested : debt;                                                                                                                                                                │
│         if (toRepay > 0) {                                                                                                                                                                                                                   │
│             IERC20(address(fyToken)).safeTransfer(address(fyToken), toRepay);                                                                                                                                                                │
│             int128 toRepay_ = toRepay.u128().i128();                                                                                                                                                                                         │
│             ladle.pour(vaultId, address(this), 0, -toRepay_);                                                                                                                                                                                │
│             debt -= toRepay;                                                                                                                                                                                                                 │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Redeem any fyToken surplus                                                                                                                                                                                                        │
│         uint256 toRedeem = fyTokenDivested - toRepay;                                                                                                                                                                                        │
│         if (toRedeem > 0) {                                                                                                                                                                                                                  │
│             IERC20(address(fyToken)).safeTransfer(address(fyToken), toRedeem);                                                                                                                                                               │
│             fyToken.redeem(address(this), toRedeem);                                                                                                                                                                                         │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Repay with underlying if there is still any debt                                                                                                                                                                                  │
│         if (debt > 0) {                                                                                                                                                                                                                      │
│             base.safeTransfer(address(baseJoin), cauldron.debtToBase(seriesId, debt.u128())); // The strategy can't lose money due to the pool invariant, there will always be enough if we get here.                                        │
│             int128 debt_ = debt.u128().i128();                                                                                                                                                                                               │
│             ladle.close(vaultId, address(this), 0, -debt_);   // Takes a fyToken amount as art parameter                                                                                                                                     │
│         }                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                              │
│         // Withdraw all collateral                                                                                                                                                                                                           │
│         ladle.pour(vaultId, address(this), -(balances_.ink.i128()), 0);                                                                                                                                                                      │
│                                                                                                                                                                                                                                              │
│         emit PoolEnded(address(pool));                                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         // Clear up                                                                                                                                                                                                                          │
│         delete pool;                                                                                                                                                                                                                         │
│         delete fyToken;                                                                                                                                                                                                                      │
│         delete seriesId;                                                                                                                                                                                                                     │
│         delete cached;                                                                                                                                                                                                                       │
│                                                                                                                                                                                                                                              │
│         ladle.destroy(vaultId);                                                                                                                                                                                                              │
│         delete vaultId;                                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Response ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward in the given code is `uint256 toDivest = pool.balanceOf(address(this));`.                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                          order_first_b                           
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                               ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ [uint256 toDivest = pool.balanceOf(address(this));] │
│ arg[1]   │ [ladle.pour(vaultId, address(this), 0, -toRepay_);] │
└──────────┴─────────────────────────────────────────────────────┘
[12/08/24 16:41:17] INFO     utils: Remove the redundant result:                                                                                                                                                                     utils.py:68
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-08-yield-main/contracts/FYToken.sol!!!FYToken!!!_burn!!!/home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-08-yield-main/c            
                             ontracts/yieldspace/Pool.sol!!!Pool!!!_burnInternal!!!price-manipulation                                                                                                                                           
                    INFO     utils: Remove the redundant result:                                                                                                                                                                     utils.py:65
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-08-yield-main/contracts/oracles/compound/CTokenMultiOracle.sol!!!CTokenMultiOracle!!!_get!!!/home/owen/Documents/GitHub/GPTScan-Bigger-            
                             Model/eval_data/2021-08-yield-main/contracts/oracles/composite/CompositeMultiOracle.sol!!!CompositeMultiOracle!!!get!!!price-manipulation                                                                          
                    INFO     utils: Remove the redundant result:                                                                                                                                                                     utils.py:65
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/eval_data/2021-08-yield-main/contracts/oracles/compound/CTokenMultiOracle.sol!!!CTokenMultiOracle!!!_get!!!/home/owen/Documents/GitHub/GPTScan-Bigger-            
                             Model/eval_data/2021-08-yield-main/contracts/oracles/compound/CTokenMultiOracle.sol!!!CTokenMultiOracle!!!get!!!price-manipulation                                                                                 
