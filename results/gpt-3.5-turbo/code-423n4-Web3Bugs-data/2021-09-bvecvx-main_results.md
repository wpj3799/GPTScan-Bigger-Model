

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[19:05:31] Loaded 10 rules                                                                                                                                                                             tasks.py:119
[12/08/24 19:05:31] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main)               subprocess.py:41
[12/08/24 19:05:32] INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main)      subprocess.py:41
[12/08/24 19:05:34] INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main)     subprocess.py:41
[19:05:35] Traceback (most recent call last):                                                                                                                                                          tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                     
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                    
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                    
               self._compile(**kwargs)                                                                                                                                                                             
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                    
               self._platform.compile(self, **kwargs)                                                                                                                                                              
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 183, in compile                                                   
               hardhat_like_parsing(crytic_compile, self._target, build_directory, hardhat_working_dir)                                                                                                            
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 52, in hardhat_like_parsing                                       
               raise InvalidCompilation(txt)                                                                                                                                                                       
           crytic_compile.platform.exceptions.InvalidCompilation: Compilation failed. Can you run build command?                                                                                                   
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/artifacts/build-info is not a directory.                                                         
                                                                                                                                                                                                                   
           During handling of the above exception, another exception occurred:                                                                                                                                     
                                                                                                                                                                                                                   
           Traceback (most recent call last):                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                         
               falcon_instance = compile_project(source_dir)                                                                                                                                                       
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                    
               return falcon.Falcon(abs_path)                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                     
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                               
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                     
           Compilation failed. Can you run build command?                                                                                                                                                          
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/artifacts/build-info is not a directory.                                                         
                                                                                                                                                                                                                   
           Compile failed.                                                                                                                                                                             tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                  tasks.py:128
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function __BaseStrategy_init(                                                                                                                                                                               │
│         address _governance,                                                                                                                                                                                    │
│         address _strategist,                                                                                                                                                                                    │
│         address _controller,                                                                                                                                                                                    │
│         address _keeper,                                                                                                                                                                                        │
│         address _guardian                                                                                                                                                                                       │
│     ) public initializer whenNotPaused {                                                                                                                                                                        │
│         __Pausable_init();                                                                                                                                                                                      │
│         governance = _governance;                                                                                                                                                                               │
│         strategist = _strategist;                                                                                                                                                                               │
│         keeper = _keeper;                                                                                                                                                                                       │
│         controller = _controller;                                                                                                                                                                               │
│         guardian = _guardian;                                                                                                                                                                                   │
│         withdrawalMaxDeviationThreshold = 50;                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setWithdrawalFee(uint256 _withdrawalFee) external {                                                                                                                                                │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(                                                                                                                                                                                                │
│             _withdrawalFee <= MAX_FEE,                                                                                                                                                                          │
│             "base-strategy/excessive-withdrawal-fee"                                                                                                                                                            │
│         );                                                                                                                                                                                                      │
│         withdrawalFee = _withdrawalFee;                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist)                                                                                                                                     │
│         external                                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(                                                                                                                                                                                                │
│             _performanceFeeStrategist <= MAX_FEE,                                                                                                                                                               │
│             "base-strategy/excessive-strategist-performance-fee"                                                                                                                                                │
│         );                                                                                                                                                                                                      │
│         performanceFeeStrategist = _performanceFeeStrategist;                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance)                                                                                                                                     │
│         external                                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(                                                                                                                                                                                                │
│             _performanceFeeGovernance <= MAX_FEE,                                                                                                                                                               │
│             "base-strategy/excessive-governance-performance-fee"                                                                                                                                                │
│         );                                                                                                                                                                                                      │
│         performanceFeeGovernance = _performanceFeeGovernance;                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setWithdrawalMaxDeviationThreshold(uint256 _threshold) external {                                                                                                                                  │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(                                                                                                                                                                                                │
│             _threshold <= MAX_FEE,                                                                                                                                                                              │
│             "base-strategy/excessive-max-deviation-threshold"                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         withdrawalMaxDeviationThreshold = _threshold;                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function earn(address _token, uint256 _amount) public {                                                                                                                                                     │
│         address _strategy = strategies[_token];                                                                                                                                                                 │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _onlyApprovedForWant(_want);                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (_want != _token) {                                                                                                                                                                                  │
│             address converter = converters[_token][_want];                                                                                                                                                      │
│             IERC20Upgradeable(_token).safeTransfer(converter, _amount);                                                                                                                                         │
│             _amount = IConverter(converter).convert(_strategy);                                                                                                                                                 │
│             IERC20Upgradeable(_want).safeTransfer(_strategy, _amount);                                                                                                                                          │
│         } else {                                                                                                                                                                                                │
│             IERC20Upgradeable(_token).safeTransfer(_strategy, _amount);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         IStrategy(_strategy).deposit();                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distribute() external {                                                                                                                                                                            │
│         //claim rewards                                                                                                                                                                                         │
│         IConvexRewards(cvxStaking).getReward(false);                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         //convert any crv that was directly added                                                                                                                                                               │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             ICrvDepositor(crvDeposit).deposit(crvBal, true);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //distribute cvxcrv                                                                                                                                                                                     │
│         uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBal > 0) {                                                                                                                                                                                    │
│             uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);                                                                                                                            │
│             cvxCrvBal = cvxCrvBal.sub(incentiveAmount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             IERC20(cvxCrv).safeTransfer(msg.sender,incentiveAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             ICvxLocker(rewards).notifyRewardAmount(cvxCrv, cvxCrvBal);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(cvxCrv, cvxCrvBal);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll()                                                                                                                                                                                      │
│         external                                                                                                                                                                                                │
│         virtual                                                                                                                                                                                                 │
│         whenNotPaused                                                                                                                                                                                           │
│         returns (uint256 balance)                                                                                                                                                                               │
│     {                                                                                                                                                                                                           │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _withdrawAll();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _transferToVault(IERC20Upgradeable(want).balanceOf(address(this)));                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function setStrategy(address _token, address _strategy) public {                                                                                                                                            │
│         _onlyGovernanceOrStrategist();                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         require(approvedStrategies[_token][_strategy] == true, "!approved");                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         address _current = strategies[_token];                                                                                                                                                                  │
│         if (_current != address(0)) {                                                                                                                                                                           │
│             IStrategy(_current).withdrawAll();                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         strategies[_token] = _strategy;                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function withdrawAll()                                                                                                                                                                                      │
│         external                                                                                                                                                                                                │
│         virtual                                                                                                                                                                                                 │
│         whenNotPaused                                                                                                                                                                                           │
│         returns (uint256 balance)                                                                                                                                                                               │
│     {                                                                                                                                                                                                           │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _withdrawAll();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _transferToVault(IERC20Upgradeable(want).balanceOf(address(this)));                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(                                                                                                                                                                                            │
│                 diff <=                                                                                                                                                                                         │
│                     _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE),                                                                                                                                  │
│                 "base-strategy/withdraw-exceed-max-deviation-threshold"                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function updateStakeRatio(uint256 _offset) internal {                                                                                                                                                       │
│         if (isShutdown) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //get balances                                                                                                                                                                                          │
│         uint256 local = stakingToken.balanceOf(address(this));                                                                                                                                                  │
│         uint256 staked = IStakingProxy(stakingProxy).getBalance();                                                                                                                                              │
│         uint256 total = local.add(staked);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (total == 0) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //current staked ratio                                                                                                                                                                                  │
│         uint256 ratio = staked.mul(denominator).div(total);                                                                                                                                                     │
│         //mean will be where we reset to if unbalanced                                                                                                                                                          │
│         uint256 mean = maximumStake.add(minimumStake).div(2);                                                                                                                                                   │
│         uint256 max = maximumStake.add(_offset);                                                                                                                                                                │
│         uint256 min = Math.min(minimumStake, minimumStake - _offset);                                                                                                                                           │
│         if (ratio > max) {                                                                                                                                                                                      │
│             //remove                                                                                                                                                                                            │
│             uint256 remove = staked.sub(total.mul(mean).div(denominator));                                                                                                                                      │
│             IStakingProxy(stakingProxy).withdraw(remove);                                                                                                                                                       │
│         } else if (ratio < min) {                                                                                                                                                                               │
│             //add                                                                                                                                                                                               │
│             uint256 increase = total.mul(mean).div(denominator).sub(staked);                                                                                                                                    │
│             stakingToken.safeTransfer(stakingProxy, increase);                                                                                                                                                  │
│             IStakingProxy(stakingProxy).stake();                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(                                                                                                                                                                                            │
│                 diff <=                                                                                                                                                                                         │
│                     _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE),                                                                                                                                  │
│                 "base-strategy/withdraw-exceed-max-deviation-threshold"                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _shares) internal virtual {                                                                                                                                                      │
│         uint256 r = (balance().mul(_shares)).div(totalSupply());                                                                                                                                                │
│         _burn(msg.sender, _shares);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Check balance                                                                                                                                                                                        │
│         uint256 b = token.balanceOf(address(this));                                                                                                                                                             │
│         if (b < r) {                                                                                                                                                                                            │
│             uint256 _toWithdraw = r.sub(b);                                                                                                                                                                     │
│             IController(controller).withdraw(address(token), _toWithdraw);                                                                                                                                      │
│             uint256 _after = token.balanceOf(address(this));                                                                                                                                                    │
│             uint256 _diff = _after.sub(b);                                                                                                                                                                      │
│             if (_diff < _toWithdraw) {                                                                                                                                                                          │
│                 r = b.add(_diff);                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         token.safeTransfer(msg.sender, r);                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(                                                                                                                                                                                            │
│                 diff <=                                                                                                                                                                                         │
│                     _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE),                                                                                                                                  │
│                 "base-strategy/withdraw-exceed-max-deviation-threshold"                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _shares) internal virtual {                                                                                                                                                      │
│         uint256 r = (balance().mul(_shares)).div(totalSupply());                                                                                                                                                │
│         _burn(msg.sender, _shares);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Check balance                                                                                                                                                                                        │
│         uint256 b = token.balanceOf(address(this));                                                                                                                                                             │
│         if (b < r) {                                                                                                                                                                                            │
│             uint256 _toWithdraw = r.sub(b);                                                                                                                                                                     │
│             IController(controller).withdraw(address(token), _toWithdraw);                                                                                                                                      │
│             uint256 _after = token.balanceOf(address(this));                                                                                                                                                    │
│             uint256 _diff = _after.sub(b);                                                                                                                                                                      │
│             if (_diff < _toWithdraw) {                                                                                                                                                                          │
│                 r = b.add(_diff);                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         token.safeTransfer(msg.sender, r);                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(                                                                                                                                                                                            │
│                 diff <=                                                                                                                                                                                         │
│                     _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE),                                                                                                                                  │
│                 "base-strategy/withdraw-exceed-max-deviation-threshold"                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external {                                                                                                                                                               │
│         require(msg.sender == rewards, "!auth");                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //unstake                                                                                                                                                                                               │
│         IConvexRewards(cvxStaking).withdraw(_amount, false);                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //withdraw cvx                                                                                                                                                                                          │
│         IERC20(cvx).safeTransfer(msg.sender, _amount);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(                                                                                                                                                                                            │
│                 diff <=                                                                                                                                                                                         │
│                     _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE),                                                                                                                                  │
│                 "base-strategy/withdraw-exceed-max-deviation-threshold"                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawOther(address _asset)                                                                                                                                                                      │
│         external                                                                                                                                                                                                │
│         virtual                                                                                                                                                                                                 │
│         whenNotPaused                                                                                                                                                                                           │
│         returns (uint256 balance)                                                                                                                                                                               │
│     {                                                                                                                                                                                                           │
│         _onlyController();                                                                                                                                                                                      │
│         _onlyNotProtectedTokens(_asset);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         balance = IERC20Upgradeable(_asset).balanceOf(address(this));                                                                                                                                           │
│         IERC20Upgradeable(_asset).safeTransfer(controller, balance);                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _add_max_liquidity_uniswap(address token0, address token1)                                                                                                                                         │
│         internal                                                                                                                                                                                                │
│         virtual                                                                                                                                                                                                 │
│     {                                                                                                                                                                                                           │
│         uint256 _token0Balance =                                                                                                                                                                                │
│             IERC20Upgradeable(token0).balanceOf(address(this));                                                                                                                                                 │
│         uint256 _token1Balance =                                                                                                                                                                                │
│             IERC20Upgradeable(token1).balanceOf(address(this));                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         _safeApproveHelper(token0, uniswap, _token0Balance);                                                                                                                                                    │
│         _safeApproveHelper(token1, uniswap, _token1Balance);                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         IUniswapRouterV2(uniswap).addLiquidity(                                                                                                                                                                 │
│             token0,                                                                                                                                                                                             │
│             token1,                                                                                                                                                                                             │
│             _token0Balance,                                                                                                                                                                                     │
│             _token1Balance,                                                                                                                                                                                     │
│             0,                                                                                                                                                                                                  │
│             0,                                                                                                                                                                                                  │
│             address(this),                                                                                                                                                                                      │
│             block.timestamp                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function initialize(                                                                                                                                                                                        │
│         address _governance,                                                                                                                                                                                    │
│         address _strategist,                                                                                                                                                                                    │
│         address _controller,                                                                                                                                                                                    │
│         address _keeper,                                                                                                                                                                                        │
│         address _guardian,                                                                                                                                                                                      │
│         address[3] memory _wantConfig,                                                                                                                                                                          │
│         uint256[3] memory _feeConfig,                                                                                                                                                                           │
│         address _locker ///@dev TODO: Add this to deploy                                                                                                                                                        │
│     ) public initializer {                                                                                                                                                                                      │
│         __BaseStrategy_init(                                                                                                                                                                                    │
│             _governance,                                                                                                                                                                                        │
│             _strategist,                                                                                                                                                                                        │
│             _controller,                                                                                                                                                                                        │
│             _keeper,                                                                                                                                                                                            │
│             _guardian                                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         /// @dev Add config here                                                                                                                                                                                │
│         want = _wantConfig[0];                                                                                                                                                                                  │
│         lpComponent = _wantConfig[1];                                                                                                                                                                           │
│         reward = _wantConfig[2];                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         performanceFeeGovernance = _feeConfig[0];                                                                                                                                                               │
│         performanceFeeStrategist = _feeConfig[1];                                                                                                                                                               │
│         withdrawalFee = _feeConfig[2];                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         LOCKER = ICvxLocker(_locker); //TODO: Make locker hardcoded at top of file                                                                                                                              │
│                                                                                                                                                                                                                 │
│         /// @dev do one off approvals here                                                                                                                                                                      │
│         // IERC20Upgradeable(want).safeApprove(gauge, type(uint256).max);                                                                                                                                       │
│         // Permissions for Locker                                                                                                                                                                               │
│         IERC20Upgradeable(CVX).safeApprove(_locker, type(uint256).max);                                                                                                                                         │
│         IERC20Upgradeable(CVX).safeApprove(                                                                                                                                                                     │
│             address(CVX_VAULT),                                                                                                                                                                                 │
│             type(uint256).max                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Permissions for Sushiswap                                                                                                                                                                            │
│         IERC20Upgradeable(reward).safeApprove(SUSHI_ROUTER, type(uint256).max);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Delegate voting to DELEGATE                                                                                                                                                                          │
│         SNAPSHOT.setDelegate(DELEGATED_SPACE, DELEGATE);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function balanceOfPool() public view override returns (uint256) {                                                                                                                                           │
│         if (withdrawalSafetyCheck) {                                                                                                                                                                            │
│             uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals                                                                                                                                │
│             require(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the balance in locker + unlocked but not withdrawn, better estimate to allow some withdrawals                                                                                                 │
│         // then multiply it by the price per share as we need to convert CVX to bCVX                                                                                                                            │
│         uint256 valueInLocker =                                                                                                                                                                                 │
│             CVXToWant(LOCKER.lockedBalanceOf(address(this))).add(                                                                                                                                               │
│                 CVXToWant(IERC20Upgradeable(CVX).balanceOf(address(this)))                                                                                                                                      │
│             );                                                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         return (valueInLocker);                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function balanceOfPool() public view override returns (uint256) {                                                                                                                                           │
│         if (withdrawalSafetyCheck) {                                                                                                                                                                            │
│             uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals                                                                                                                                │
│             require(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the balance in locker + unlocked but not withdrawn, better estimate to allow some withdrawals                                                                                                 │
│         // then multiply it by the price per share as we need to convert CVX to bCVX                                                                                                                            │
│         uint256 valueInLocker =                                                                                                                                                                                 │
│             CVXToWant(LOCKER.lockedBalanceOf(address(this))).add(                                                                                                                                               │
│                 CVXToWant(IERC20Upgradeable(CVX).balanceOf(address(this)))                                                                                                                                      │
│             );                                                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         return (valueInLocker);                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal override {                                                                                                                                                      │
│         // We receive bCVX -> Convert to bCVX                                                                                                                                                                   │
│         CVX_VAULT.withdraw(_amount);                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Lock tokens for 17 weeks, send credit to strat, always use max boost cause why not?                                                                                                                  │
│         LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal override {                                                                                                                                                      │
│         // We receive bCVX -> Convert to bCVX                                                                                                                                                                   │
│         CVX_VAULT.withdraw(_amount);                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Lock tokens for 17 weeks, send credit to strat, always use max boost cause why not?                                                                                                                  │
│         LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal override {                                                                                                                                                      │
│         // We receive bCVX -> Convert to bCVX                                                                                                                                                                   │
│         CVX_VAULT.withdraw(_amount);                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Lock tokens for 17 weeks, send credit to strat, always use max boost cause why not?                                                                                                                  │
│         LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function prepareWithdrawAll() external {                                                                                                                                                                    │
│         _onlyGovernance();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         LOCKER.processExpiredLocks(false);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                    │
│         if (toDeposit > 0) {                                                                                                                                                                                    │
│             CVX_VAULT.deposit(toDeposit);                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawSome(uint256 _amount)                                                                                                                                                                     │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 max = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (withdrawalSafetyCheck) {                                                                                                                                                                            │
│             uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals                                                                                                                                │
│             require(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg                                                                                                        │
│             require(                                                                                                                                                                                            │
│                 max >= _amount.mul(9_980).div(MAX_BPS),                                                                                                                                                         │
│                 "Withdrawal Safety Check"                                                                                                                                                                       │
│             ); // 20 BP of slippage                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (max < _amount) {                                                                                                                                                                                    │
│             return max;                                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return _amount;                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawSome(uint256 _amount)                                                                                                                                                                     │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 max = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (withdrawalSafetyCheck) {                                                                                                                                                                            │
│             uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals                                                                                                                                │
│             require(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg                                                                                                        │
│             require(                                                                                                                                                                                            │
│                 max >= _amount.mul(9_980).div(MAX_BPS),                                                                                                                                                         │
│                 "Withdrawal Safety Check"                                                                                                                                                                       │
│             ); // 20 BP of slippage                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (max < _amount) {                                                                                                                                                                                    │
│             return max;                                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return _amount;                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), "base-strategy/withdraw-exceed-max-deviation-threshold");                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _withdrawSome(uint256 _amount)                                                                                                                                                                     │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 max = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (withdrawalSafetyCheck) {                                                                                                                                                                            │
│             uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals                                                                                                                                │
│             require(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg                                                                                                        │
│             require(                                                                                                                                                                                            │
│                 max >= _amount.mul(9_980).div(MAX_BPS),                                                                                                                                                         │
│                 "Withdrawal Safety Check"                                                                                                                                                                       │
│             ); // 20 BP of slippage                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (max < _amount) {                                                                                                                                                                                    │
│             return max;                                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return _amount;                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), "base-strategy/withdraw-exceed-max-deviation-threshold");                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _withdrawSome(uint256 _amount)                                                                                                                                                                     │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 max = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (withdrawalSafetyCheck) {                                                                                                                                                                            │
│             uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals                                                                                                                                │
│             require(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg                                                                                                        │
│             require(                                                                                                                                                                                            │
│                 max >= _amount.mul(9_980).div(MAX_BPS),                                                                                                                                                         │
│                 "Withdrawal Safety Check"                                                                                                                                                                       │
│             ); // 20 BP of slippage                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (max < _amount) {                                                                                                                                                                                    │
│             return max;                                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return _amount;                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(                                                                                                                                                                                            │
│                 diff <=                                                                                                                                                                                         │
│                     _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE),                                                                                                                                  │
│                 "base-strategy/withdraw-exceed-max-deviation-threshold"                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _withdrawSome(uint256 _amount)                                                                                                                                                                     │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 max = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (withdrawalSafetyCheck) {                                                                                                                                                                            │
│             uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals                                                                                                                                │
│             require(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg                                                                                                        │
│             require(                                                                                                                                                                                            │
│                 max >= _amount.mul(9_980).div(MAX_BPS),                                                                                                                                                         │
│                 "Withdrawal Safety Check"                                                                                                                                                                       │
│             ); // 20 BP of slippage                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (max < _amount) {                                                                                                                                                                                    │
│             return max;                                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return _amount;                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function harvest() public whenNotPaused returns (uint256 harvested) {                                                                                                                                       │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Get cvxCRV                                                                                                                                                                                           │
│         LOCKER.getReward(address(this), false);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Rewards Math                                                                                                                                                                                         │
│         uint256 earnedReward =                                                                                                                                                                                  │
│             IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Because we are using bCVX we take fees in reward                                                                                                                                                     │
│         //NOTE: This will probably revert because we deposit and transfer on same block                                                                                                                         │
│         (uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =                                                                                                                                  │
│             _processRewardsFees(earnedReward, reward);                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // Swap cvxCRV for want (bCVX)                                                                                                                                                                          │
│         _swapcvxCRVToWant();                                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         uint256 earned =                                                                                                                                                                                        │
│             IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         /// @dev Harvest event that every strategy MUST have, see BaseStrategy                                                                                                                                  │
│         emit Harvest(earned, block.number);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         /// @dev Harvest must return the amount of want increased                                                                                                                                               │
│         return earned;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function manualRebalance(uint256 toLock) external whenNotPaused {                                                                                                                                           │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(toLock <= MAX_BPS, "Max is 100%");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (processLocksOnRebalance) {                                                                                                                                                                          │
│             // manualRebalance will revert if you have no expired locks                                                                                                                                         │
│             LOCKER.processExpiredLocks(false);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (harvestOnRebalance) {                                                                                                                                                                               │
│             harvest();                                                                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Token that is highly liquid                                                                                                                                                                          │
│         uint256 balanceOfWant =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│         // CVX uninvested we got from harvest and unlocks                                                                                                                                                       │
│         uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                 │
│         // Locked CVX in the locker                                                                                                                                                                             │
│         uint256 balanceInLock = LOCKER.balanceOf(address(this));                                                                                                                                                │
│         uint256 totalCVXBalance =                                                                                                                                                                               │
│             balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //Ratios                                                                                                                                                                                                │
│         uint256 currentLockRatio =                                                                                                                                                                              │
│             balanceInLock.mul(10**18).div(totalCVXBalance);                                                                                                                                                     │
│         // Amount we want to have in lock                                                                                                                                                                       │
│         uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);                                                                                                                                        │
│         // Amount we want to have in bCVX                                                                                                                                                                       │
│         uint256 toWantRatio =                                                                                                                                                                                   │
│             totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // We can't unlock enough, just deposit rest into bCVX                                                                                                                                                  │
│         if (newLockRatio <= currentLockRatio) {                                                                                                                                                                 │
│             // Deposit into vault                                                                                                                                                                               │
│             uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                │
│             if (toDeposit > 0) {                                                                                                                                                                                │
│                 CVX_VAULT.deposit(toDeposit);                                                                                                                                                                   │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If we're continuing, then we are going to lock something (unless it's zero)                                                                                                                          │
│         uint256 cvxToLock = newLockRatio.sub(currentLockRatio);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // NOTE: We only lock the CVX we have and not the bCVX                                                                                                                                                  │
│         // bCVX should be sent back to vault and then go through earn                                                                                                                                           │
│         // We do this because bCVX has "blockLock" and we can't both deposit and withdraw on the same block                                                                                                     │
│         uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                       │
│         if (cvxToLock > maxCVX) {                                                                                                                                                                               │
│             // Just lock what we can                                                                                                                                                                            │
│             LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             // Lock proper                                                                                                                                                                                      │
│             LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If anything else is left, deposit into vault                                                                                                                                                         │
│         uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                      │
│         if (cvxLeft > 0) {                                                                                                                                                                                      │
│             CVX_VAULT.deposit(cvxLeft);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat                                                                                            │
│     }                                                                                                                                                                                                           │
│     function harvest() public whenNotPaused returns (uint256 harvested) {                                                                                                                                       │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Get cvxCRV                                                                                                                                                                                           │
│         LOCKER.getReward(address(this), false);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Rewards Math                                                                                                                                                                                         │
│         uint256 earnedReward =                                                                                                                                                                                  │
│             IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Because we are using bCVX we take fees in reward                                                                                                                                                     │
│         //NOTE: This will probably revert because we deposit and transfer on same block                                                                                                                         │
│         (uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =                                                                                                                                  │
│             _processRewardsFees(earnedReward, reward);                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // Swap cvxCRV for want (bCVX)                                                                                                                                                                          │
│         _swapcvxCRVToWant();                                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         uint256 earned =                                                                                                                                                                                        │
│             IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         /// @dev Harvest event that every strategy MUST have, see BaseStrategy                                                                                                                                  │
│         emit Harvest(earned, block.number);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         /// @dev Harvest must return the amount of want increased                                                                                                                                               │
│         return earned;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function manualRebalance(uint256 toLock) external whenNotPaused {                                                                                                                                           │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(toLock <= MAX_BPS, "Max is 100%");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (processLocksOnRebalance) {                                                                                                                                                                          │
│             // manualRebalance will revert if you have no expired locks                                                                                                                                         │
│             LOCKER.processExpiredLocks(false);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (harvestOnRebalance) {                                                                                                                                                                               │
│             harvest();                                                                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Token that is highly liquid                                                                                                                                                                          │
│         uint256 balanceOfWant =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│         // CVX uninvested we got from harvest and unlocks                                                                                                                                                       │
│         uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                 │
│         // Locked CVX in the locker                                                                                                                                                                             │
│         uint256 balanceInLock = LOCKER.balanceOf(address(this));                                                                                                                                                │
│         uint256 totalCVXBalance =                                                                                                                                                                               │
│             balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //Ratios                                                                                                                                                                                                │
│         uint256 currentLockRatio =                                                                                                                                                                              │
│             balanceInLock.mul(10**18).div(totalCVXBalance);                                                                                                                                                     │
│         // Amount we want to have in lock                                                                                                                                                                       │
│         uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);                                                                                                                                        │
│         // Amount we want to have in bCVX                                                                                                                                                                       │
│         uint256 toWantRatio =                                                                                                                                                                                   │
│             totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // We can't unlock enough, just deposit rest into bCVX                                                                                                                                                  │
│         if (newLockRatio <= currentLockRatio) {                                                                                                                                                                 │
│             // Deposit into vault                                                                                                                                                                               │
│             uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                │
│             if (toDeposit > 0) {                                                                                                                                                                                │
│                 CVX_VAULT.deposit(toDeposit);                                                                                                                                                                   │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If we're continuing, then we are going to lock something (unless it's zero)                                                                                                                          │
│         uint256 cvxToLock = newLockRatio.sub(currentLockRatio);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // NOTE: We only lock the CVX we have and not the bCVX                                                                                                                                                  │
│         // bCVX should be sent back to vault and then go through earn                                                                                                                                           │
│         // We do this because bCVX has "blockLock" and we can't both deposit and withdraw on the same block                                                                                                     │
│         uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                       │
│         if (cvxToLock > maxCVX) {                                                                                                                                                                               │
│             // Just lock what we can                                                                                                                                                                            │
│             LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             // Lock proper                                                                                                                                                                                      │
│             LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If anything else is left, deposit into vault                                                                                                                                                         │
│         uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                      │
│         if (cvxLeft > 0) {                                                                                                                                                                                      │
│             CVX_VAULT.deposit(cvxLeft);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat                                                                                            │
│     }                                                                                                                                                                                                           │
│     function harvest() public whenNotPaused returns (uint256 harvested) {                                                                                                                                       │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Get cvxCRV                                                                                                                                                                                           │
│         LOCKER.getReward(address(this), false);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Rewards Math                                                                                                                                                                                         │
│         uint256 earnedReward =                                                                                                                                                                                  │
│             IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Because we are using bCVX we take fees in reward                                                                                                                                                     │
│         //NOTE: This will probably revert because we deposit and transfer on same block                                                                                                                         │
│         (uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =                                                                                                                                  │
│             _processRewardsFees(earnedReward, reward);                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // Swap cvxCRV for want (bCVX)                                                                                                                                                                          │
│         _swapcvxCRVToWant();                                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         uint256 earned =                                                                                                                                                                                        │
│             IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         /// @dev Harvest event that every strategy MUST have, see BaseStrategy                                                                                                                                  │
│         emit Harvest(earned, block.number);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         /// @dev Harvest must return the amount of want increased                                                                                                                                               │
│         return earned;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _swapcvxCRVToWant() internal {                                                                                                                                                                     │
│         uint256 toSwap = IERC20Upgradeable(reward).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         if (toSwap == 0) {                                                                                                                                                                                      │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Sushi reward to WETH to want                                                                                                                                                                         │
│         address[] memory path = new address[](3);                                                                                                                                                               │
│         path[0] = reward;                                                                                                                                                                                       │
│         path[1] = WETH;                                                                                                                                                                                         │
│         path[2] = CVX;                                                                                                                                                                                          │
│         IUniswapRouterV2(SUSHI_ROUTER).swapExactTokensForTokens(                                                                                                                                                │
│             toSwap,                                                                                                                                                                                             │
│             0,                                                                                                                                                                                                  │
│             path,                                                                                                                                                                                               │
│             address(this),                                                                                                                                                                                      │
│             now                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Deposit into vault                                                                                                                                                                                   │
│         uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                    │
│         if (toDeposit > 0) {                                                                                                                                                                                    │
│             CVX_VAULT.deposit(toDeposit);                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function harvest() public whenNotPaused returns (uint256 harvested) {                                                                                                                                       │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Get cvxCRV                                                                                                                                                                                           │
│         LOCKER.getReward(address(this), false);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Rewards Math                                                                                                                                                                                         │
│         uint256 earnedReward =                                                                                                                                                                                  │
│             IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Because we are using bCVX we take fees in reward                                                                                                                                                     │
│         //NOTE: This will probably revert because we deposit and transfer on same block                                                                                                                         │
│         (uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =                                                                                                                                  │
│             _processRewardsFees(earnedReward, reward);                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // Swap cvxCRV for want (bCVX)                                                                                                                                                                          │
│         _swapcvxCRVToWant();                                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         uint256 earned =                                                                                                                                                                                        │
│             IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         /// @dev Harvest event that every strategy MUST have, see BaseStrategy                                                                                                                                  │
│         emit Harvest(earned, block.number);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         /// @dev Harvest must return the amount of want increased                                                                                                                                               │
│         return earned;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function _swapcvxCRVToWant() internal {                                                                                                                                                                     │
│         uint256 toSwap = IERC20Upgradeable(reward).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         if (toSwap == 0) {                                                                                                                                                                                      │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Sushi reward to WETH to want                                                                                                                                                                         │
│         address[] memory path = new address[](3);                                                                                                                                                               │
│         path[0] = reward;                                                                                                                                                                                       │
│         path[1] = WETH;                                                                                                                                                                                         │
│         path[2] = CVX;                                                                                                                                                                                          │
│         IUniswapRouterV2(SUSHI_ROUTER).swapExactTokensForTokens(                                                                                                                                                │
│             toSwap,                                                                                                                                                                                             │
│             0,                                                                                                                                                                                                  │
│             path,                                                                                                                                                                                               │
│             address(this),                                                                                                                                                                                      │
│             now                                                                                                                                                                                                 │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Deposit into vault                                                                                                                                                                                   │
│         uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                    │
│         if (toDeposit > 0) {                                                                                                                                                                                    │
│             CVX_VAULT.deposit(toDeposit);                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _processRewardsFees(uint256 _amount, address _token)                                                                                                                                               │
│         internal                                                                                                                                                                                                │
│         returns (uint256 governanceRewardsFee, uint256 strategistRewardsFee)                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         governanceRewardsFee = _processFee(                                                                                                                                                                     │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeGovernance,                                                                                                                                                                           │
│             IController(controller).rewards()                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         strategistRewardsFee = _processFee(                                                                                                                                                                     │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeStrategist,                                                                                                                                                                           │
│             strategist                                                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function _processRewardsFees(uint256 _amount, address _token)                                                                                                                                               │
│         internal                                                                                                                                                                                                │
│         returns (uint256 governanceRewardsFee, uint256 strategistRewardsFee)                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         governanceRewardsFee = _processFee(                                                                                                                                                                     │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeGovernance,                                                                                                                                                                           │
│             IController(controller).rewards()                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         strategistRewardsFee = _processFee(                                                                                                                                                                     │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeStrategist,                                                                                                                                                                           │
│             strategist                                                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function reinvest() external whenNotPaused returns (uint256 reinvested) {                                                                                                                                   │
│         _onlyGovernance();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (processLocksOnReinvest) {                                                                                                                                                                           │
│             // Withdraw all we can                                                                                                                                                                              │
│             LOCKER.processExpiredLocks(false);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Redeposit all into veCVX                                                                                                                                                                             │
│         uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Redeposit into veCVX                                                                                                                                                                                 │
│         LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function manualDepositCVXIntoVault() external whenNotPaused {                                                                                                                                               │
│         _onlyGovernance();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                    │
│         if (toDeposit > 0) {                                                                                                                                                                                    │
│             CVX_VAULT.deposit(toDeposit);                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function manualSendbCVXToVault() external whenNotPaused {                                                                                                                                                   │
│         _onlyGovernance();                                                                                                                                                                                      │
│         uint256 bCvxAmount = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                  │
│         _transferToVault(bCvxAmount);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function manualRebalance(uint256 toLock) external whenNotPaused {                                                                                                                                           │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(toLock <= MAX_BPS, "Max is 100%");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (processLocksOnRebalance) {                                                                                                                                                                          │
│             // manualRebalance will revert if you have no expired locks                                                                                                                                         │
│             LOCKER.processExpiredLocks(false);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (harvestOnRebalance) {                                                                                                                                                                               │
│             harvest();                                                                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Token that is highly liquid                                                                                                                                                                          │
│         uint256 balanceOfWant =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│         // CVX uninvested we got from harvest and unlocks                                                                                                                                                       │
│         uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                 │
│         // Locked CVX in the locker                                                                                                                                                                             │
│         uint256 balanceInLock = LOCKER.balanceOf(address(this));                                                                                                                                                │
│         uint256 totalCVXBalance =                                                                                                                                                                               │
│             balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //Ratios                                                                                                                                                                                                │
│         uint256 currentLockRatio =                                                                                                                                                                              │
│             balanceInLock.mul(10**18).div(totalCVXBalance);                                                                                                                                                     │
│         // Amount we want to have in lock                                                                                                                                                                       │
│         uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);                                                                                                                                        │
│         // Amount we want to have in bCVX                                                                                                                                                                       │
│         uint256 toWantRatio =                                                                                                                                                                                   │
│             totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // We can't unlock enough, just deposit rest into bCVX                                                                                                                                                  │
│         if (newLockRatio <= currentLockRatio) {                                                                                                                                                                 │
│             // Deposit into vault                                                                                                                                                                               │
│             uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                │
│             if (toDeposit > 0) {                                                                                                                                                                                │
│                 CVX_VAULT.deposit(toDeposit);                                                                                                                                                                   │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If we're continuing, then we are going to lock something (unless it's zero)                                                                                                                          │
│         uint256 cvxToLock = newLockRatio.sub(currentLockRatio);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // NOTE: We only lock the CVX we have and not the bCVX                                                                                                                                                  │
│         // bCVX should be sent back to vault and then go through earn                                                                                                                                           │
│         // We do this because bCVX has "blockLock" and we can't both deposit and withdraw on the same block                                                                                                     │
│         uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                       │
│         if (cvxToLock > maxCVX) {                                                                                                                                                                               │
│             // Just lock what we can                                                                                                                                                                            │
│             LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             // Lock proper                                                                                                                                                                                      │
│             LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If anything else is left, deposit into vault                                                                                                                                                         │
│         uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                      │
│         if (cvxLeft > 0) {                                                                                                                                                                                      │
│             CVX_VAULT.deposit(cvxLeft);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function manualRebalance(uint256 toLock) external whenNotPaused {                                                                                                                                           │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(toLock <= MAX_BPS, "Max is 100%");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (processLocksOnRebalance) {                                                                                                                                                                          │
│             // manualRebalance will revert if you have no expired locks                                                                                                                                         │
│             LOCKER.processExpiredLocks(false);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (harvestOnRebalance) {                                                                                                                                                                               │
│             harvest();                                                                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Token that is highly liquid                                                                                                                                                                          │
│         uint256 balanceOfWant =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│         // CVX uninvested we got from harvest and unlocks                                                                                                                                                       │
│         uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                 │
│         // Locked CVX in the locker                                                                                                                                                                             │
│         uint256 balanceInLock = LOCKER.balanceOf(address(this));                                                                                                                                                │
│         uint256 totalCVXBalance =                                                                                                                                                                               │
│             balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //Ratios                                                                                                                                                                                                │
│         uint256 currentLockRatio =                                                                                                                                                                              │
│             balanceInLock.mul(10**18).div(totalCVXBalance);                                                                                                                                                     │
│         // Amount we want to have in lock                                                                                                                                                                       │
│         uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);                                                                                                                                        │
│         // Amount we want to have in bCVX                                                                                                                                                                       │
│         uint256 toWantRatio =                                                                                                                                                                                   │
│             totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // We can't unlock enough, just deposit rest into bCVX                                                                                                                                                  │
│         if (newLockRatio <= currentLockRatio) {                                                                                                                                                                 │
│             // Deposit into vault                                                                                                                                                                               │
│             uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                │
│             if (toDeposit > 0) {                                                                                                                                                                                │
│                 CVX_VAULT.deposit(toDeposit);                                                                                                                                                                   │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If we're continuing, then we are going to lock something (unless it's zero)                                                                                                                          │
│         uint256 cvxToLock = newLockRatio.sub(currentLockRatio);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // NOTE: We only lock the CVX we have and not the bCVX                                                                                                                                                  │
│         // bCVX should be sent back to vault and then go through earn                                                                                                                                           │
│         // We do this because bCVX has "blockLock" and we can't both deposit and withdraw on the same block                                                                                                     │
│         uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                       │
│         if (cvxToLock > maxCVX) {                                                                                                                                                                               │
│             // Just lock what we can                                                                                                                                                                            │
│             LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             // Lock proper                                                                                                                                                                                      │
│             LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If anything else is left, deposit into vault                                                                                                                                                         │
│         uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                      │
│         if (cvxLeft > 0) {                                                                                                                                                                                      │
│             CVX_VAULT.deposit(cvxLeft);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function initialize(                                                                                                                                                                                        │
│         address _governance,                                                                                                                                                                                    │
│         address _strategist,                                                                                                                                                                                    │
│         address _keeper,                                                                                                                                                                                        │
│         address _rewards                                                                                                                                                                                        │
│     ) public initializer {                                                                                                                                                                                      │
│         governance = _governance;                                                                                                                                                                               │
│         strategist = _strategist;                                                                                                                                                                               │
│         keeper = _keeper;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rewards = _rewards;                                                                                                                                                                                     │
│         onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedReturn(                                                                                                                                                                                 │
│         address _strategy,                                                                                                                                                                                      │
│         address _token,                                                                                                                                                                                         │
│         uint256 parts                                                                                                                                                                                           │
│     ) public view returns (uint256 expected) {                                                                                                                                                                  │
│         uint256 _balance = IERC20Upgradeable(_token).balanceOf(_strategy);                                                                                                                                      │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│         (expected, ) = IOneSplitAudit(onesplit).getExpectedReturn(                                                                                                                                              │
│             _token,                                                                                                                                                                                             │
│             _want,                                                                                                                                                                                              │
│             _balance,                                                                                                                                                                                           │
│             parts,                                                                                                                                                                                              │
│             0                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedReturn(                                                                                                                                                                                 │
│         address _strategy,                                                                                                                                                                                      │
│         address _token,                                                                                                                                                                                         │
│         uint256 parts                                                                                                                                                                                           │
│     ) public view returns (uint256 expected) {                                                                                                                                                                  │
│         uint256 _balance = IERC20Upgradeable(_token).balanceOf(_strategy);                                                                                                                                      │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│         (expected, ) = IOneSplitAudit(onesplit).getExpectedReturn(                                                                                                                                              │
│             _token,                                                                                                                                                                                             │
│             _want,                                                                                                                                                                                              │
│             _balance,                                                                                                                                                                                           │
│             parts,                                                                                                                                                                                              │
│             0                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function getExpectedReturn(                                                                                                                                                                                 │
│         address _strategy,                                                                                                                                                                                      │
│         address _token,                                                                                                                                                                                         │
│         uint256 parts                                                                                                                                                                                           │
│     ) public view returns (uint256 expected) {                                                                                                                                                                  │
│         uint256 _balance = IERC20Upgradeable(_token).balanceOf(_strategy);                                                                                                                                      │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│         (expected, ) = IOneSplitAudit(onesplit).getExpectedReturn(                                                                                                                                              │
│             _token,                                                                                                                                                                                             │
│             _want,                                                                                                                                                                                              │
│             _balance,                                                                                                                                                                                           │
│             parts,                                                                                                                                                                                              │
│             0                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedReturn(                                                                                                                                                                                 │
│         address _strategy,                                                                                                                                                                                      │
│         address _token,                                                                                                                                                                                         │
│         uint256 parts                                                                                                                                                                                           │
│     ) public view returns (uint256 expected) {                                                                                                                                                                  │
│         uint256 _balance = IERC20Upgradeable(_token).balanceOf(_strategy);                                                                                                                                      │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│         (expected, ) = IOneSplitAudit(onesplit).getExpectedReturn(                                                                                                                                              │
│             _token,                                                                                                                                                                                             │
│             _want,                                                                                                                                                                                              │
│             _balance,                                                                                                                                                                                           │
│             parts,                                                                                                                                                                                              │
│             0                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function getExpectedReturn(                                                                                                                                                                                 │
│         address _strategy,                                                                                                                                                                                      │
│         address _token,                                                                                                                                                                                         │
│         uint256 parts                                                                                                                                                                                           │
│     ) public view returns (uint256 expected) {                                                                                                                                                                  │
│         uint256 _balance = IERC20Upgradeable(_token).balanceOf(_strategy);                                                                                                                                      │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│         (expected, ) = IOneSplitAudit(onesplit).getExpectedReturn(                                                                                                                                              │
│             _token,                                                                                                                                                                                             │
│             _want,                                                                                                                                                                                              │
│             _balance,                                                                                                                                                                                           │
│             parts,                                                                                                                                                                                              │
│             0                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setVault(address _token, address _vault) public {                                                                                                                                                  │
│         _onlyGovernanceOrStrategist();                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         require(vaults[_token] == address(0), "vault");                                                                                                                                                         │
│         vaults[_token] = _vault;                                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setStrategy(address _token, address _strategy) public {                                                                                                                                            │
│         _onlyGovernanceOrStrategist();                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         require(approvedStrategies[_token][_strategy] == true, "!approved");                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         address _current = strategies[_token];                                                                                                                                                                  │
│         if (_current != address(0)) {                                                                                                                                                                           │
│             IStrategy(_current).withdrawAll();                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         strategies[_token] = _strategy;                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ add or check approval via require/if statements before the token transfer,                                                                                                                                      │
│ Code:                                                                                                                                                                                                           │
│     function earn(address _token, uint256 _amount) public {                                                                                                                                                     │
│         address _strategy = strategies[_token];                                                                                                                                                                 │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _onlyApprovedForWant(_want);                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (_want != _token) {                                                                                                                                                                                  │
│             address converter = converters[_token][_want];                                                                                                                                                      │
│             IERC20Upgradeable(_token).safeTransfer(converter, _amount);                                                                                                                                         │
│             _amount = IConverter(converter).convert(_strategy);                                                                                                                                                 │
│             IERC20Upgradeable(_want).safeTransfer(_strategy, _amount);                                                                                                                                          │
│         } else {                                                                                                                                                                                                │
│             IERC20Upgradeable(_token).safeTransfer(_strategy, _amount);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         IStrategy(_strategy).deposit();                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer,                                                                                                                           │
│ Code:                                                                                                                                                                                                           │
│     function earn() public whenNotPaused {                                                                                                                                                                      │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 _bal = available();                                                                                                                                                                             │
│         token.safeTransfer(controller, _bal);                                                                                                                                                                   │
│         IController(controller).earn(address(token), _bal);                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│     function earn(address _token, uint256 _amount) public {                                                                                                                                                     │
│         address _strategy = strategies[_token];                                                                                                                                                                 │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _onlyApprovedForWant(_want);                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (_want != _token) {                                                                                                                                                                                  │
│             address converter = converters[_token][_want];                                                                                                                                                      │
│             IERC20Upgradeable(_token).safeTransfer(converter, _amount);                                                                                                                                         │
│             _amount = IConverter(converter).convert(_strategy);                                                                                                                                                 │
│             IERC20Upgradeable(_want).safeTransfer(_strategy, _amount);                                                                                                                                          │
│         } else {                                                                                                                                                                                                │
│             IERC20Upgradeable(_token).safeTransfer(_strategy, _amount);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         IStrategy(_strategy).deposit();                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer, and there is no clear/reset of the approval when the transfer finishes its main branch or encounters exceptions           │
│ Code:                                                                                                                                                                                                           │
│     function earn() public whenNotPaused {                                                                                                                                                                      │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 _bal = available();                                                                                                                                                                             │
│         token.safeTransfer(controller, _bal);                                                                                                                                                                   │
│         IController(controller).earn(address(token), _bal);                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│     function earn(address _token, uint256 _amount) public {                                                                                                                                                     │
│         address _strategy = strategies[_token];                                                                                                                                                                 │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _onlyApprovedForWant(_want);                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (_want != _token) {                                                                                                                                                                                  │
│             address converter = converters[_token][_want];                                                                                                                                                      │
│             IERC20Upgradeable(_token).safeTransfer(converter, _amount);                                                                                                                                         │
│             _amount = IConverter(converter).convert(_strategy);                                                                                                                                                 │
│             IERC20Upgradeable(_want).safeTransfer(_strategy, _amount);                                                                                                                                          │
│         } else {                                                                                                                                                                                                │
│             IERC20Upgradeable(_token).safeTransfer(_strategy, _amount);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         IStrategy(_strategy).deposit();                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function initialize(                                                                                                                                                                                        │
│         address _token,                                                                                                                                                                                         │
│         address _controller,                                                                                                                                                                                    │
│         address _governance,                                                                                                                                                                                    │
│         address _keeper,                                                                                                                                                                                        │
│         address _guardian,                                                                                                                                                                                      │
│         bool _overrideTokenName,                                                                                                                                                                                │
│         string memory _namePrefix,                                                                                                                                                                              │
│         string memory _symbolPrefix                                                                                                                                                                             │
│     ) public initializer whenNotPaused {                                                                                                                                                                        │
│         IERC20Detailed namedToken = IERC20Detailed(_token);                                                                                                                                                     │
│         string memory tokenName = namedToken.name();                                                                                                                                                            │
│         string memory tokenSymbol = namedToken.symbol();                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         string memory name;                                                                                                                                                                                     │
│         string memory symbol;                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         if (_overrideTokenName) {                                                                                                                                                                               │
│             name = string(abi.encodePacked(_namePrefix, tokenName));                                                                                                                                            │
│             symbol = string(abi.encodePacked(_symbolPrefix, tokenSymbol));                                                                                                                                      │
│         } else {                                                                                                                                                                                                │
│             name = string(abi.encodePacked(_defaultNamePrefix, tokenName));                                                                                                                                     │
│             symbol = string(abi.encodePacked(_symbolSymbolPrefix, tokenSymbol));                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         __ERC20_init(name, symbol);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         token = IERC20Upgradeable(_token);                                                                                                                                                                      │
│         governance = _governance;                                                                                                                                                                               │
│         strategist = address(0);                                                                                                                                                                                │
│         keeper = _keeper;                                                                                                                                                                                       │
│         controller = _controller;                                                                                                                                                                               │
│         guardian = _guardian;                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         min = 9500;                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         emit FullPricePerShareUpdated(                                                                                                                                                                          │
│             getPricePerFullShare(),                                                                                                                                                                             │
│             now,                                                                                                                                                                                                │
│             block.number                                                                                                                                                                                        │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Paused on launch                                                                                                                                                                                     │
│         _pause();                                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositAll(bytes32[] memory proof) external whenNotPaused {                                                                                                                                        │
│         _defend();                                                                                                                                                                                              │
│         _blockLocked();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _lockForBlock(msg.sender);                                                                                                                                                                              │
│         _depositWithAuthorization(token.balanceOf(msg.sender), proof);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll() external whenNotPaused {                                                                                                                                                             │
│         _defend();                                                                                                                                                                                              │
│         _blockLocked();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _lockForBlock(msg.sender);                                                                                                                                                                              │
│         _withdraw(balanceOf(msg.sender));                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function setStrategy(address _token, address _strategy) public {                                                                                                                                            │
│         _onlyGovernanceOrStrategist();                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         require(approvedStrategies[_token][_strategy] == true, "!approved");                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         address _current = strategies[_token];                                                                                                                                                                  │
│         if (_current != address(0)) {                                                                                                                                                                           │
│             IStrategy(_current).withdrawAll();                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         strategies[_token] = _strategy;                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function withdrawAll() external whenNotPaused {                                                                                                                                                             │
│         _defend();                                                                                                                                                                                              │
│         _blockLocked();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _lockForBlock(msg.sender);                                                                                                                                                                              │
│         _withdraw(balanceOf(msg.sender));                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: mint or vest or collect token/liquidity/earning and assign them to the address recipient or to variable,                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function harvest(address reserve, uint256 amount) external whenNotPaused {                                                                                                                                  │
│         _onlyController();                                                                                                                                                                                      │
│         require(reserve != address(token), "token");                                                                                                                                                            │
│         IERC20Upgradeable(reserve).safeTransfer(controller, amount);                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal virtual {                                                                                                                                                       │
│         uint256 _pool = balance();                                                                                                                                                                              │
│         uint256 _before = token.balanceOf(address(this));                                                                                                                                                       │
│         token.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                             │
│         uint256 _after = token.balanceOf(address(this));                                                                                                                                                        │
│         _amount = _after.sub(_before); // Additional check for deflationary tokens                                                                                                                              │
│         uint256 shares = 0;                                                                                                                                                                                     │
│         if (totalSupply() == 0) {                                                                                                                                                                               │
│             shares = _amount;                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             shares = (_amount.mul(totalSupply())).div(_pool);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         _mint(msg.sender, shares);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal virtual {                                                                                                                                                       │
│         uint256 _pool = balance();                                                                                                                                                                              │
│         uint256 _before = token.balanceOf(address(this));                                                                                                                                                       │
│         token.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                             │
│         uint256 _after = token.balanceOf(address(this));                                                                                                                                                        │
│         _amount = _after.sub(_before); // Additional check for deflationary tokens                                                                                                                              │
│         uint256 shares = 0;                                                                                                                                                                                     │
│         if (totalSupply() == 0) {                                                                                                                                                                               │
│             shares = _amount;                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             shares = (_amount.mul(totalSupply())).div(_pool);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         _mint(msg.sender, shares);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal virtual {                                                                                                                                                       │
│         uint256 _pool = balance();                                                                                                                                                                              │
│         uint256 _before = token.balanceOf(address(this));                                                                                                                                                       │
│         token.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                             │
│         uint256 _after = token.balanceOf(address(this));                                                                                                                                                        │
│         _amount = _after.sub(_before); // Additional check for deflationary tokens                                                                                                                              │
│         uint256 shares = 0;                                                                                                                                                                                     │
│         if (totalSupply() == 0) {                                                                                                                                                                               │
│             shares = _amount;                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             shares = (_amount.mul(totalSupply())).div(_pool);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         _mint(msg.sender, shares);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal virtual {                                                                                                                                                       │
│         uint256 _pool = balance();                                                                                                                                                                              │
│         uint256 _before = token.balanceOf(address(this));                                                                                                                                                       │
│         token.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                             │
│         uint256 _after = token.balanceOf(address(this));                                                                                                                                                        │
│         _amount = _after.sub(_before); // Additional check for deflationary tokens                                                                                                                              │
│         uint256 shares = 0;                                                                                                                                                                                     │
│         if (totalSupply() == 0) {                                                                                                                                                                               │
│             shares = _amount;                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             shares = (_amount.mul(totalSupply())).div(_pool);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         _mint(msg.sender, shares);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal virtual {                                                                                                                                                       │
│         uint256 _pool = balance();                                                                                                                                                                              │
│         uint256 _before = token.balanceOf(address(this));                                                                                                                                                       │
│         token.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                             │
│         uint256 _after = token.balanceOf(address(this));                                                                                                                                                        │
│         _amount = _after.sub(_before); // Additional check for deflationary tokens                                                                                                                              │
│         uint256 shares = 0;                                                                                                                                                                                     │
│         if (totalSupply() == 0) {                                                                                                                                                                               │
│             shares = _amount;                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             shares = (_amount.mul(totalSupply())).div(_pool);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         _mint(msg.sender, shares);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function _deposit(uint256 _amount) internal virtual {                                                                                                                                                       │
│         uint256 _pool = balance();                                                                                                                                                                              │
│         uint256 _before = token.balanceOf(address(this));                                                                                                                                                       │
│         token.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                             │
│         uint256 _after = token.balanceOf(address(this));                                                                                                                                                        │
│         _amount = _after.sub(_before); // Additional check for deflationary tokens                                                                                                                              │
│         uint256 shares = 0;                                                                                                                                                                                     │
│         if (totalSupply() == 0) {                                                                                                                                                                               │
│             shares = _amount;                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             shares = (_amount.mul(totalSupply())).div(_pool);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         _mint(msg.sender, shares);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _shares) internal virtual {                                                                                                                                                      │
│         uint256 r = (balance().mul(_shares)).div(totalSupply());                                                                                                                                                │
│         _burn(msg.sender, _shares);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Check balance                                                                                                                                                                                        │
│         uint256 b = token.balanceOf(address(this));                                                                                                                                                             │
│         if (b < r) {                                                                                                                                                                                            │
│             uint256 _toWithdraw = r.sub(b);                                                                                                                                                                     │
│             IController(controller).withdraw(address(token), _toWithdraw);                                                                                                                                      │
│             uint256 _after = token.balanceOf(address(this));                                                                                                                                                    │
│             uint256 _diff = _after.sub(b);                                                                                                                                                                      │
│             if (_diff < _toWithdraw) {                                                                                                                                                                          │
│                 r = b.add(_diff);                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         token.safeTransfer(msg.sender, r);                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _shares) public whenNotPaused {                                                                                                                                                   │
│         _defend();                                                                                                                                                                                              │
│         _blockLocked();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _lockForBlock(msg.sender);                                                                                                                                                                              │
│         _withdraw(_shares);                                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│     function _withdraw(uint256 _shares) internal virtual {                                                                                                                                                      │
│         uint256 r = (balance().mul(_shares)).div(totalSupply());                                                                                                                                                │
│         _burn(msg.sender, _shares);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Check balance                                                                                                                                                                                        │
│         uint256 b = token.balanceOf(address(this));                                                                                                                                                             │
│         if (b < r) {                                                                                                                                                                                            │
│             uint256 _toWithdraw = r.sub(b);                                                                                                                                                                     │
│             IController(controller).withdraw(address(token), _toWithdraw);                                                                                                                                      │
│             uint256 _after = token.balanceOf(address(this));                                                                                                                                                    │
│             uint256 _diff = _after.sub(b);                                                                                                                                                                      │
│             if (_diff < _toWithdraw) {                                                                                                                                                                          │
│                 r = b.add(_diff);                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         token.safeTransfer(msg.sender, r);                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll() external whenNotPaused {                                                                                                                                                             │
│         _defend();                                                                                                                                                                                              │
│         _blockLocked();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _lockForBlock(msg.sender);                                                                                                                                                                              │
│         _withdraw(balanceOf(msg.sender));                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _withdraw(uint256 _shares) internal virtual {                                                                                                                                                      │
│         uint256 r = (balance().mul(_shares)).div(totalSupply());                                                                                                                                                │
│         _burn(msg.sender, _shares);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Check balance                                                                                                                                                                                        │
│         uint256 b = token.balanceOf(address(this));                                                                                                                                                             │
│         if (b < r) {                                                                                                                                                                                            │
│             uint256 _toWithdraw = r.sub(b);                                                                                                                                                                     │
│             IController(controller).withdraw(address(token), _toWithdraw);                                                                                                                                      │
│             uint256 _after = token.balanceOf(address(this));                                                                                                                                                    │
│             uint256 _diff = _after.sub(b);                                                                                                                                                                      │
│             if (_diff < _toWithdraw) {                                                                                                                                                                          │
│                 r = b.add(_diff);                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         token.safeTransfer(msg.sender, r);                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function authorized(                                                                                                                                                                                        │
│         address _guest,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         bytes32[] calldata _merkleProof                                                                                                                                                                         │
│     ) external view returns (bool) {                                                                                                                                                                            │
│         // Yes: If the user is on the list, and under the cap                                                                                                                                                   │
│         // Yes: If the user is not on the list, supplies a valid proof (thereby being added to the list), and is under the cap                                                                                  │
│         // No: If the user is not on the list, does not supply a valid proof, or is over the cap                                                                                                                │
│         bool invited = guests[_guest];                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // If there is no guest root, all users are invited                                                                                                                                                     │
│         if (!invited && guestRoot == bytes32(0)) {                                                                                                                                                              │
│             invited = true;                                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If the user is not already invited and there is an active guestList, require verification of merkle proof to grant temporary invitation (does not set storage variable)                              │
│         if (!invited && guestRoot != bytes32(0)) {                                                                                                                                                              │
│             // Will revert on invalid proof                                                                                                                                                                     │
│             invited = _verifyInvitationProof(_guest, _merkleProof);                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If the user was previously invited, or proved invitiation via list, verify if the amount to deposit keeps them under the cap                                                                         │
│         if (                                                                                                                                                                                                    │
│             invited &&                                                                                                                                                                                          │
│             remainingUserDepositAllowed(_guest) >= _amount &&                                                                                                                                                   │
│             remainingTotalDepositAllowed() >= _amount                                                                                                                                                           │
│         ) {                                                                                                                                                                                                     │
│             return true;                                                                                                                                                                                        │
│         } else {                                                                                                                                                                                                │
│             return false;                                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _checkpointEpoch() internal {                                                                                                                                                                      │
│         uint256 currentEpoch =                                                                                                                                                                                  │
│             block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                                          │
│         uint256 epochindex = epochs.length;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //first epoch add in constructor, no need to check 0 length                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //check to add                                                                                                                                                                                          │
│         if (epochs.date < currentEpoch) {                                                                                                                                                                       │
│             //fill any epoch gaps                                                                                                                                                                               │
│             while (epochs.date != currentEpoch) {                                                                                                                                                               │
│                 uint256 nextEpochDate =                                                                                                                                                                         │
│                     uint256(epochs.date).add(                                                                                                                                                                   │
│                         rewardsDuration                                                                                                                                                                         │
│                     );                                                                                                                                                                                          │
│                 epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));                                                                                                                                   │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //update boost parameters on a new epoch                                                                                                                                                            │
│             if (boostRate != nextBoostRate) {                                                                                                                                                                   │
│                 boostRate = nextBoostRate;                                                                                                                                                                      │
│             }                                                                                                                                                                                                   │
│             if (maximumBoostPayment != nextMaximumBoostPayment) {                                                                                                                                               │
│                 maximumBoostPayment = nextMaximumBoostPayment;                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ have inside code statements that invoke user checkpoint,                                                                                                                                                        │
│ Code:                                                                                                                                                                                                           │
│     function _lock(                                                                                                                                                                                             │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _spendRatio                                                                                                                                                                                     │
│     ) internal {                                                                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(_spendRatio <= maximumBoostPayment, "over max spend");                                                                                                                                          │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //calc lock and boosted amount                                                                                                                                                                          │
│         uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);                                                                                                                                        │
│         uint256 boostRatio =                                                                                                                                                                                    │
│             boostRate.mul(_spendRatio).div(                                                                                                                                                                     │
│                 maximumBoostPayment == 0 ? 1 : maximumBoostPayment                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         uint112 lockAmount = _amount.sub(spendAmount).to112();                                                                                                                                                  │
│         uint112 boostedAmount =                                                                                                                                                                                 │
│             _amount.add(_amount.mul(boostRatio).div(denominator)).to112();                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│         bal.boosted = bal.boosted.add(boostedAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(lockAmount);                                                                                                                                                            │
│         boostedSupply = boostedSupply.add(boostedAmount);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch =                                                                                                                                                                                  │
│             block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                                          │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(                                                                                                                                                                           │
│                 LockedBalance({                                                                                                                                                                                 │
│                     amount: lockAmount,                                                                                                                                                                         │
│                     boosted: boostedAmount,                                                                                                                                                                     │
│                     unlockTime: uint32(unlockTime)                                                                                                                                                              │
│                 })                                                                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│             userL.boosted = userL.boosted.add(boostedAmount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(uint224(boostedAmount));                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send boost payment                                                                                                                                                                                    │
│         if (spendAmount > 0) {                                                                                                                                                                                  │
│             stakingToken.safeTransfer(boostPayment, spendAmount);                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update staking, allow a bit of leeway for smaller deposits to reduce gas                                                                                                                              │
│         updateStakeRatio(stakeOffsetOnLock);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, _amount, lockAmount, boostedAmount);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes",                                                                                                                                                                                                 │
│     "3": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _lock(                                                                                                                                                                                             │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _spendRatio                                                                                                                                                                                     │
│     ) internal {                                                                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(_spendRatio <= maximumBoostPayment, "over max spend");                                                                                                                                          │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //calc lock and boosted amount                                                                                                                                                                          │
│         uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);                                                                                                                                        │
│         uint256 boostRatio =                                                                                                                                                                                    │
│             boostRate.mul(_spendRatio).div(                                                                                                                                                                     │
│                 maximumBoostPayment == 0 ? 1 : maximumBoostPayment                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         uint112 lockAmount = _amount.sub(spendAmount).to112();                                                                                                                                                  │
│         uint112 boostedAmount =                                                                                                                                                                                 │
│             _amount.add(_amount.mul(boostRatio).div(denominator)).to112();                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│         bal.boosted = bal.boosted.add(boostedAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(lockAmount);                                                                                                                                                            │
│         boostedSupply = boostedSupply.add(boostedAmount);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch =                                                                                                                                                                                  │
│             block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                                          │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(                                                                                                                                                                           │
│                 LockedBalance({                                                                                                                                                                                 │
│                     amount: lockAmount,                                                                                                                                                                         │
│                     boosted: boostedAmount,                                                                                                                                                                     │
│                     unlockTime: uint32(unlockTime)                                                                                                                                                              │
│                 })                                                                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│             userL.boosted = userL.boosted.add(boostedAmount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(uint224(boostedAmount));                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send boost payment                                                                                                                                                                                    │
│         if (spendAmount > 0) {                                                                                                                                                                                  │
│             stakingToken.safeTransfer(boostPayment, spendAmount);                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update staking, allow a bit of leeway for smaller deposits to reduce gas                                                                                                                              │
│         updateStakeRatio(stakeOffsetOnLock);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, _amount, lockAmount, boostedAmount);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function lock(                                                                                                                                                                                              │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _spendRatio                                                                                                                                                                                     │
│     ) external nonReentrant updateReward(_account) {                                                                                                                                                            │
│         //pull tokens                                                                                                                                                                                           │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //lock                                                                                                                                                                                                  │
│         _lock(_account, _amount, _spendRatio);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     function _lock(                                                                                                                                                                                             │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _spendRatio                                                                                                                                                                                     │
│     ) internal {                                                                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(_spendRatio <= maximumBoostPayment, "over max spend");                                                                                                                                          │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //calc lock and boosted amount                                                                                                                                                                          │
│         uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);                                                                                                                                        │
│         uint256 boostRatio =                                                                                                                                                                                    │
│             boostRate.mul(_spendRatio).div(                                                                                                                                                                     │
│                 maximumBoostPayment == 0 ? 1 : maximumBoostPayment                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         uint112 lockAmount = _amount.sub(spendAmount).to112();                                                                                                                                                  │
│         uint112 boostedAmount =                                                                                                                                                                                 │
│             _amount.add(_amount.mul(boostRatio).div(denominator)).to112();                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│         bal.boosted = bal.boosted.add(boostedAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(lockAmount);                                                                                                                                                            │
│         boostedSupply = boostedSupply.add(boostedAmount);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch =                                                                                                                                                                                  │
│             block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                                          │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(                                                                                                                                                                           │
│                 LockedBalance({                                                                                                                                                                                 │
│                     amount: lockAmount,                                                                                                                                                                         │
│                     boosted: boostedAmount,                                                                                                                                                                     │
│                     unlockTime: uint32(unlockTime)                                                                                                                                                              │
│                 })                                                                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│             userL.boosted = userL.boosted.add(boostedAmount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(uint224(boostedAmount));                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send boost payment                                                                                                                                                                                    │
│         if (spendAmount > 0) {                                                                                                                                                                                  │
│             stakingToken.safeTransfer(boostPayment, spendAmount);                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update staking, allow a bit of leeway for smaller deposits to reduce gas                                                                                                                              │
│         updateStakeRatio(stakeOffsetOnLock);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, _amount, lockAmount, boostedAmount);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function lock(                                                                                                                                                                                              │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _spendRatio                                                                                                                                                                                     │
│     ) external nonReentrant updateReward(_account) {                                                                                                                                                            │
│         //pull tokens                                                                                                                                                                                           │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //lock                                                                                                                                                                                                  │
│         _lock(_account, _amount, _spendRatio);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     function _lock(                                                                                                                                                                                             │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _spendRatio                                                                                                                                                                                     │
│     ) internal {                                                                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(_spendRatio <= maximumBoostPayment, "over max spend");                                                                                                                                          │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //calc lock and boosted amount                                                                                                                                                                          │
│         uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);                                                                                                                                        │
│         uint256 boostRatio =                                                                                                                                                                                    │
│             boostRate.mul(_spendRatio).div(                                                                                                                                                                     │
│                 maximumBoostPayment == 0 ? 1 : maximumBoostPayment                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         uint112 lockAmount = _amount.sub(spendAmount).to112();                                                                                                                                                  │
│         uint112 boostedAmount =                                                                                                                                                                                 │
│             _amount.add(_amount.mul(boostRatio).div(denominator)).to112();                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│         bal.boosted = bal.boosted.add(boostedAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(lockAmount);                                                                                                                                                            │
│         boostedSupply = boostedSupply.add(boostedAmount);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch =                                                                                                                                                                                  │
│             block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                                          │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(                                                                                                                                                                           │
│                 LockedBalance({                                                                                                                                                                                 │
│                     amount: lockAmount,                                                                                                                                                                         │
│                     boosted: boostedAmount,                                                                                                                                                                     │
│                     unlockTime: uint32(unlockTime)                                                                                                                                                              │
│                 })                                                                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│             userL.boosted = userL.boosted.add(boostedAmount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(uint224(boostedAmount));                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send boost payment                                                                                                                                                                                    │
│         if (spendAmount > 0) {                                                                                                                                                                                  │
│             stakingToken.safeTransfer(boostPayment, spendAmount);                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update staking, allow a bit of leeway for smaller deposits to reduce gas                                                                                                                              │
│         updateStakeRatio(stakeOffsetOnLock);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, _amount, lockAmount, boostedAmount);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _processExpiredLocks(                                                                                                                                                                              │
│         address _account,                                                                                                                                                                                       │
│         bool _relock,                                                                                                                                                                                           │
│         uint256 _spendRatio,                                                                                                                                                                                    │
│         address _withdrawTo,                                                                                                                                                                                    │
│         address _rewardAddress,                                                                                                                                                                                 │
│         uint256 _checkDelay                                                                                                                                                                                     │
│     ) internal updateReward(_account) {                                                                                                                                                                         │
│         LockedBalance[] storage locks = userLocks[_account];                                                                                                                                                    │
│         Balances storage userBalance = balances[_account];                                                                                                                                                      │
│         uint112 locked;                                                                                                                                                                                         │
│         uint112 boostedAmount;                                                                                                                                                                                  │
│         uint256 length = locks.length;                                                                                                                                                                          │
│         uint256 reward = 0;                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (                                                                                                                                                                                                    │
│             isShutdown ||                                                                                                                                                                                       │
│             locks.unlockTime <= block.timestamp.sub(_checkDelay)                                                                                                                                                │
│         ) {                                                                                                                                                                                                     │
│             //if time is beyond last lock, can just bundle everything together                                                                                                                                  │
│             locked = userBalance.locked;                                                                                                                                                                        │
│             boostedAmount = userBalance.boosted;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             //dont delete, just set next index                                                                                                                                                                  │
│             userBalance.nextUnlockIndex = length.to32();                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             //check for kick reward                                                                                                                                                                             │
│             //this wont have the exact reward rate that you would get if looped through                                                                                                                         │
│             //but this section is supposed to be for quick and easy low gas processing of all locks                                                                                                             │
│             //we'll assume that if the reward was good enough someone would have processed at an earlier epoch                                                                                                  │
│             if (_checkDelay > 0) {                                                                                                                                                                              │
│                 uint256 currentEpoch =                                                                                                                                                                          │
│                     block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                                                                                                                                  │
│                         rewardsDuration                                                                                                                                                                         │
│                     );                                                                                                                                                                                          │
│                 uint256 epochsover =                                                                                                                                                                            │
│                     currentEpoch.sub(uint256(locks.unlockTime)).div(                                                                                                                                            │
│                         rewardsDuration                                                                                                                                                                         │
│                     );                                                                                                                                                                                          │
│                 uint256 rRate =                                                                                                                                                                                 │
│                     MathUtil.min(                                                                                                                                                                               │
│                         kickRewardPerEpoch.mul(epochsover + 1),                                                                                                                                                 │
│                         denominator                                                                                                                                                                             │
│                     );                                                                                                                                                                                          │
│                 reward = uint256(locks.amount).mul(rRate).div(                                                                                                                                                  │
│                     denominator                                                                                                                                                                                 │
│                 );                                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             //use a processed index(nextUnlockIndex) to not loop as much                                                                                                                                        │
│             //deleting does not change array length                                                                                                                                                             │
│             uint32 nextUnlockIndex = userBalance.nextUnlockIndex;                                                                                                                                               │
│             for (uint256 i = nextUnlockIndex; i < length; i++) {                                                                                                                                                │
│                 //unlock time must be less or equal to time                                                                                                                                                     │
│                 if (locks.unlockTime > block.timestamp.sub(_checkDelay))                                                                                                                                        │
│                     break;                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│                 //add to cumulative amounts                                                                                                                                                                     │
│                 locked = locked.add(locks.amount);                                                                                                                                                              │
│                 boostedAmount = boostedAmount.add(locks.boosted);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 //check for kick reward                                                                                                                                                                         │
│                 //each epoch over due increases reward                                                                                                                                                          │
│                 if (_checkDelay > 0) {                                                                                                                                                                          │
│                     uint256 currentEpoch =                                                                                                                                                                      │
│                         block                                                                                                                                                                                   │
│                             .timestamp                                                                                                                                                                          │
│                             .sub(_checkDelay)                                                                                                                                                                   │
│                             .div(rewardsDuration)                                                                                                                                                               │
│                             .mul(rewardsDuration);                                                                                                                                                              │
│                     uint256 epochsover =                                                                                                                                                                        │
│                         currentEpoch.sub(uint256(locks.unlockTime)).div(                                                                                                                                        │
│                             rewardsDuration                                                                                                                                                                     │
│                         );                                                                                                                                                                                      │
│                     uint256 rRate =                                                                                                                                                                             │
│                         MathUtil.min(                                                                                                                                                                           │
│                             kickRewardPerEpoch.mul(epochsover + 1),                                                                                                                                             │
│                             denominator                                                                                                                                                                         │
│                         );                                                                                                                                                                                      │
│                     reward = reward.add(                                                                                                                                                                        │
│                         uint256(locks.amount).mul(rRate).div(denominator)                                                                                                                                       │
│                     );                                                                                                                                                                                          │
│                 }                                                                                                                                                                                               │
│                 //set next unlock index                                                                                                                                                                         │
│                 nextUnlockIndex++;                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             //update next unlock index                                                                                                                                                                          │
│             userBalance.nextUnlockIndex = nextUnlockIndex;                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│         require(locked > 0, "no exp locks");                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //update user balances and total supplies                                                                                                                                                               │
│         userBalance.locked = userBalance.locked.sub(locked);                                                                                                                                                    │
│         userBalance.boosted = userBalance.boosted.sub(boostedAmount);                                                                                                                                           │
│         lockedSupply = lockedSupply.sub(locked);                                                                                                                                                                │
│         boostedSupply = boostedSupply.sub(boostedAmount);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_account, locked, _relock);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //send process incentive                                                                                                                                                                                │
│         if (reward > 0) {                                                                                                                                                                                       │
│             //if theres a reward(kicked), it will always be a withdraw only                                                                                                                                     │
│             //preallocate enough cvx from stake contract to pay for both reward and withdraw                                                                                                                    │
│             allocateCVXForTransfer(uint256(locked));                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│             //reduce return amount by the kick reward                                                                                                                                                           │
│             locked = locked.sub(reward.to112());                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             //transfer reward                                                                                                                                                                                   │
│             transferCVX(_rewardAddress, reward, false);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             emit KickReward(_rewardAddress, _account, reward);                                                                                                                                                  │
│         } else if (_spendRatio > 0) {                                                                                                                                                                           │
│             //preallocate enough cvx to transfer the boost cost                                                                                                                                                 │
│             allocateCVXForTransfer(                                                                                                                                                                             │
│                 uint256(locked).mul(_spendRatio).div(denominator)                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //relock or return to user                                                                                                                                                                              │
│         if (_relock) {                                                                                                                                                                                          │
│             _lock(_withdrawTo, locked, _spendRatio);                                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             transferCVX(_withdrawTo, locked, true);                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _lock(                                                                                                                                                                                             │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _spendRatio                                                                                                                                                                                     │
│     ) internal {                                                                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(_spendRatio <= maximumBoostPayment, "over max spend");                                                                                                                                          │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //calc lock and boosted amount                                                                                                                                                                          │
│         uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);                                                                                                                                        │
│         uint256 boostRatio =                                                                                                                                                                                    │
│             boostRate.mul(_spendRatio).div(                                                                                                                                                                     │
│                 maximumBoostPayment == 0 ? 1 : maximumBoostPayment                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         uint112 lockAmount = _amount.sub(spendAmount).to112();                                                                                                                                                  │
│         uint112 boostedAmount =                                                                                                                                                                                 │
│             _amount.add(_amount.mul(boostRatio).div(denominator)).to112();                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│         bal.boosted = bal.boosted.add(boostedAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(lockAmount);                                                                                                                                                            │
│         boostedSupply = boostedSupply.add(boostedAmount);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch =                                                                                                                                                                                  │
│             block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                                          │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(                                                                                                                                                                           │
│                 LockedBalance({                                                                                                                                                                                 │
│                     amount: lockAmount,                                                                                                                                                                         │
│                     boosted: boostedAmount,                                                                                                                                                                     │
│                     unlockTime: uint32(unlockTime)                                                                                                                                                              │
│                 })                                                                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│             userL.boosted = userL.boosted.add(boostedAmount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(uint224(boostedAmount));                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send boost payment                                                                                                                                                                                    │
│         if (spendAmount > 0) {                                                                                                                                                                                  │
│             stakingToken.safeTransfer(boostPayment, spendAmount);                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update staking, allow a bit of leeway for smaller deposits to reduce gas                                                                                                                              │
│         updateStakeRatio(stakeOffsetOnLock);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, _amount, lockAmount, boostedAmount);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _processExpiredLocks(                                                                                                                                                                              │
│         address _account,                                                                                                                                                                                       │
│         bool _relock,                                                                                                                                                                                           │
│         uint256 _spendRatio,                                                                                                                                                                                    │
│         address _withdrawTo,                                                                                                                                                                                    │
│         address _rewardAddress,                                                                                                                                                                                 │
│         uint256 _checkDelay                                                                                                                                                                                     │
│     ) internal updateReward(_account) {                                                                                                                                                                         │
│         LockedBalance[] storage locks = userLocks[_account];                                                                                                                                                    │
│         Balances storage userBalance = balances[_account];                                                                                                                                                      │
│         uint112 locked;                                                                                                                                                                                         │
│         uint112 boostedAmount;                                                                                                                                                                                  │
│         uint256 length = locks.length;                                                                                                                                                                          │
│         uint256 reward = 0;                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (                                                                                                                                                                                                    │
│             isShutdown ||                                                                                                                                                                                       │
│             locks.unlockTime <= block.timestamp.sub(_checkDelay)                                                                                                                                                │
│         ) {                                                                                                                                                                                                     │
│             //if time is beyond last lock, can just bundle everything together                                                                                                                                  │
│             locked = userBalance.locked;                                                                                                                                                                        │
│             boostedAmount = userBalance.boosted;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             //dont delete, just set next index                                                                                                                                                                  │
│             userBalance.nextUnlockIndex = length.to32();                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             //check for kick reward                                                                                                                                                                             │
│             //this wont have the exact reward rate that you would get if looped through                                                                                                                         │
│             //but this section is supposed to be for quick and easy low gas processing of all locks                                                                                                             │
│             //we'll assume that if the reward was good enough someone would have processed at an earlier epoch                                                                                                  │
│             if (_checkDelay > 0) {                                                                                                                                                                              │
│                 uint256 currentEpoch =                                                                                                                                                                          │
│                     block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(                                                                                                                                  │
│                         rewardsDuration                                                                                                                                                                         │
│                     );                                                                                                                                                                                          │
│                 uint256 epochsover =                                                                                                                                                                            │
│                     currentEpoch.sub(uint256(locks.unlockTime)).div(                                                                                                                                            │
│                         rewardsDuration                                                                                                                                                                         │
│                     );                                                                                                                                                                                          │
│                 uint256 rRate =                                                                                                                                                                                 │
│                     MathUtil.min(                                                                                                                                                                               │
│                         kickRewardPerEpoch.mul(epochsover + 1),                                                                                                                                                 │
│                         denominator                                                                                                                                                                             │
│                     );                                                                                                                                                                                          │
│                 reward = uint256(locks.amount).mul(rRate).div(                                                                                                                                                  │
│                     denominator                                                                                                                                                                                 │
│                 );                                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             //use a processed index(nextUnlockIndex) to not loop as much                                                                                                                                        │
│             //deleting does not change array length                                                                                                                                                             │
│             uint32 nextUnlockIndex = userBalance.nextUnlockIndex;                                                                                                                                               │
│             for (uint256 i = nextUnlockIndex; i < length; i++) {                                                                                                                                                │
│                 //unlock time must be less or equal to time                                                                                                                                                     │
│                 if (locks.unlockTime > block.timestamp.sub(_checkDelay))                                                                                                                                        │
│                     break;                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│                 //add to cumulative amounts                                                                                                                                                                     │
│                 locked = locked.add(locks.amount);                                                                                                                                                              │
│                 boostedAmount = boostedAmount.add(locks.boosted);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 //check for kick reward                                                                                                                                                                         │
│                 //each epoch over due increases reward                                                                                                                                                          │
│                 if (_checkDelay > 0) {                                                                                                                                                                          │
│                     uint256 currentEpoch =                                                                                                                                                                      │
│                         block                                                                                                                                                                                   │
│                             .timestamp                                                                                                                                                                          │
│                             .sub(_checkDelay)                                                                                                                                                                   │
│                             .div(rewardsDuration)                                                                                                                                                               │
│                             .mul(rewardsDuration);                                                                                                                                                              │
│                     uint256 epochsover =                                                                                                                                                                        │
│                         currentEpoch.sub(uint256(locks.unlockTime)).div(                                                                                                                                        │
│                             rewardsDuration                                                                                                                                                                     │
│                         );                                                                                                                                                                                      │
│                     uint256 rRate =                                                                                                                                                                             │
│                         MathUtil.min(                                                                                                                                                                           │
│                             kickRewardPerEpoch.mul(epochsover + 1),                                                                                                                                             │
│                             denominator                                                                                                                                                                         │
│                         );                                                                                                                                                                                      │
│                     reward = reward.add(                                                                                                                                                                        │
│                         uint256(locks.amount).mul(rRate).div(denominator)                                                                                                                                       │
│                     );                                                                                                                                                                                          │
│                 }                                                                                                                                                                                               │
│                 //set next unlock index                                                                                                                                                                         │
│                 nextUnlockIndex++;                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             //update next unlock index                                                                                                                                                                          │
│             userBalance.nextUnlockIndex = nextUnlockIndex;                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│         require(locked > 0, "no exp locks");                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //update user balances and total supplies                                                                                                                                                               │
│         userBalance.locked = userBalance.locked.sub(locked);                                                                                                                                                    │
│         userBalance.boosted = userBalance.boosted.sub(boostedAmount);                                                                                                                                           │
│         lockedSupply = lockedSupply.sub(locked);                                                                                                                                                                │
│         boostedSupply = boostedSupply.sub(boostedAmount);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_account, locked, _relock);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //send process incentive                                                                                                                                                                                │
│         if (reward > 0) {                                                                                                                                                                                       │
│             //if theres a reward(kicked), it will always be a withdraw only                                                                                                                                     │
│             //preallocate enough cvx from stake contract to pay for both reward and withdraw                                                                                                                    │
│             allocateCVXForTransfer(uint256(locked));                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│             //reduce return amount by the kick reward                                                                                                                                                           │
│             locked = locked.sub(reward.to112());                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             //transfer reward                                                                                                                                                                                   │
│             transferCVX(_rewardAddress, reward, false);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             emit KickReward(_rewardAddress, _account, reward);                                                                                                                                                  │
│         } else if (_spendRatio > 0) {                                                                                                                                                                           │
│             //preallocate enough cvx to transfer the boost cost                                                                                                                                                 │
│             allocateCVXForTransfer(                                                                                                                                                                             │
│                 uint256(locked).mul(_spendRatio).div(denominator)                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //relock or return to user                                                                                                                                                                              │
│         if (_relock) {                                                                                                                                                                                          │
│             _lock(_withdrawTo, locked, _spendRatio);                                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             transferCVX(_withdrawTo, locked, true);                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function updateStakeRatio(uint256 _offset) internal {                                                                                                                                                       │
│         if (isShutdown) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //get balances                                                                                                                                                                                          │
│         uint256 local = stakingToken.balanceOf(address(this));                                                                                                                                                  │
│         uint256 staked = IStakingProxy(stakingProxy).getBalance();                                                                                                                                              │
│         uint256 total = local.add(staked);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (total == 0) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //current staked ratio                                                                                                                                                                                  │
│         uint256 ratio = staked.mul(denominator).div(total);                                                                                                                                                     │
│         //mean will be where we reset to if unbalanced                                                                                                                                                          │
│         uint256 mean = maximumStake.add(minimumStake).div(2);                                                                                                                                                   │
│         uint256 max = maximumStake.add(_offset);                                                                                                                                                                │
│         uint256 min = Math.min(minimumStake, minimumStake - _offset);                                                                                                                                           │
│         if (ratio > max) {                                                                                                                                                                                      │
│             //remove                                                                                                                                                                                            │
│             uint256 remove = staked.sub(total.mul(mean).div(denominator));                                                                                                                                      │
│             IStakingProxy(stakingProxy).withdraw(remove);                                                                                                                                                       │
│         } else if (ratio < min) {                                                                                                                                                                               │
│             //add                                                                                                                                                                                               │
│             uint256 increase = total.mul(mean).div(denominator).sub(staked);                                                                                                                                    │
│             stakingToken.safeTransfer(stakingProxy, increase);                                                                                                                                                  │
│             IStakingProxy(stakingProxy).stake();                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function updateStakeRatio(uint256 _offset) internal {                                                                                                                                                       │
│         if (isShutdown) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //get balances                                                                                                                                                                                          │
│         uint256 local = stakingToken.balanceOf(address(this));                                                                                                                                                  │
│         uint256 staked = IStakingProxy(stakingProxy).getBalance();                                                                                                                                              │
│         uint256 total = local.add(staked);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (total == 0) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //current staked ratio                                                                                                                                                                                  │
│         uint256 ratio = staked.mul(denominator).div(total);                                                                                                                                                     │
│         //mean will be where we reset to if unbalanced                                                                                                                                                          │
│         uint256 mean = maximumStake.add(minimumStake).div(2);                                                                                                                                                   │
│         uint256 max = maximumStake.add(_offset);                                                                                                                                                                │
│         uint256 min = Math.min(minimumStake, minimumStake - _offset);                                                                                                                                           │
│         if (ratio > max) {                                                                                                                                                                                      │
│             //remove                                                                                                                                                                                            │
│             uint256 remove = staked.sub(total.mul(mean).div(denominator));                                                                                                                                      │
│             IStakingProxy(stakingProxy).withdraw(remove);                                                                                                                                                       │
│         } else if (ratio < min) {                                                                                                                                                                               │
│             //add                                                                                                                                                                                               │
│             uint256 increase = total.mul(mean).div(denominator).sub(staked);                                                                                                                                    │
│             stakingToken.safeTransfer(stakingProxy, increase);                                                                                                                                                  │
│             IStakingProxy(stakingProxy).stake();                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(address _rewardsToken, uint256 _reward)                                                                                                                                         │
│         external                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         require(rewardDistributors[_rewardsToken]);                                                                                                                                                             │
│         require(_reward > 0, "No reward");                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _notifyReward(_rewardsToken, _reward);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // handle the transfer of reward tokens via `transferFrom` to reduce the number                                                                                                                         │
│         // of transactions required and ensure correctness of the _reward amount                                                                                                                                │
│         IERC20(_rewardsToken).safeTransferFrom(                                                                                                                                                                 │
│             msg.sender,                                                                                                                                                                                         │
│             address(this),                                                                                                                                                                                      │
│             _reward                                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         emit RewardAdded(_rewardsToken, _reward);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         if (_rewardsToken == cvxCrv) {                                                                                                                                                                          │
│             //update staking ratio if main reward                                                                                                                                                               │
│             updateStakeRatio(0);                                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function updateStakeRatio(uint256 _offset) internal {                                                                                                                                                       │
│         if (isShutdown) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //get balances                                                                                                                                                                                          │
│         uint256 local = stakingToken.balanceOf(address(this));                                                                                                                                                  │
│         uint256 staked = IStakingProxy(stakingProxy).getBalance();                                                                                                                                              │
│         uint256 total = local.add(staked);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (total == 0) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //current staked ratio                                                                                                                                                                                  │
│         uint256 ratio = staked.mul(denominator).div(total);                                                                                                                                                     │
│         //mean will be where we reset to if unbalanced                                                                                                                                                          │
│         uint256 mean = maximumStake.add(minimumStake).div(2);                                                                                                                                                   │
│         uint256 max = maximumStake.add(_offset);                                                                                                                                                                │
│         uint256 min = Math.min(minimumStake, minimumStake - _offset);                                                                                                                                           │
│         if (ratio > max) {                                                                                                                                                                                      │
│             //remove                                                                                                                                                                                            │
│             uint256 remove = staked.sub(total.mul(mean).div(denominator));                                                                                                                                      │
│             IStakingProxy(stakingProxy).withdraw(remove);                                                                                                                                                       │
│         } else if (ratio < min) {                                                                                                                                                                               │
│             //add                                                                                                                                                                                               │
│             uint256 increase = total.mul(mean).div(denominator).sub(staked);                                                                                                                                    │
│             stakingToken.safeTransfer(stakingProxy, increase);                                                                                                                                                  │
│             IStakingProxy(stakingProxy).stake();                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function transferCVX(                                                                                                                                                                                       │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         bool _updateStake                                                                                                                                                                                       │
│     ) internal {                                                                                                                                                                                                │
│         //allocate enough cvx from staking for the transfer                                                                                                                                                     │
│         allocateCVXForTransfer(_amount);                                                                                                                                                                        │
│         //transfer                                                                                                                                                                                              │
│         stakingToken.safeTransfer(_account, _amount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //update staking                                                                                                                                                                                        │
│         if (_updateStake) {                                                                                                                                                                                     │
│             updateStakeRatio(0);                                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function updateStakeRatio(uint256 _offset) internal {                                                                                                                                                       │
│         if (isShutdown) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //get balances                                                                                                                                                                                          │
│         uint256 local = stakingToken.balanceOf(address(this));                                                                                                                                                  │
│         uint256 staked = IStakingProxy(stakingProxy).getBalance();                                                                                                                                              │
│         uint256 total = local.add(staked);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (total == 0) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //current staked ratio                                                                                                                                                                                  │
│         uint256 ratio = staked.mul(denominator).div(total);                                                                                                                                                     │
│         //mean will be where we reset to if unbalanced                                                                                                                                                          │
│         uint256 mean = maximumStake.add(minimumStake).div(2);                                                                                                                                                   │
│         uint256 max = maximumStake.add(_offset);                                                                                                                                                                │
│         uint256 min = Math.min(minimumStake, minimumStake - _offset);                                                                                                                                           │
│         if (ratio > max) {                                                                                                                                                                                      │
│             //remove                                                                                                                                                                                            │
│             uint256 remove = staked.sub(total.mul(mean).div(denominator));                                                                                                                                      │
│             IStakingProxy(stakingProxy).withdraw(remove);                                                                                                                                                       │
│         } else if (ratio < min) {                                                                                                                                                                               │
│             //add                                                                                                                                                                                               │
│             uint256 increase = total.mul(mean).div(denominator).sub(staked);                                                                                                                                    │
│             stakingToken.safeTransfer(stakingProxy, increase);                                                                                                                                                  │
│             IStakingProxy(stakingProxy).stake();                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _lock(                                                                                                                                                                                             │
│         address _account,                                                                                                                                                                                       │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _spendRatio                                                                                                                                                                                     │
│     ) internal {                                                                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(_spendRatio <= maximumBoostPayment, "over max spend");                                                                                                                                          │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //calc lock and boosted amount                                                                                                                                                                          │
│         uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);                                                                                                                                        │
│         uint256 boostRatio =                                                                                                                                                                                    │
│             boostRate.mul(_spendRatio).div(                                                                                                                                                                     │
│                 maximumBoostPayment == 0 ? 1 : maximumBoostPayment                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         uint112 lockAmount = _amount.sub(spendAmount).to112();                                                                                                                                                  │
│         uint112 boostedAmount =                                                                                                                                                                                 │
│             _amount.add(_amount.mul(boostRatio).div(denominator)).to112();                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│         bal.boosted = bal.boosted.add(boostedAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(lockAmount);                                                                                                                                                            │
│         boostedSupply = boostedSupply.add(boostedAmount);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch =                                                                                                                                                                                  │
│             block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                                          │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(                                                                                                                                                                           │
│                 LockedBalance({                                                                                                                                                                                 │
│                     amount: lockAmount,                                                                                                                                                                         │
│                     boosted: boostedAmount,                                                                                                                                                                     │
│                     unlockTime: uint32(unlockTime)                                                                                                                                                              │
│                 })                                                                                                                                                                                              │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│             userL.boosted = userL.boosted.add(boostedAmount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(uint224(boostedAmount));                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send boost payment                                                                                                                                                                                    │
│         if (spendAmount > 0) {                                                                                                                                                                                  │
│             stakingToken.safeTransfer(boostPayment, spendAmount);                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update staking, allow a bit of leeway for smaller deposits to reduce gas                                                                                                                              │
│         updateStakeRatio(stakeOffsetOnLock);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, _amount, lockAmount, boostedAmount);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     function updateStakeRatio(uint256 _offset) internal {                                                                                                                                                       │
│         if (isShutdown) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //get balances                                                                                                                                                                                          │
│         uint256 local = stakingToken.balanceOf(address(this));                                                                                                                                                  │
│         uint256 staked = IStakingProxy(stakingProxy).getBalance();                                                                                                                                              │
│         uint256 total = local.add(staked);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (total == 0) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //current staked ratio                                                                                                                                                                                  │
│         uint256 ratio = staked.mul(denominator).div(total);                                                                                                                                                     │
│         //mean will be where we reset to if unbalanced                                                                                                                                                          │
│         uint256 mean = maximumStake.add(minimumStake).div(2);                                                                                                                                                   │
│         uint256 max = maximumStake.add(_offset);                                                                                                                                                                │
│         uint256 min = Math.min(minimumStake, minimumStake - _offset);                                                                                                                                           │
│         if (ratio > max) {                                                                                                                                                                                      │
│             //remove                                                                                                                                                                                            │
│             uint256 remove = staked.sub(total.mul(mean).div(denominator));                                                                                                                                      │
│             IStakingProxy(stakingProxy).withdraw(remove);                                                                                                                                                       │
│         } else if (ratio < min) {                                                                                                                                                                               │
│             //add                                                                                                                                                                                               │
│             uint256 increase = total.mul(mean).div(denominator).sub(staked);                                                                                                                                    │
│             stakingToken.safeTransfer(stakingProxy, increase);                                                                                                                                                  │
│             IStakingProxy(stakingProxy).stake();                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _notifyReward(address _rewardsToken, uint256 _reward) internal {                                                                                                                                   │
│         Reward storage rdata = rewardData[_rewardsToken];                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             rdata.rewardRate = _reward.div(rewardsDuration).to208();                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining =                                                                                                                                                                                 │
│                 uint256(rdata.periodFinish).sub(block.timestamp);                                                                                                                                               │
│             uint256 leftover = remaining.mul(rdata.rewardRate);                                                                                                                                                 │
│             rdata.rewardRate = _reward                                                                                                                                                                          │
│                 .add(leftover)                                                                                                                                                                                  │
│                 .div(rewardsDuration)                                                                                                                                                                           │
│                 .to208();                                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rdata.lastUpdateTime = block.timestamp.to40();                                                                                                                                                          │
│         rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function _notifyReward(address _rewardsToken, uint256 _reward) internal {                                                                                                                                   │
│         Reward storage rdata = rewardData[_rewardsToken];                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             rdata.rewardRate = _reward.div(rewardsDuration).to208();                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining =                                                                                                                                                                                 │
│                 uint256(rdata.periodFinish).sub(block.timestamp);                                                                                                                                               │
│             uint256 leftover = remaining.mul(rdata.rewardRate);                                                                                                                                                 │
│             rdata.rewardRate = _reward                                                                                                                                                                          │
│                 .add(leftover)                                                                                                                                                                                  │
│                 .div(rewardsDuration)                                                                                                                                                                           │
│                 .to208();                                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rdata.lastUpdateTime = block.timestamp.to40();                                                                                                                                                          │
│         rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function rescueToken(address _token, address _to) external {                                                                                                                                                │
│         require(msg.sender == owner, "!auth");                                                                                                                                                                  │
│         require(_token != crv && _token != cvx && _token != cvxCrv, "not allowed");                                                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256 bal = IERC20(_token).balanceOf(address(this));                                                                                                                                                  │
│         IERC20(_token).safeTransfer(_to, bal);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distribute() external {                                                                                                                                                                            │
│         //claim rewards                                                                                                                                                                                         │
│         IConvexRewards(cvxStaking).getReward(false);                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         //convert any crv that was directly added                                                                                                                                                               │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             ICrvDepositor(crvDeposit).deposit(crvBal, true);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //distribute cvxcrv                                                                                                                                                                                     │
│         uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBal > 0) {                                                                                                                                                                                    │
│             uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);                                                                                                                            │
│             cvxCrvBal = cvxCrvBal.sub(incentiveAmount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             IERC20(cvxCrv).safeTransfer(msg.sender,incentiveAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             ICvxLocker(rewards).notifyRewardAmount(cvxCrv, cvxCrvBal);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(cvxCrv, cvxCrvBal);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distributeOther(IERC20 _token) external {                                                                                                                                                          │
│         require( address(_token) != crv && address(_token) != cvxCrv, "not allowed");                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 bal = _token.balanceOf(address(this));                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (bal > 0) {                                                                                                                                                                                          │
│             uint256 incentiveAmount = bal.mul(callIncentive).div(denominator);                                                                                                                                  │
│             bal = bal.sub(incentiveAmount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             _token.safeTransfer(msg.sender,incentiveAmount);                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│             //approve                                                                                                                                                                                           │
│             _token.safeApprove(rewards, 0);                                                                                                                                                                     │
│             _token.safeApprove(rewards, uint256(-1));                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             ICvxLocker(rewards).notifyRewardAmount(address(_token), bal);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(address(_token), bal);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function initialize(                                                                                                                                                                                        │
│         address _governance,                                                                                                                                                                                    │
│         address _strategist,                                                                                                                                                                                    │
│         address _controller,                                                                                                                                                                                    │
│         address _keeper,                                                                                                                                                                                        │
│         address _guardian,                                                                                                                                                                                      │
│         uint256[3] memory _feeConfig                                                                                                                                                                            │
│     ) public initializer whenNotPaused {                                                                                                                                                                        │
│         __BaseStrategy_init(_governance, _strategist, _controller, _keeper, _guardian);                                                                                                                         │
│                                                                                                                                                                                                                 │
│         want = cvx;                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         performanceFeeGovernance = _feeConfig[0];                                                                                                                                                               │
│         performanceFeeStrategist = _feeConfig[1];                                                                                                                                                               │
│         withdrawalFee = _feeConfig[2];                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         address[] memory path = new address[](3);                                                                                                                                                               │
│         path[0] = cvxCrv;                                                                                                                                                                                       │
│         path[1] = weth;                                                                                                                                                                                         │
│         path[2] = cvx;                                                                                                                                                                                          │
│         _setTokenSwapPath(cvxCrv, cvx, path);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Approvals: Staking Pool                                                                                                                                                                              │
│         cvxToken.approve(address(cvxRewardsPool), MAX_UINT_256);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawSome(uint256 _amount) internal override returns (uint256) {                                                                                                                               │
│         // Get idle want in the strategy                                                                                                                                                                        │
│         uint256 _preWant = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // If we lack sufficient idle want, withdraw the difference from the strategy position                                                                                                                  │
│         if (_preWant < _amount) {                                                                                                                                                                               │
│             uint256 _toWithdraw = _amount.sub(_preWant);                                                                                                                                                        │
│             cvxRewardsPool.withdraw(_toWithdraw, false);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             // Note: Withdrawl process will earn sushi, this will be deposited into SushiBar on next tend()                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Confirm how much want we actually end up with                                                                                                                                                        │
│         uint256 _postWant = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Return the actual amount withdrawn if less than requested                                                                                                                                            │
│         uint256 _withdrawn = MathUpgradeable.min(_postWant, _amount);                                                                                                                                           │
│         emit WithdrawState(_amount, _preWant, _postWant, _withdrawn);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return _withdrawn;                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), "base-strategy/withdraw-exceed-max-deviation-threshold");                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _withdrawSome(uint256 _amount) internal override returns (uint256) {                                                                                                                               │
│         // Get idle want in the strategy                                                                                                                                                                        │
│         uint256 _preWant = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // If we lack sufficient idle want, withdraw the difference from the strategy position                                                                                                                  │
│         if (_preWant < _amount) {                                                                                                                                                                               │
│             uint256 _toWithdraw = _amount.sub(_preWant);                                                                                                                                                        │
│             cvxRewardsPool.withdraw(_toWithdraw, false);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             // Note: Withdrawl process will earn sushi, this will be deposited into SushiBar on next tend()                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Confirm how much want we actually end up with                                                                                                                                                        │
│         uint256 _postWant = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Return the actual amount withdrawn if less than requested                                                                                                                                            │
│         uint256 _withdrawn = MathUpgradeable.min(_postWant, _amount);                                                                                                                                           │
│         emit WithdrawState(_amount, _preWant, _postWant, _withdrawn);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return _withdrawn;                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(                                                                                                                                                                                            │
│                 diff <=                                                                                                                                                                                         │
│                     _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE),                                                                                                                                  │
│                 "base-strategy/withdraw-exceed-max-deviation-threshold"                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _withdrawSome(uint256 _amount) internal override returns (uint256) {                                                                                                                               │
│         // Get idle want in the strategy                                                                                                                                                                        │
│         uint256 _preWant = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // If we lack sufficient idle want, withdraw the difference from the strategy position                                                                                                                  │
│         if (_preWant < _amount) {                                                                                                                                                                               │
│             uint256 _toWithdraw = _amount.sub(_preWant);                                                                                                                                                        │
│             cvxRewardsPool.withdraw(_toWithdraw, false);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             // Note: Withdrawl process will earn sushi, this will be deposited into SushiBar on next tend()                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Confirm how much want we actually end up with                                                                                                                                                        │
│         uint256 _postWant = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Return the actual amount withdrawn if less than requested                                                                                                                                            │
│         uint256 _withdrawn = MathUpgradeable.min(_postWant, _amount);                                                                                                                                           │
│         emit WithdrawState(_amount, _preWant, _postWant, _withdrawn);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return _withdrawn;                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function harvest() external whenNotPaused returns (uint256 cvxHarvested) {                                                                                                                                  │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│         // 1. Harvest gains from positions                                                                                                                                                                      │
│         _tendGainsFromPositions();                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         uint256 stakedCvxCrv = cvxCrvRewardsPool.balanceOf(address(this));                                                                                                                                      │
│         if (stakedCvxCrv > 0) {                                                                                                                                                                                 │
│             cvxCrvRewardsPool.withdraw(stakedCvxCrv, true);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // 2. Swap cvxCRV tokens to CVX                                                                                                                                                                         │
│         uint256 cvxCrvBalance = cvxCrvToken.balanceOf(address(this));                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBalance > 0) {                                                                                                                                                                                │
│             _swapExactTokensForTokens(sushiswap, cvxCrv, cvxCrvBalance, getTokenSwapPath(cvxCrv, cvx));                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Track harvested + converted coin balance of want                                                                                                                                                     │
│         cvxHarvested = cvxToken.balanceOf(address(this));                                                                                                                                                       │
│         _processFee(cvx, cvxHarvested, performanceFeeGovernance, IController(controller).rewards());                                                                                                            │
│                                                                                                                                                                                                                 │
│         // 3. Stake all CVX                                                                                                                                                                                     │
│         if (cvxHarvested > 0) {                                                                                                                                                                                 │
│             cvxRewardsPool.stake(cvxToken.balanceOf(address(this)));                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Harvest(cvxHarvested, block.number);                                                                                                                                                               │
│         return cvxHarvested;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function harvest() external whenNotPaused returns (uint256 cvxHarvested) {                                                                                                                                  │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│         // 1. Harvest gains from positions                                                                                                                                                                      │
│         _tendGainsFromPositions();                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         uint256 stakedCvxCrv = cvxCrvRewardsPool.balanceOf(address(this));                                                                                                                                      │
│         if (stakedCvxCrv > 0) {                                                                                                                                                                                 │
│             cvxCrvRewardsPool.withdraw(stakedCvxCrv, true);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // 2. Swap cvxCRV tokens to CVX                                                                                                                                                                         │
│         uint256 cvxCrvBalance = cvxCrvToken.balanceOf(address(this));                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBalance > 0) {                                                                                                                                                                                │
│             _swapExactTokensForTokens(sushiswap, cvxCrv, cvxCrvBalance, getTokenSwapPath(cvxCrv, cvx));                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Track harvested + converted coin balance of want                                                                                                                                                     │
│         cvxHarvested = cvxToken.balanceOf(address(this));                                                                                                                                                       │
│         _processFee(cvx, cvxHarvested, performanceFeeGovernance, IController(controller).rewards());                                                                                                            │
│                                                                                                                                                                                                                 │
│         // 3. Stake all CVX                                                                                                                                                                                     │
│         if (cvxHarvested > 0) {                                                                                                                                                                                 │
│             cvxRewardsPool.stake(cvxToken.balanceOf(address(this)));                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Harvest(cvxHarvested, block.number);                                                                                                                                                               │
│         return cvxHarvested;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function manualRebalance(uint256 toLock) external whenNotPaused {                                                                                                                                           │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(toLock <= MAX_BPS, "Max is 100%");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (processLocksOnRebalance) {                                                                                                                                                                          │
│             // manualRebalance will revert if you have no expired locks                                                                                                                                         │
│             LOCKER.processExpiredLocks(false);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (harvestOnRebalance) {                                                                                                                                                                               │
│             harvest();                                                                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Token that is highly liquid                                                                                                                                                                          │
│         uint256 balanceOfWant =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│         // CVX uninvested we got from harvest and unlocks                                                                                                                                                       │
│         uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                 │
│         // Locked CVX in the locker                                                                                                                                                                             │
│         uint256 balanceInLock = LOCKER.balanceOf(address(this));                                                                                                                                                │
│         uint256 totalCVXBalance =                                                                                                                                                                               │
│             balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //Ratios                                                                                                                                                                                                │
│         uint256 currentLockRatio =                                                                                                                                                                              │
│             balanceInLock.mul(10**18).div(totalCVXBalance);                                                                                                                                                     │
│         // Amount we want to have in lock                                                                                                                                                                       │
│         uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);                                                                                                                                        │
│         // Amount we want to have in bCVX                                                                                                                                                                       │
│         uint256 toWantRatio =                                                                                                                                                                                   │
│             totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // We can't unlock enough, just deposit rest into bCVX                                                                                                                                                  │
│         if (newLockRatio <= currentLockRatio) {                                                                                                                                                                 │
│             // Deposit into vault                                                                                                                                                                               │
│             uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                │
│             if (toDeposit > 0) {                                                                                                                                                                                │
│                 CVX_VAULT.deposit(toDeposit);                                                                                                                                                                   │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If we're continuing, then we are going to lock something (unless it's zero)                                                                                                                          │
│         uint256 cvxToLock = newLockRatio.sub(currentLockRatio);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // NOTE: We only lock the CVX we have and not the bCVX                                                                                                                                                  │
│         // bCVX should be sent back to vault and then go through earn                                                                                                                                           │
│         // We do this because bCVX has "blockLock" and we can't both deposit and withdraw on the same block                                                                                                     │
│         uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                       │
│         if (cvxToLock > maxCVX) {                                                                                                                                                                               │
│             // Just lock what we can                                                                                                                                                                            │
│             LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             // Lock proper                                                                                                                                                                                      │
│             LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If anything else is left, deposit into vault                                                                                                                                                         │
│         uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                      │
│         if (cvxLeft > 0) {                                                                                                                                                                                      │
│             CVX_VAULT.deposit(cvxLeft);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat                                                                                            │
│     }                                                                                                                                                                                                           │
│     function harvest() external whenNotPaused returns (uint256 cvxHarvested) {                                                                                                                                  │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│         // 1. Harvest gains from positions                                                                                                                                                                      │
│         _tendGainsFromPositions();                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         uint256 stakedCvxCrv = cvxCrvRewardsPool.balanceOf(address(this));                                                                                                                                      │
│         if (stakedCvxCrv > 0) {                                                                                                                                                                                 │
│             cvxCrvRewardsPool.withdraw(stakedCvxCrv, true);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // 2. Swap cvxCRV tokens to CVX                                                                                                                                                                         │
│         uint256 cvxCrvBalance = cvxCrvToken.balanceOf(address(this));                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBalance > 0) {                                                                                                                                                                                │
│             _swapExactTokensForTokens(sushiswap, cvxCrv, cvxCrvBalance, getTokenSwapPath(cvxCrv, cvx));                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Track harvested + converted coin balance of want                                                                                                                                                     │
│         cvxHarvested = cvxToken.balanceOf(address(this));                                                                                                                                                       │
│         _processFee(cvx, cvxHarvested, performanceFeeGovernance, IController(controller).rewards());                                                                                                            │
│                                                                                                                                                                                                                 │
│         // 3. Stake all CVX                                                                                                                                                                                     │
│         if (cvxHarvested > 0) {                                                                                                                                                                                 │
│             cvxRewardsPool.stake(cvxToken.balanceOf(address(this)));                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Harvest(cvxHarvested, block.number);                                                                                                                                                               │
│         return cvxHarvested;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function manualRebalance(uint256 toLock) external whenNotPaused {                                                                                                                                           │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(toLock <= MAX_BPS, "Max is 100%");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (processLocksOnRebalance) {                                                                                                                                                                          │
│             // manualRebalance will revert if you have no expired locks                                                                                                                                         │
│             LOCKER.processExpiredLocks(false);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (harvestOnRebalance) {                                                                                                                                                                               │
│             harvest();                                                                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Token that is highly liquid                                                                                                                                                                          │
│         uint256 balanceOfWant =                                                                                                                                                                                 │
│             IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                                   │
│         // CVX uninvested we got from harvest and unlocks                                                                                                                                                       │
│         uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                 │
│         // Locked CVX in the locker                                                                                                                                                                             │
│         uint256 balanceInLock = LOCKER.balanceOf(address(this));                                                                                                                                                │
│         uint256 totalCVXBalance =                                                                                                                                                                               │
│             balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //Ratios                                                                                                                                                                                                │
│         uint256 currentLockRatio =                                                                                                                                                                              │
│             balanceInLock.mul(10**18).div(totalCVXBalance);                                                                                                                                                     │
│         // Amount we want to have in lock                                                                                                                                                                       │
│         uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);                                                                                                                                        │
│         // Amount we want to have in bCVX                                                                                                                                                                       │
│         uint256 toWantRatio =                                                                                                                                                                                   │
│             totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // We can't unlock enough, just deposit rest into bCVX                                                                                                                                                  │
│         if (newLockRatio <= currentLockRatio) {                                                                                                                                                                 │
│             // Deposit into vault                                                                                                                                                                               │
│             uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                │
│             if (toDeposit > 0) {                                                                                                                                                                                │
│                 CVX_VAULT.deposit(toDeposit);                                                                                                                                                                   │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If we're continuing, then we are going to lock something (unless it's zero)                                                                                                                          │
│         uint256 cvxToLock = newLockRatio.sub(currentLockRatio);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // NOTE: We only lock the CVX we have and not the bCVX                                                                                                                                                  │
│         // bCVX should be sent back to vault and then go through earn                                                                                                                                           │
│         // We do this because bCVX has "blockLock" and we can't both deposit and withdraw on the same block                                                                                                     │
│         uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                       │
│         if (cvxToLock > maxCVX) {                                                                                                                                                                               │
│             // Just lock what we can                                                                                                                                                                            │
│             LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             // Lock proper                                                                                                                                                                                      │
│             LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If anything else is left, deposit into vault                                                                                                                                                         │
│         uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));                                                                                                                                      │
│         if (cvxLeft > 0) {                                                                                                                                                                                      │
│             CVX_VAULT.deposit(cvxLeft);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat                                                                                            │
│     }                                                                                                                                                                                                           │
│     function harvest() external whenNotPaused returns (uint256 cvxHarvested) {                                                                                                                                  │
│         _onlyAuthorizedActors();                                                                                                                                                                                │
│         // 1. Harvest gains from positions                                                                                                                                                                      │
│         _tendGainsFromPositions();                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         uint256 stakedCvxCrv = cvxCrvRewardsPool.balanceOf(address(this));                                                                                                                                      │
│         if (stakedCvxCrv > 0) {                                                                                                                                                                                 │
│             cvxCrvRewardsPool.withdraw(stakedCvxCrv, true);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // 2. Swap cvxCRV tokens to CVX                                                                                                                                                                         │
│         uint256 cvxCrvBalance = cvxCrvToken.balanceOf(address(this));                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBalance > 0) {                                                                                                                                                                                │
│             _swapExactTokensForTokens(sushiswap, cvxCrv, cvxCrvBalance, getTokenSwapPath(cvxCrv, cvx));                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Track harvested + converted coin balance of want                                                                                                                                                     │
│         cvxHarvested = cvxToken.balanceOf(address(this));                                                                                                                                                       │
│         _processFee(cvx, cvxHarvested, performanceFeeGovernance, IController(controller).rewards());                                                                                                            │
│                                                                                                                                                                                                                 │
│         // 3. Stake all CVX                                                                                                                                                                                     │
│         if (cvxHarvested > 0) {                                                                                                                                                                                 │
│             cvxRewardsPool.stake(cvxToken.balanceOf(address(this)));                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Harvest(cvxHarvested, block.number);                                                                                                                                                               │
│         return cvxHarvested;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function __BaseStrategy_init(                                                                                                                                                                               │
│         address _governance,                                                                                                                                                                                    │
│         address _strategist,                                                                                                                                                                                    │
│         address _controller,                                                                                                                                                                                    │
│         address _keeper,                                                                                                                                                                                        │
│         address _guardian                                                                                                                                                                                       │
│     ) public initializer whenNotPaused {                                                                                                                                                                        │
│         __Pausable_init();                                                                                                                                                                                      │
│         governance = _governance;                                                                                                                                                                               │
│         strategist = _strategist;                                                                                                                                                                               │
│         keeper = _keeper;                                                                                                                                                                                       │
│         controller = _controller;                                                                                                                                                                               │
│         guardian = _guardian;                                                                                                                                                                                   │
│         withdrawalMaxDeviationThreshold = 50;                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setWithdrawalFee(uint256 _withdrawalFee) external {                                                                                                                                                │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(_withdrawalFee <= MAX_FEE, "base-strategy/excessive-withdrawal-fee");                                                                                                                           │
│         withdrawalFee = _withdrawalFee;                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist) external {                                                                                                                          │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(_performanceFeeStrategist <= MAX_FEE, "base-strategy/excessive-strategist-performance-fee");                                                                                                    │
│         performanceFeeStrategist = _performanceFeeStrategist;                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance) external {                                                                                                                          │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(_performanceFeeGovernance <= MAX_FEE, "base-strategy/excessive-governance-performance-fee");                                                                                                    │
│         performanceFeeGovernance = _performanceFeeGovernance;                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function setWithdrawalMaxDeviationThreshold(uint256 _threshold) external {                                                                                                                                  │
│         _onlyGovernance();                                                                                                                                                                                      │
│         require(_threshold <= MAX_FEE, "base-strategy/excessive-max-deviation-threshold");                                                                                                                      │
│         withdrawalMaxDeviationThreshold = _threshold;                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function earn(address _token, uint256 _amount) public {                                                                                                                                                     │
│         address _strategy = strategies[_token];                                                                                                                                                                 │
│         address _want = IStrategy(_strategy).want();                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _onlyApprovedForWant(_want);                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (_want != _token) {                                                                                                                                                                                  │
│             address converter = converters[_token][_want];                                                                                                                                                      │
│             IERC20Upgradeable(_token).safeTransfer(converter, _amount);                                                                                                                                         │
│             _amount = IConverter(converter).convert(_strategy);                                                                                                                                                 │
│             IERC20Upgradeable(_want).safeTransfer(_strategy, _amount);                                                                                                                                          │
│         } else {                                                                                                                                                                                                │
│             IERC20Upgradeable(_token).safeTransfer(_strategy, _amount);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         IStrategy(_strategy).deposit();                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distribute() external {                                                                                                                                                                            │
│         //claim rewards                                                                                                                                                                                         │
│         IConvexRewards(cvxStaking).getReward(false);                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         //convert any crv that was directly added                                                                                                                                                               │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             ICrvDepositor(crvDeposit).deposit(crvBal, true);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //distribute cvxcrv                                                                                                                                                                                     │
│         uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBal > 0) {                                                                                                                                                                                    │
│             uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);                                                                                                                            │
│             cvxCrvBal = cvxCrvBal.sub(incentiveAmount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             IERC20(cvxCrv).safeTransfer(msg.sender,incentiveAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             ICvxLocker(rewards).notifyRewardAmount(cvxCrv, cvxCrvBal);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(cvxCrv, cvxCrvBal);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function deposit() public virtual whenNotPaused {                                                                                                                                                           │
│         _onlyAuthorizedActorsOrController();                                                                                                                                                                    │
│         uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                                       │
│         if (_want > 0) {                                                                                                                                                                                        │
│             _deposit(_want);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         _postDeposit();                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll() external virtual whenNotPaused returns (uint256 balance) {                                                                                                                           │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _withdrawAll();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _transferToVault(IERC20Upgradeable(want).balanceOf(address(this)));                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function setStrategy(address _token, address _strategy) public {                                                                                                                                            │
│         _onlyGovernanceOrStrategist();                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         require(approvedStrategies[_token][_strategy] == true, "!approved");                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         address _current = strategies[_token];                                                                                                                                                                  │
│         if (_current != address(0)) {                                                                                                                                                                           │
│             IStrategy(_current).withdrawAll();                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         strategies[_token] = _strategy;                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function withdrawAll() external virtual whenNotPaused returns (uint256 balance) {                                                                                                                           │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _withdrawAll();                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _transferToVault(IERC20Upgradeable(want).balanceOf(address(this)));                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), "base-strategy/withdraw-exceed-max-deviation-threshold");                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function updateStakeRatio(uint256 _offset) internal {                                                                                                                                                       │
│         if (isShutdown) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //get balances                                                                                                                                                                                          │
│         uint256 local = stakingToken.balanceOf(address(this));                                                                                                                                                  │
│         uint256 staked = IStakingProxy(stakingProxy).getBalance();                                                                                                                                              │
│         uint256 total = local.add(staked);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (total == 0) return;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //current staked ratio                                                                                                                                                                                  │
│         uint256 ratio = staked.mul(denominator).div(total);                                                                                                                                                     │
│         //mean will be where we reset to if unbalanced                                                                                                                                                          │
│         uint256 mean = maximumStake.add(minimumStake).div(2);                                                                                                                                                   │
│         uint256 max = maximumStake.add(_offset);                                                                                                                                                                │
│         uint256 min = Math.min(minimumStake, minimumStake - _offset);                                                                                                                                           │
│         if (ratio > max) {                                                                                                                                                                                      │
│             //remove                                                                                                                                                                                            │
│             uint256 remove = staked.sub(total.mul(mean).div(denominator));                                                                                                                                      │
│             IStakingProxy(stakingProxy).withdraw(remove);                                                                                                                                                       │
│         } else if (ratio < min) {                                                                                                                                                                               │
│             //add                                                                                                                                                                                               │
│             uint256 increase = total.mul(mean).div(denominator).sub(staked);                                                                                                                                    │
│             stakingToken.safeTransfer(stakingProxy, increase);                                                                                                                                                  │
│             IStakingProxy(stakingProxy).stake();                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), "base-strategy/withdraw-exceed-max-deviation-threshold");                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _shares) internal virtual {                                                                                                                                                      │
│         uint256 r = (balance().mul(_shares)).div(totalSupply());                                                                                                                                                │
│         _burn(msg.sender, _shares);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Check balance                                                                                                                                                                                        │
│         uint256 b = token.balanceOf(address(this));                                                                                                                                                             │
│         if (b < r) {                                                                                                                                                                                            │
│             uint256 _toWithdraw = r.sub(b);                                                                                                                                                                     │
│             IController(controller).withdraw(address(token), _toWithdraw);                                                                                                                                      │
│             uint256 _after = token.balanceOf(address(this));                                                                                                                                                    │
│             uint256 _diff = _after.sub(b);                                                                                                                                                                      │
│             if (_diff < _toWithdraw) {                                                                                                                                                                          │
│                 r = b.add(_diff);                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         token.safeTransfer(msg.sender, r);                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), "base-strategy/withdraw-exceed-max-deviation-threshold");                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _shares) internal virtual {                                                                                                                                                      │
│         uint256 r = (balance().mul(_shares)).div(totalSupply());                                                                                                                                                │
│         _burn(msg.sender, _shares);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Check balance                                                                                                                                                                                        │
│         uint256 b = token.balanceOf(address(this));                                                                                                                                                             │
│         if (b < r) {                                                                                                                                                                                            │
│             uint256 _toWithdraw = r.sub(b);                                                                                                                                                                     │
│             IController(controller).withdraw(address(token), _toWithdraw);                                                                                                                                      │
│             uint256 _after = token.balanceOf(address(this));                                                                                                                                                    │
│             uint256 _diff = _after.sub(b);                                                                                                                                                                      │
│             if (_diff < _toWithdraw) {                                                                                                                                                                          │
│                 r = b.add(_diff);                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         token.safeTransfer(msg.sender, r);                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), "base-strategy/withdraw-exceed-max-deviation-threshold");                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external {                                                                                                                                                               │
│         require(msg.sender == rewards, "!auth");                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //unstake                                                                                                                                                                                               │
│         IConvexRewards(cvxStaking).withdraw(_amount, false);                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //withdraw cvx                                                                                                                                                                                          │
│         IERC20(cvx).safeTransfer(msg.sender, _amount);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 _amount) external virtual whenNotPaused {                                                                                                                                         │
│         _onlyController();                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Withdraw from strategy positions, typically taking from any idle want first.                                                                                                                         │
│         _withdrawSome(_amount);                                                                                                                                                                                 │
│         uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions                                                                                                                 │
│         // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold                                                                                           │
│         if (_postWithdraw < _amount) {                                                                                                                                                                          │
│             uint256 diff = _diff(_amount, _postWithdraw);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // Require that difference between expected and actual values is less than the deviation threshold percentage                                                                                       │
│             require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), "base-strategy/withdraw-exceed-max-deviation-threshold");                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Return the amount actually withdrawn if less than amount requested                                                                                                                                   │
│         uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Process withdrawal fee                                                                                                                                                                               │
│         uint256 _fee = _processWithdrawalFee(_toWithdraw);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Transfer remaining to Vault to handle withdrawal                                                                                                                                                     │
│         _transferToVault(_toWithdraw.sub(_fee));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawOther(address _asset) external virtual whenNotPaused returns (uint256 balance) {                                                                                                           │
│         _onlyController();                                                                                                                                                                                      │
│         _onlyNotProtectedTokens(_asset);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         balance = IERC20Upgradeable(_asset).balanceOf(address(this));                                                                                                                                           │
│         IERC20Upgradeable(_asset).safeTransfer(controller, balance);                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _addMaxLiquidity(                                                                                                                                                                                  │
│         address router,                                                                                                                                                                                         │
│         address token0,                                                                                                                                                                                         │
│         address token1                                                                                                                                                                                          │
│     ) internal {                                                                                                                                                                                                │
│         uint256 _token0Balance = IERC20Upgradeable(token0).balanceOf(address(this));                                                                                                                            │
│         uint256 _token1Balance = IERC20Upgradeable(token1).balanceOf(address(this));                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _safeApproveHelper(token0, router, _token0Balance);                                                                                                                                                     │
│         _safeApproveHelper(token1, router, _token1Balance);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         IUniswapRouterV2(router).addLiquidity(token0, token1, _token0Balance, _token1Balance, 0, 0, address(this), block.timestamp);                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _addMaxLiquidityEth(address router, address token0) internal {                                                                                                                                     │
│         uint256 _token0Balance = IERC20Upgradeable(token0).balanceOf(address(this));                                                                                                                            │
│         uint256 _ethBalance = address(this).balance;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _safeApproveHelper(token0, router, _token0Balance);                                                                                                                                                     │
│         IUniswapRouterV2(router).addLiquidityETH{value: address(this).balance}(token0, _token0Balance, 0, 0, address(this), block.timestamp);                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_postWithdraw": "Variable holding the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_fee": "Variable holding the calculated value/price of LP token"                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:29] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/deps/BaseStrategy.sol, current          tasks.py:260
                             function: withdraw, current vul: price-manipulation                                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "r": "Holds the calculated value of LP token to be withdrawn"                                                                                                                                           │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "b": "Holds the balance of the token contract"                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:30] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/deps/BaseStrategy.sol, current          tasks.py:359
                             function: withdraw, current vul: price-manipulation                                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 310, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the validation                                                                                                                    
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "bCVXToCVX": "Variable holding the market reserves/AMM price/exchange rate calculation"                                                                                                                 │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "valueInLocker": "Variable holding the calculated value/price of LP token"                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:31] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/veCVXStrategy.sol, current    tasks.py:260
                             function: balanceOfPool, current vul: price-manipulation                                                                                                                              
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "max": "Variable holding the market reserves/AMM price/exchange rate or the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "max": "Variable holding the calculated value/price of LP token"                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:32] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/veCVXStrategy.sol, current    tasks.py:260
                             function: _withdrawSome, current vul: price-manipulation                                                                                                                              
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "want": "Variable holding the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_fee": "Variable holding the calculated value/price of LP token"                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:33] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/veCVXStrategy.sol, current    tasks.py:359
                             function: _withdrawSome, current vul: price-manipulation                                                                                                                              
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "earnedReward": "Variable holding the calculated earned reward"                                                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "earned": "Variable holding the calculated earned amount of want"                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:34] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/veCVXStrategy.sol, current    tasks.py:260
                             function: harvest, current vul: price-manipulation                                                                                                                                    
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 209, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the `validate_description` validation                                                                                             
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balanceOfWant": "Token that is highly liquid balance",                                                                                                                                                 │
│         "balanceOfCVX": "CVX uninvested balance",                                                                                                                                                               │
│         "balanceInLock": "Locked CVX in the locker balance",                                                                                                                                                    │
│         "totalCVXBalance": "Total CVX balance calculation",                                                                                                                                                     │
│         "currentLockRatio": "Current lock ratio calculation",                                                                                                                                                   │
│         "newLockRatio": "New lock ratio calculation",                                                                                                                                                           │
│         "toWantRatio": "Amount to have in bCVX calculation",                                                                                                                                                    │
│         "toDeposit": "Amount to deposit into vault calculation",                                                                                                                                                │
│         "cvxToLock": "CVX to lock calculation",                                                                                                                                                                 │
│         "maxCVX": "Maximum CVX balance to lock calculation",                                                                                                                                                    │
│         "cvxLeft": "Remaining CVX balance to deposit into vault"                                                                                                                                                │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "cvxToLock": "Calculated CVX to lock"                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:35] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/veCVXStrategy.sol, current    tasks.py:359
                             function: harvest, current vul: price-manipulation                                                                                                                                    
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 310, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the validation                                                                                                                    
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function _processRewardsFees(uint256 _amount, address _token)                                                                                                                                               │
│         internal                                                                                                                                                                                                │
│         returns (uint256 governanceRewardsFee, uint256 strategistRewardsFee)                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         governanceRewardsFee = _processFee(                                                                                                                                                                     │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeGovernance,                                                                                                                                                                           │
│             IController(controller).rewards()                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         strategistRewardsFee = _processFee(                                                                                                                                                                     │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeStrategist,                                                                                                                                                                           │
│             strategist                                                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `governanceRewardsFee = _processFee(                                                                                                                                                                            │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeGovernance,                                                                                                                                                                           │
│             IController(controller).rewards()                                                                                                                                                                   │
│         );`                                                                                                                                                                                                     │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _processRewardsFees(uint256 _amount, address _token)                                                                                                                                               │
│         internal                                                                                                                                                                                                │
│         returns (uint256 governanceRewardsFee, uint256 strategistRewardsFee)                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         governanceRewardsFee = _processFee(                                                                                                                                                                     │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeGovernance,                                                                                                                                                                           │
│             IController(controller).rewards()                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         strategistRewardsFee = _processFee(                                                                                                                                                                     │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeStrategist,                                                                                                                                                                           │
│             strategist                                                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `governanceRewardsFee = _processFee(                                                                                                                                                                            │
│             _token,                                                                                                                                                                                             │
│             _amount,                                                                                                                                                                                            │
│             performanceFeeGovernance,                                                                                                                                                                           │
│             IController(controller).rewards()                                                                                                                                                                   │
│         );`                                                                                                                                                                                                     │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:37] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/veCVXStrategy.sol, current    tasks.py:260
                             function: _processRewardsFees, current vul: wrong-order-interest                                                                                                                      
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balanceOfWant": "Token that is highly liquid balance",                                                                                                                                                 │
│         "balanceOfCVX": "CVX uninvested balance",                                                                                                                                                               │
│         "balanceInLock": "Locked CVX in the locker balance",                                                                                                                                                    │
│         "totalCVXBalance": "Total CVX balance calculation",                                                                                                                                                     │
│         "currentLockRatio": "Current lock ratio calculation",                                                                                                                                                   │
│         "newLockRatio": "New lock ratio calculation",                                                                                                                                                           │
│         "toWantRatio": "Amount to have in bCVX calculation",                                                                                                                                                    │
│         "toDeposit": "Amount to deposit into vault calculation",                                                                                                                                                │
│         "cvxToLock": "CVX to lock calculation",                                                                                                                                                                 │
│         "maxCVX": "Maximum CVX balance calculation",                                                                                                                                                            │
│         "cvxLeft": "Remaining CVX balance to deposit into vault"                                                                                                                                                │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "cvxToLock": "Calculated CVX to lock"                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:38] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/veCVXStrategy.sol, current    tasks.py:260
                             function: manualRebalance, current vul: price-manipulation                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 209, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the `validate_description` validation                                                                                             
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_balance": "Variable holding the token balance calculation"                                                                                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "expected": "Variable holding the calculated value/price of LP token"                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:39] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/deps/Controller.sol, current  tasks.py:260
                             function: getExpectedReturn, current vul: price-manipulation                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_balance": "Variable holding the token balance of the strategy"                                                                                                                                        │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "expected": "Variable holding the calculated expected return"                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:40] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/deps/Controller.sol, current  tasks.py:359
                             function: getExpectedReturn, current vul: price-manipulation                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 310, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the validation                                                                                                                    
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "totalSupply()": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                        │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:41] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/deps/SettV3.sol, current      tasks.py:260
                             function: _deposit, current vul: first-deposit                                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_want": "Holds the value of total minted share or amount"                                                                                                                                              │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_want": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                                │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_want": "Holds the value of the deposit/mint/add amount"                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:42] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/deps/SettV3.sol, current      tasks.py:359
                             function: _deposit, current vul: first-deposit                                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_want": "Holds the value of total minted share or amount"                                                                                                                                              │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_want": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                                │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_want": "Holds the value of the deposit/mint/add amount"                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:43] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/deps/SettV3.sol, current      tasks.py:359
                             function: _deposit, current vul: first-deposit                                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "local": "Variable holding the balance of the staking token in the contract",                                                                                                                               │
│     "staked": "Variable holding the balance of staked tokens from the staking proxy contract",                                                                                                                  │
│     "total": "Variable holding the total balance of staking token and staked tokens"                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "ratio": "Variable holding the calculated staked ratio"                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:44] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/locker/CvxLocker.sol, current tasks.py:260
                             function: updateStakeRatio, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 209, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the `validate_description` validation                                                                                             
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function _notifyReward(address _rewardsToken, uint256 _reward) internal {                                                                                                                                   │
│         Reward storage rdata = rewardData[_rewardsToken];                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             rdata.rewardRate = _reward.div(rewardsDuration).to208();                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining =                                                                                                                                                                                 │
│                 uint256(rdata.periodFinish).sub(block.timestamp);                                                                                                                                               │
│             uint256 leftover = remaining.mul(rdata.rewardRate);                                                                                                                                                 │
│             rdata.rewardRate = _reward                                                                                                                                                                          │
│                 .add(leftover)                                                                                                                                                                                  │
│                 .div(rewardsDuration)                                                                                                                                                                           │
│                 .to208();                                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rdata.lastUpdateTime = block.timestamp.to40();                                                                                                                                                          │
│         rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `rdata.rewardRate = _reward.div(rewardsDuration).to208();`.                                                                                      │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _notifyReward(address _rewardsToken, uint256 _reward) internal {                                                                                                                                   │
│         Reward storage rdata = rewardData[_rewardsToken];                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             rdata.rewardRate = _reward.div(rewardsDuration).to208();                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining =                                                                                                                                                                                 │
│                 uint256(rdata.periodFinish).sub(block.timestamp);                                                                                                                                               │
│             uint256 leftover = remaining.mul(rdata.rewardRate);                                                                                                                                                 │
│             rdata.rewardRate = _reward                                                                                                                                                                          │
│                 .add(leftover)                                                                                                                                                                                  │
│                 .div(rewardsDuration)                                                                                                                                                                           │
│                 .to208();                                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rdata.lastUpdateTime = block.timestamp.to40();                                                                                                                                                          │
│         rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward is `rdata.rewardRate = _reward.div(rewardsDuration).to208();`.                                                       │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:46] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/veCVX/contracts/locker/CvxLocker.sol, current tasks.py:260
                             function: _notifyReward, current vul: wrong-order-interest                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "want": "Variable holding the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_fee": "Variable holding the calculated value/price of LP token"                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:06:47] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/bCVX/deps/BaseStrategy.sol, current function: tasks.py:260
                             withdraw, current vul: price-manipulation                                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "r": "Variable holding the calculated value of LP token to withdraw"                                                                                                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "b": "Variable holding the balance of the token contract"                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-09-bvecvx-main/bCVX/deps/BaseStrategy.sol, current function: tasks.py:359
                             withdraw, current vul: price-manipulation                                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 310, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the validation                                                                                                                    
                                                                                                                                                                                                                   
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                  Summary                  
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value            ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━┩
│ Files                │ 55               │
│ Contracts            │ 67               │
│ Functions            │ 109              │
│ Lines of Code        │ 5311             │
│ Used Time            │ 76.8842146396637 │
│ Estimated Cost (USD) │ 0.0788365        │
└──────────────────────┴──────────────────┘
