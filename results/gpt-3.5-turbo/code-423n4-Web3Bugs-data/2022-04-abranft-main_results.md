

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[19:42:43] Loaded 10 rules                                                                                                                                                                             tasks.py:119
[12/08/24 19:42:43] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main)              subprocess.py:41
[12/08/24 19:47:13] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_42_43_389Z-debug-0.log                                                              
                    INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main)     subprocess.py:41
[12/08/24 19:47:14] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_47_13_765Z-debug-0.log                                                              
[12/08/24 19:47:15] INFO     CryticCompile: Problem executing hardhat: npm warn exec The following package was not found and will be installed: hardhat@2.22.17                                      hardhat.py:327
                             npm error Invalid Version:                                                                                                                                                            
                             npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_47_14_896Z-debug-0.log                                                                      
                                                                                                                                                                                                                   
                    INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main)    subprocess.py:41
[12/08/24 19:47:16] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_47_15_945Z-debug-0.log                                                              
[19:47:16] Traceback (most recent call last):                                                                                                                                                          tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                     
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                    
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                    
               self._compile(**kwargs)                                                                                                                                                                             
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                    
               self._platform.compile(self, **kwargs)                                                                                                                                                              
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 183, in compile                                                   
               hardhat_like_parsing(crytic_compile, self._target, build_directory, hardhat_working_dir)                                                                                                            
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 52, in hardhat_like_parsing                                       
               raise InvalidCompilation(txt)                                                                                                                                                                       
           crytic_compile.platform.exceptions.InvalidCompilation: Compilation failed. Can you run build command?                                                                                                   
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/artifacts/build-info is not a directory.                                                        
                                                                                                                                                                                                                   
           During handling of the above exception, another exception occurred:                                                                                                                                     
                                                                                                                                                                                                                   
           Traceback (most recent call last):                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                         
               falcon_instance = compile_project(source_dir)                                                                                                                                                       
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                    
               return falcon.Falcon(abs_path)                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                     
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                               
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                     
           Compilation failed. Can you run build command?                                                                                                                                                          
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/artifacts/build-info is not a directory.                                                        
                                                                                                                                                                                                                   
           Compile failed.                                                                                                                                                                             tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                  tasks.py:128
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {                                                                                                                          │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         if (loan.status == LOAN_OUTSTANDING) {                                                                                                                                                                  │
│             // The lender can change terms so long as the changes are strictly                                                                                                                                  │
│             // the same or better for the borrower:                                                                                                                                                             │
│             require(msg.sender == loan.lender, "NFTPair: not the lender");                                                                                                                                      │
│             TokenLoanParams memory cur = tokenLoanParams;                                                                                                                                                       │
│             require(                                                                                                                                                                                            │
│                 params.duration >= cur.duration && params.valuation <= cur.valuation && params.annualInterestBPS <= cur.annualInterestBPS,                                                                      │
│                 "NFTPair: worse params"                                                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         } else if (loan.status == LOAN_REQUESTED) {                                                                                                                                                             │
│             // The borrower has already deposited the collateral and can                                                                                                                                        │
│             // change whatever they like                                                                                                                                                                        │
│             require(msg.sender == loan.borrower, "NFTPair: not the borrower");                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             // The loan has not been taken out yet; the borrower needs to                                                                                                                                       │
│             // provide collateral.                                                                                                                                                                              │
│             revert("NFTPair: no collateral");                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         tokenLoanParams = params;                                                                                                                                                                               │
│         emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS);                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _requestLoan(                                                                                                                                                                                      │
│         address collateralProvider,                                                                                                                                                                             │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         address to,                                                                                                                                                                                             │
│         bool skim                                                                                                                                                                                               │
│     ) private {                                                                                                                                                                                                 │
│         // Edge case: valuation can be zero. That effectively gifts the NFT and                                                                                                                                 │
│         // is therefore a bad idea, but does not break the contract.                                                                                                                                            │
│         require(tokenLoan.status == LOAN_INITIAL, "NFTPair: loan exists");                                                                                                                                      │
│         if (skim) {                                                                                                                                                                                             │
│             require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");                                                                                                                      │
│         } else {                                                                                                                                                                                                │
│             collateral.transferFrom(collateralProvider, address(this), tokenId);                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         TokenLoan memory loan;                                                                                                                                                                                  │
│         loan.borrower = to;                                                                                                                                                                                     │
│         loan.status = LOAN_REQUESTED;                                                                                                                                                                           │
│         tokenLoan = loan;                                                                                                                                                                                       │
│         tokenLoanParams = params;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS,                                                                                                                                         │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function takeCollateralAndLend(                                                                                                                                                                             │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address borrower,                                                                                                                                                                                       │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimFunds,                                                                                                                                                                                         │
│         uint256 deadline,                                                                                                                                                                                       │
│         uint8 v,                                                                                                                                                                                                │
│         bytes32 r,                                                                                                                                                                                              │
│         bytes32 s                                                                                                                                                                                               │
│     ) public {                                                                                                                                                                                                  │
│         require(block.timestamp <= deadline, "NFTPair: signature expired");                                                                                                                                     │
│         uint256 nonce = nonces++;                                                                                                                                                                               │
│         bytes32 dataHash = keccak256(                                                                                                                                                                           │
│             abi.encode(                                                                                                                                                                                         │
│                 BORROW_SIGNATURE_HASH,                                                                                                                                                                          │
│                 address(this),                                                                                                                                                                                  │
│                 tokenId,                                                                                                                                                                                        │
│                 params.valuation,                                                                                                                                                                               │
│                 params.duration,                                                                                                                                                                                │
│                 params.annualInterestBPS,                                                                                                                                                                       │
│                 nonce,                                                                                                                                                                                          │
│                 deadline                                                                                                                                                                                        │
│             )                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, "NFTPair: signature invalid");                                                                                                            │
│         _requestLoan(borrower, tokenId, params, borrower, false);                                                                                                                                               │
│         _lend(msg.sender, tokenId, params, skimFunds);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS,                                                                                                                                         │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function requestAndBorrow(                                                                                                                                                                                  │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address lender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimCollateral,                                                                                                                                                                                    │
│         bool anyTokenId,                                                                                                                                                                                        │
│         SignatureParams memory signature                                                                                                                                                                        │
│     ) public {                                                                                                                                                                                                  │
│         if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {                                                                                                                       │
│             require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             require(block.timestamp <= signature.deadline, "NFTPair: signature expired");                                                                                                                       │
│             uint256 nonce = nonces++;                                                                                                                                                                           │
│             bytes32 dataHash = keccak256(                                                                                                                                                                       │
│                 abi.encode(                                                                                                                                                                                     │
│                     LEND_SIGNATURE_HASH,                                                                                                                                                                        │
│                     address(this),                                                                                                                                                                              │
│                     anyTokenId ? 0 : tokenId,                                                                                                                                                                   │
│                     anyTokenId,                                                                                                                                                                                 │
│                     params.valuation,                                                                                                                                                                           │
│                     params.duration,                                                                                                                                                                            │
│                     params.annualInterestBPS,                                                                                                                                                                   │
│                     params.ltvBPS,                                                                                                                                                                              │
│                     params.oracle,                                                                                                                                                                              │
│                     nonce,                                                                                                                                                                                      │
│                     signature.deadline                                                                                                                                                                          │
│                 )                                                                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│             require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");                                                                            │
│         }                                                                                                                                                                                                       │
│         _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);                                                                                                                                   │
│         _lend(lender, tokenId, params, false);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS,                                                                                                                                         │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function takeCollateralAndLend(                                                                                                                                                                             │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address borrower,                                                                                                                                                                                       │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimFunds,                                                                                                                                                                                         │
│         SignatureParams memory signature                                                                                                                                                                        │
│     ) public {                                                                                                                                                                                                  │
│         require(block.timestamp <= signature.deadline, "NFTPair: signature expired");                                                                                                                           │
│         uint256 nonce = nonces++;                                                                                                                                                                               │
│         bytes32 dataHash = keccak256(                                                                                                                                                                           │
│             abi.encode(                                                                                                                                                                                         │
│                 BORROW_SIGNATURE_HASH,                                                                                                                                                                          │
│                 address(this),                                                                                                                                                                                  │
│                 tokenId,                                                                                                                                                                                        │
│                 params.valuation,                                                                                                                                                                               │
│                 params.duration,                                                                                                                                                                                │
│                 params.annualInterestBPS,                                                                                                                                                                       │
│                 params.ltvBPS,                                                                                                                                                                                  │
│                 params.oracle,                                                                                                                                                                                  │
│                 nonce,                                                                                                                                                                                          │
│                 signature.deadline                                                                                                                                                                              │
│             )                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");                                                                              │
│         _requestLoan(borrower, tokenId, params, borrower, false);                                                                                                                                               │
│         _lend(msg.sender, tokenId, params, skimFunds);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS,                                                                                                                                         │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function requestAndBorrow(                                                                                                                                                                                  │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address lender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimCollateral,                                                                                                                                                                                    │
│         bool anyTokenId,                                                                                                                                                                                        │
│         uint256 deadline,                                                                                                                                                                                       │
│         uint8 v,                                                                                                                                                                                                │
│         bytes32 r,                                                                                                                                                                                              │
│         bytes32 s                                                                                                                                                                                               │
│     ) public {                                                                                                                                                                                                  │
│         if (v == 0 && r == bytes32(0) && s == bytes32(0)) {                                                                                                                                                     │
│             require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             require(block.timestamp <= deadline, "NFTPair: signature expired");                                                                                                                                 │
│             uint256 nonce = nonces++;                                                                                                                                                                           │
│             bytes32 dataHash = keccak256(                                                                                                                                                                       │
│                 abi.encode(                                                                                                                                                                                     │
│                     LEND_SIGNATURE_HASH,                                                                                                                                                                        │
│                     address(this),                                                                                                                                                                              │
│                     anyTokenId ? 0 : tokenId,                                                                                                                                                                   │
│                     anyTokenId,                                                                                                                                                                                 │
│                     params.valuation,                                                                                                                                                                           │
│                     params.duration,                                                                                                                                                                            │
│                     params.annualInterestBPS,                                                                                                                                                                   │
│                     nonce,                                                                                                                                                                                      │
│                     deadline                                                                                                                                                                                    │
│                 )                                                                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│             require(ecrecover(_getDigest(dataHash), v, r, s) == lender, "NFTPair: signature invalid");                                                                                                          │
│         }                                                                                                                                                                                                       │
│         _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);                                                                                                                                   │
│         _lend(lender, tokenId, params, false);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS,                                                                                                                                         │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function requestAndBorrow(                                                                                                                                                                                  │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address lender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimCollateral,                                                                                                                                                                                    │
│         bool anyTokenId,                                                                                                                                                                                        │
│         uint256 deadline,                                                                                                                                                                                       │
│         uint8 v,                                                                                                                                                                                                │
│         bytes32 r,                                                                                                                                                                                              │
│         bytes32 s                                                                                                                                                                                               │
│     ) public {                                                                                                                                                                                                  │
│         if (v == 0 && r == bytes32(0) && s == bytes32(0)) {                                                                                                                                                     │
│             require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             require(block.timestamp <= deadline, "NFTPair: signature expired");                                                                                                                                 │
│             uint256 nonce = nonces++;                                                                                                                                                                           │
│             bytes32 dataHash = keccak256(                                                                                                                                                                       │
│                 abi.encode(                                                                                                                                                                                     │
│                     LEND_SIGNATURE_HASH,                                                                                                                                                                        │
│                     address(this),                                                                                                                                                                              │
│                     anyTokenId ? 0 : tokenId,                                                                                                                                                                   │
│                     anyTokenId,                                                                                                                                                                                 │
│                     params.valuation,                                                                                                                                                                           │
│                     params.duration,                                                                                                                                                                            │
│                     params.annualInterestBPS,                                                                                                                                                                   │
│                     nonce,                                                                                                                                                                                      │
│                     deadline                                                                                                                                                                                    │
│                 )                                                                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│             require(ecrecover(_getDigest(dataHash), v, r, s) == lender, "NFTPair: signature invalid");                                                                                                          │
│         }                                                                                                                                                                                                       │
│         _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);                                                                                                                                   │
│         _lend(lender, tokenId, params, false);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function takeCollateralAndLend(                                                                                                                                                                             │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address borrower,                                                                                                                                                                                       │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimFunds,                                                                                                                                                                                         │
│         uint256 deadline,                                                                                                                                                                                       │
│         uint8 v,                                                                                                                                                                                                │
│         bytes32 r,                                                                                                                                                                                              │
│         bytes32 s                                                                                                                                                                                               │
│     ) public {                                                                                                                                                                                                  │
│         require(block.timestamp <= deadline, "NFTPair: signature expired");                                                                                                                                     │
│         uint256 nonce = nonces++;                                                                                                                                                                               │
│         bytes32 dataHash = keccak256(                                                                                                                                                                           │
│             abi.encode(                                                                                                                                                                                         │
│                 BORROW_SIGNATURE_HASH,                                                                                                                                                                          │
│                 address(this),                                                                                                                                                                                  │
│                 tokenId,                                                                                                                                                                                        │
│                 params.valuation,                                                                                                                                                                               │
│                 params.duration,                                                                                                                                                                                │
│                 params.annualInterestBPS,                                                                                                                                                                       │
│                 nonce,                                                                                                                                                                                          │
│                 deadline                                                                                                                                                                                        │
│             )                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, "NFTPair: signature invalid");                                                                                                            │
│         _requestLoan(borrower, tokenId, params, borrower, false);                                                                                                                                               │
│         _lend(msg.sender, tokenId, params, skimFunds);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function calculateInterest(                                                                                                                                                                                 │
│         uint256 principal,                                                                                                                                                                                      │
│         uint64 t,                                                                                                                                                                                               │
│         uint16 aprBPS                                                                                                                                                                                           │
│     ) public pure returns (uint256 interest) {                                                                                                                                                                  │
│         // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // We calculate                                                                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         //  ----- n                                       ----- n                                                                                                                                               │
│         //   \           principal * (t * aprBPS)^k        \                                                                                                                                                    │
│         //    )          --------------------------   =:    )          term_k                                                                                                                                   │
│         //   /                k! * YEAR_BPS^k              /                                                                                                                                                    │
│         //  ----- k = 1                                   ----- k = 1                                                                                                                                           │
│         //                                                                                                                                                                                                      │
│         // which approaches, but never exceeds the "theoretical" result,                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         // as n goes to infinity. We use the fact that                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)                                                                                                                                          │
│         //      term_k = ---------------------------------------------                                                                                                                                          │
│         //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         //                             t * aprBPS                                                                                                                                                               │
│         //             = term_{k-1} * ------------                          (*)                                                                                                                                 │
│         //                            k * YEAR_BPS                                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         // to calculate the terms one by one. The principal affords us the                                                                                                                                      │
│         // precision to carry out the division without resorting to fixed-point                                                                                                                                 │
│         // math. Any rounding error is downward, which we consider acceptable.                                                                                                                                  │
│         //                                                                                                                                                                                                      │
│         // Since all numbers involved are positive, each term is certainly                                                                                                                                      │
│         // bounded above by M. From (*) we see that any intermediate results                                                                                                                                    │
│         // are at most                                                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //                      denom_k := k * YEAR_BPS.                                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,                                                                                                                                    │
│         // which proves that all calculations will certainly not overflow if M                                                                                                                                  │
│         // fits in 128 bits.                                                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // If M does not fit, then the intermediate results for some term may                                                                                                                                   │
│         // eventually overflow, but this cannot happen at the first term, and                                                                                                                                   │
│         // neither can the total overflow because it uses checked math.                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         // This constitutes a guarantee of specified behavior when M >= 2^128.                                                                                                                                  │
│         uint256 x = uint256(t) * aprBPS;                                                                                                                                                                        │
│         uint256 term_k = (principal * x) / YEAR_BPS;                                                                                                                                                            │
│         uint256 denom_k = YEAR_BPS;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         interest = term_k;                                                                                                                                                                                      │
│         for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {                                                                                                                                                │
│             denom_k += YEAR_BPS;                                                                                                                                                                                │
│             term_k = (term_k * x) / denom_k;                                                                                                                                                                    │
│             interest = interest.add(term_k); // <- Only overflow check we need                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (interest >= 2**128) {                                                                                                                                                                               │
│             revert();                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function calculateInterest(                                                                                                                                                                                 │
│         uint256 principal,                                                                                                                                                                                      │
│         uint64 t,                                                                                                                                                                                               │
│         uint16 aprBPS                                                                                                                                                                                           │
│     ) public pure returns (uint256 interest) {                                                                                                                                                                  │
│         // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // We calculate                                                                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         //  ----- n                                       ----- n                                                                                                                                               │
│         //   \           principal * (t * aprBPS)^k        \                                                                                                                                                    │
│         //    )          --------------------------   =:    )          term_k                                                                                                                                   │
│         //   /                k! * YEAR_BPS^k              /                                                                                                                                                    │
│         //  ----- k = 1                                   ----- k = 1                                                                                                                                           │
│         //                                                                                                                                                                                                      │
│         // which approaches, but never exceeds the "theoretical" result,                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         // as n goes to infinity. We use the fact that                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)                                                                                                                                          │
│         //      term_k = ---------------------------------------------                                                                                                                                          │
│         //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         //                             t * aprBPS                                                                                                                                                               │
│         //             = term_{k-1} * ------------                          (*)                                                                                                                                 │
│         //                            k * YEAR_BPS                                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         // to calculate the terms one by one. The principal affords us the                                                                                                                                      │
│         // precision to carry out the division without resorting to fixed-point                                                                                                                                 │
│         // math. Any rounding error is downward, which we consider acceptable.                                                                                                                                  │
│         //                                                                                                                                                                                                      │
│         // Since all numbers involved are positive, each term is certainly                                                                                                                                      │
│         // bounded above by M. From (*) we see that any intermediate results                                                                                                                                    │
│         // are at most                                                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //                      denom_k := k * YEAR_BPS.                                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,                                                                                                                                    │
│         // which proves that all calculations will certainly not overflow if M                                                                                                                                  │
│         // fits in 128 bits.                                                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // If M does not fit, then the intermediate results for some term may                                                                                                                                   │
│         // eventually overflow, but this cannot happen at the first term, and                                                                                                                                   │
│         // neither can the total overflow because it uses checked math.                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         // This constitutes a guarantee of specified behavior when M >= 2^128.                                                                                                                                  │
│         uint256 x = uint256(t) * aprBPS;                                                                                                                                                                        │
│         uint256 term_k = (principal * x) / YEAR_BPS;                                                                                                                                                            │
│         uint256 denom_k = YEAR_BPS;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         interest = term_k;                                                                                                                                                                                      │
│         for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {                                                                                                                                                │
│             denom_k += YEAR_BPS;                                                                                                                                                                                │
│             term_k = (term_k * x) / denom_k;                                                                                                                                                                    │
│             interest = interest.add(term_k); // <- Only overflow check we need                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (interest >= 2**128) {                                                                                                                                                                               │
│             revert();                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function cook(                                                                                                                                                                                              │
│         uint8[] calldata actions,                                                                                                                                                                               │
│         uint256[] calldata values,                                                                                                                                                                              │
│         bytes[] calldata datas                                                                                                                                                                                  │
│     ) external payable returns (uint256 value1, uint256 value2) {                                                                                                                                               │
│         for (uint256 i = 0; i < actions.length; i++) {                                                                                                                                                          │
│             uint8 action = actions;                                                                                                                                                                             │
│             if (action == ACTION_REPAY) {                                                                                                                                                                       │
│                 (uint256 tokenId, bool skim) = abi.decode(datas, (uint256, bool));                                                                                                                              │
│                 repay(tokenId, skim);                                                                                                                                                                           │
│             } else if (action == ACTION_REMOVE_COLLATERAL) {                                                                                                                                                    │
│                 (uint256 tokenId, address to) = abi.decode(datas, (uint256, address));                                                                                                                          │
│                 removeCollateral(tokenId, to);                                                                                                                                                                  │
│             } else if (action == ACTION_REQUEST_LOAN) {                                                                                                                                                         │
│                 (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                                                                                                           │
│                     datas,                                                                                                                                                                                      │
│                     (uint256, TokenLoanParams, address, bool)                                                                                                                                                   │
│                 );                                                                                                                                                                                              │
│                 requestLoan(tokenId, params, to, skim);                                                                                                                                                         │
│             } else if (action == ACTION_LEND) {                                                                                                                                                                 │
│                 (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas, (uint256, TokenLoanParams, bool));                                                                              │
│                 lend(tokenId, params, skim);                                                                                                                                                                    │
│             } else if (action == ACTION_BENTO_SETAPPROVAL) {                                                                                                                                                    │
│                 (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                                                                                             │
│                     datas,                                                                                                                                                                                      │
│                     (address, address, bool, uint8, bytes32, bytes32)                                                                                                                                           │
│                 );                                                                                                                                                                                              │
│                 bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);                                                                                                                   │
│             } else if (action == ACTION_BENTO_DEPOSIT) {                                                                                                                                                        │
│                 (value1, value2) = _bentoDeposit(datas, values, value1, value2);                                                                                                                                │
│             } else if (action == ACTION_BENTO_WITHDRAW) {                                                                                                                                                       │
│                 (value1, value2) = _bentoWithdraw(datas, value1, value2);                                                                                                                                       │
│             } else if (action == ACTION_BENTO_TRANSFER) {                                                                                                                                                       │
│                 (IERC20 token, address to, int256 share) = abi.decode(datas, (IERC20, address, int256));                                                                                                        │
│                 bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));                                                                                                                          │
│             } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {                                                                                                                                              │
│                 (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas, (IERC20, address[], uint256[]));                                                                              │
│                 bentoBox.transferMultiple(token, msg.sender, tos, shares);                                                                                                                                      │
│             } else if (action == ACTION_CALL) {                                                                                                                                                                 │
│                 (bytes memory returnData, uint8 returnValues) = _call(values, datas, value1, value2);                                                                                                           │
│                                                                                                                                                                                                                 │
│                 if (returnValues == 1) {                                                                                                                                                                        │
│                     (value1) = abi.decode(returnData, (uint256));                                                                                                                                               │
│                 } else if (returnValues == 2) {                                                                                                                                                                 │
│                     (value1, value2) = abi.decode(returnData, (uint256, uint256));                                                                                                                              │
│                 }                                                                                                                                                                                               │
│             } else if (action == ACTION_REQUEST_AND_BORROW) {                                                                                                                                                   │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address lender,                                                                                                                                                                             │
│                     address recipient,                                                                                                                                                                          │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimCollateral,                                                                                                                                                                        │
│                     bool anyTokenId,                                                                                                                                                                            │
│                     uint256 deadline,                                                                                                                                                                           │
│                     uint8 v,                                                                                                                                                                                    │
│                     bytes32 r,                                                                                                                                                                                  │
│                     bytes32 s                                                                                                                                                                                   │
│                 ) = abi.decode(datas, (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));                                                                              │
│                 requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);                                                                                            │
│             } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {                                                                                                                                             │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address borrower,                                                                                                                                                                           │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimFunds,                                                                                                                                                                             │
│                     uint256 deadline,                                                                                                                                                                           │
│                     uint8 v,                                                                                                                                                                                    │
│                     bytes32 r,                                                                                                                                                                                  │
│                     bytes32 s                                                                                                                                                                                   │
│                 ) = abi.decode(datas, (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));                                                                                             │
│                 takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);                                                                                                                 │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function cook(                                                                                                                                                                                              │
│         uint8[] calldata actions,                                                                                                                                                                               │
│         uint256[] calldata values,                                                                                                                                                                              │
│         bytes[] calldata datas                                                                                                                                                                                  │
│     ) external payable returns (uint256 value1, uint256 value2) {                                                                                                                                               │
│         for (uint256 i = 0; i < actions.length; i++) {                                                                                                                                                          │
│             uint8 action = actions;                                                                                                                                                                             │
│             if (action == ACTION_REPAY) {                                                                                                                                                                       │
│                 (uint256 tokenId, bool skim) = abi.decode(datas, (uint256, bool));                                                                                                                              │
│                 repay(tokenId, skim);                                                                                                                                                                           │
│             } else if (action == ACTION_REMOVE_COLLATERAL) {                                                                                                                                                    │
│                 (uint256 tokenId, address to) = abi.decode(datas, (uint256, address));                                                                                                                          │
│                 removeCollateral(tokenId, to);                                                                                                                                                                  │
│             } else if (action == ACTION_REQUEST_LOAN) {                                                                                                                                                         │
│                 (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                                                                                                           │
│                     datas,                                                                                                                                                                                      │
│                     (uint256, TokenLoanParams, address, bool)                                                                                                                                                   │
│                 );                                                                                                                                                                                              │
│                 requestLoan(tokenId, params, to, skim);                                                                                                                                                         │
│             } else if (action == ACTION_LEND) {                                                                                                                                                                 │
│                 (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas, (uint256, TokenLoanParams, bool));                                                                              │
│                 lend(tokenId, params, skim);                                                                                                                                                                    │
│             } else if (action == ACTION_BENTO_SETAPPROVAL) {                                                                                                                                                    │
│                 (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                                                                                             │
│                     datas,                                                                                                                                                                                      │
│                     (address, address, bool, uint8, bytes32, bytes32)                                                                                                                                           │
│                 );                                                                                                                                                                                              │
│                 bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);                                                                                                                   │
│             } else if (action == ACTION_BENTO_DEPOSIT) {                                                                                                                                                        │
│                 (value1, value2) = _bentoDeposit(datas, values, value1, value2);                                                                                                                                │
│             } else if (action == ACTION_BENTO_WITHDRAW) {                                                                                                                                                       │
│                 (value1, value2) = _bentoWithdraw(datas, value1, value2);                                                                                                                                       │
│             } else if (action == ACTION_BENTO_TRANSFER) {                                                                                                                                                       │
│                 (IERC20 token, address to, int256 share) = abi.decode(datas, (IERC20, address, int256));                                                                                                        │
│                 bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));                                                                                                                          │
│             } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {                                                                                                                                              │
│                 (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas, (IERC20, address[], uint256[]));                                                                              │
│                 bentoBox.transferMultiple(token, msg.sender, tos, shares);                                                                                                                                      │
│             } else if (action == ACTION_CALL) {                                                                                                                                                                 │
│                 (bytes memory returnData, uint8 returnValues) = _call(values, datas, value1, value2);                                                                                                           │
│                                                                                                                                                                                                                 │
│                 if (returnValues == 1) {                                                                                                                                                                        │
│                     (value1) = abi.decode(returnData, (uint256));                                                                                                                                               │
│                 } else if (returnValues == 2) {                                                                                                                                                                 │
│                     (value1, value2) = abi.decode(returnData, (uint256, uint256));                                                                                                                              │
│                 }                                                                                                                                                                                               │
│             } else if (action == ACTION_REQUEST_AND_BORROW) {                                                                                                                                                   │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address lender,                                                                                                                                                                             │
│                     address recipient,                                                                                                                                                                          │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimCollateral,                                                                                                                                                                        │
│                     bool anyTokenId,                                                                                                                                                                            │
│                     SignatureParams memory signature                                                                                                                                                            │
│                 ) = abi.decode(datas, (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));                                                                                               │
│                 requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);                                                                                                    │
│             } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {                                                                                                                                             │
│                 (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                                                                      │
│                     .decode(datas, (uint256, address, TokenLoanParams, bool, SignatureParams));                                                                                                                 │
│                 takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);                                                                                                                         │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer,                                                                                                                           │
│ Code:                                                                                                                                                                                                           │
│     function cook(                                                                                                                                                                                              │
│         uint8[] calldata actions,                                                                                                                                                                               │
│         uint256[] calldata values,                                                                                                                                                                              │
│         bytes[] calldata datas                                                                                                                                                                                  │
│     ) external payable returns (uint256 value1, uint256 value2) {                                                                                                                                               │
│         for (uint256 i = 0; i < actions.length; i++) {                                                                                                                                                          │
│             uint8 action = actions;                                                                                                                                                                             │
│             if (action == ACTION_REPAY) {                                                                                                                                                                       │
│                 (uint256 tokenId, bool skim) = abi.decode(datas, (uint256, bool));                                                                                                                              │
│                 repay(tokenId, skim);                                                                                                                                                                           │
│             } else if (action == ACTION_REMOVE_COLLATERAL) {                                                                                                                                                    │
│                 (uint256 tokenId, address to) = abi.decode(datas, (uint256, address));                                                                                                                          │
│                 removeCollateral(tokenId, to);                                                                                                                                                                  │
│             } else if (action == ACTION_REQUEST_LOAN) {                                                                                                                                                         │
│                 (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                                                                                                           │
│                     datas,                                                                                                                                                                                      │
│                     (uint256, TokenLoanParams, address, bool)                                                                                                                                                   │
│                 );                                                                                                                                                                                              │
│                 requestLoan(tokenId, params, to, skim);                                                                                                                                                         │
│             } else if (action == ACTION_LEND) {                                                                                                                                                                 │
│                 (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas, (uint256, TokenLoanParams, bool));                                                                              │
│                 lend(tokenId, params, skim);                                                                                                                                                                    │
│             } else if (action == ACTION_BENTO_SETAPPROVAL) {                                                                                                                                                    │
│                 (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                                                                                             │
│                     datas,                                                                                                                                                                                      │
│                     (address, address, bool, uint8, bytes32, bytes32)                                                                                                                                           │
│                 );                                                                                                                                                                                              │
│                 bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);                                                                                                                   │
│             } else if (action == ACTION_BENTO_DEPOSIT) {                                                                                                                                                        │
│                 (value1, value2) = _bentoDeposit(datas, values, value1, value2);                                                                                                                                │
│             } else if (action == ACTION_BENTO_WITHDRAW) {                                                                                                                                                       │
│                 (value1, value2) = _bentoWithdraw(datas, value1, value2);                                                                                                                                       │
│             } else if (action == ACTION_BENTO_TRANSFER) {                                                                                                                                                       │
│                 (IERC20 token, address to, int256 share) = abi.decode(datas, (IERC20, address, int256));                                                                                                        │
│                 bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));                                                                                                                          │
│             } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {                                                                                                                                              │
│                 (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas, (IERC20, address[], uint256[]));                                                                              │
│                 bentoBox.transferMultiple(token, msg.sender, tos, shares);                                                                                                                                      │
│             } else if (action == ACTION_CALL) {                                                                                                                                                                 │
│                 (bytes memory returnData, uint8 returnValues) = _call(values, datas, value1, value2);                                                                                                           │
│                                                                                                                                                                                                                 │
│                 if (returnValues == 1) {                                                                                                                                                                        │
│                     (value1) = abi.decode(returnData, (uint256));                                                                                                                                               │
│                 } else if (returnValues == 2) {                                                                                                                                                                 │
│                     (value1, value2) = abi.decode(returnData, (uint256, uint256));                                                                                                                              │
│                 }                                                                                                                                                                                               │
│             } else if (action == ACTION_REQUEST_AND_BORROW) {                                                                                                                                                   │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address lender,                                                                                                                                                                             │
│                     address recipient,                                                                                                                                                                          │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimCollateral,                                                                                                                                                                        │
│                     bool anyTokenId,                                                                                                                                                                            │
│                     uint256 deadline,                                                                                                                                                                           │
│                     uint8 v,                                                                                                                                                                                    │
│                     bytes32 r,                                                                                                                                                                                  │
│                     bytes32 s                                                                                                                                                                                   │
│                 ) = abi.decode(datas, (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));                                                                              │
│                 requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);                                                                                            │
│             } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {                                                                                                                                             │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address borrower,                                                                                                                                                                           │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimFunds,                                                                                                                                                                             │
│                     uint256 deadline,                                                                                                                                                                           │
│                     uint8 v,                                                                                                                                                                                    │
│                     bytes32 r,                                                                                                                                                                                  │
│                     bytes32 s                                                                                                                                                                                   │
│                 ) = abi.decode(datas, (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));                                                                                             │
│                 takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);                                                                                                                 │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer, and there is no clear/reset of the approval when the transfer finishes its main branch or encounters exceptions           │
│ Code:                                                                                                                                                                                                           │
│     function cook(                                                                                                                                                                                              │
│         uint8[] calldata actions,                                                                                                                                                                               │
│         uint256[] calldata values,                                                                                                                                                                              │
│         bytes[] calldata datas                                                                                                                                                                                  │
│     ) external payable returns (uint256 value1, uint256 value2) {                                                                                                                                               │
│         for (uint256 i = 0; i < actions.length; i++) {                                                                                                                                                          │
│             uint8 action = actions;                                                                                                                                                                             │
│             if (action == ACTION_REPAY) {                                                                                                                                                                       │
│                 (uint256 tokenId, bool skim) = abi.decode(datas, (uint256, bool));                                                                                                                              │
│                 repay(tokenId, skim);                                                                                                                                                                           │
│             } else if (action == ACTION_REMOVE_COLLATERAL) {                                                                                                                                                    │
│                 (uint256 tokenId, address to) = abi.decode(datas, (uint256, address));                                                                                                                          │
│                 removeCollateral(tokenId, to);                                                                                                                                                                  │
│             } else if (action == ACTION_REQUEST_LOAN) {                                                                                                                                                         │
│                 (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                                                                                                           │
│                     datas,                                                                                                                                                                                      │
│                     (uint256, TokenLoanParams, address, bool)                                                                                                                                                   │
│                 );                                                                                                                                                                                              │
│                 requestLoan(tokenId, params, to, skim);                                                                                                                                                         │
│             } else if (action == ACTION_LEND) {                                                                                                                                                                 │
│                 (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas, (uint256, TokenLoanParams, bool));                                                                              │
│                 lend(tokenId, params, skim);                                                                                                                                                                    │
│             } else if (action == ACTION_BENTO_SETAPPROVAL) {                                                                                                                                                    │
│                 (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                                                                                             │
│                     datas,                                                                                                                                                                                      │
│                     (address, address, bool, uint8, bytes32, bytes32)                                                                                                                                           │
│                 );                                                                                                                                                                                              │
│                 bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);                                                                                                                   │
│             } else if (action == ACTION_BENTO_DEPOSIT) {                                                                                                                                                        │
│                 (value1, value2) = _bentoDeposit(datas, values, value1, value2);                                                                                                                                │
│             } else if (action == ACTION_BENTO_WITHDRAW) {                                                                                                                                                       │
│                 (value1, value2) = _bentoWithdraw(datas, value1, value2);                                                                                                                                       │
│             } else if (action == ACTION_BENTO_TRANSFER) {                                                                                                                                                       │
│                 (IERC20 token, address to, int256 share) = abi.decode(datas, (IERC20, address, int256));                                                                                                        │
│                 bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));                                                                                                                          │
│             } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {                                                                                                                                              │
│                 (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas, (IERC20, address[], uint256[]));                                                                              │
│                 bentoBox.transferMultiple(token, msg.sender, tos, shares);                                                                                                                                      │
│             } else if (action == ACTION_CALL) {                                                                                                                                                                 │
│                 (bytes memory returnData, uint8 returnValues) = _call(values, datas, value1, value2);                                                                                                           │
│                                                                                                                                                                                                                 │
│                 if (returnValues == 1) {                                                                                                                                                                        │
│                     (value1) = abi.decode(returnData, (uint256));                                                                                                                                               │
│                 } else if (returnValues == 2) {                                                                                                                                                                 │
│                     (value1, value2) = abi.decode(returnData, (uint256, uint256));                                                                                                                              │
│                 }                                                                                                                                                                                               │
│             } else if (action == ACTION_REQUEST_AND_BORROW) {                                                                                                                                                   │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address lender,                                                                                                                                                                             │
│                     address recipient,                                                                                                                                                                          │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimCollateral,                                                                                                                                                                        │
│                     bool anyTokenId,                                                                                                                                                                            │
│                     uint256 deadline,                                                                                                                                                                           │
│                     uint8 v,                                                                                                                                                                                    │
│                     bytes32 r,                                                                                                                                                                                  │
│                     bytes32 s                                                                                                                                                                                   │
│                 ) = abi.decode(datas, (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));                                                                              │
│                 requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);                                                                                            │
│             } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {                                                                                                                                             │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address borrower,                                                                                                                                                                           │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimFunds,                                                                                                                                                                             │
│                     uint256 deadline,                                                                                                                                                                           │
│                     uint8 v,                                                                                                                                                                                    │
│                     bytes32 r,                                                                                                                                                                                  │
│                     bytes32 s                                                                                                                                                                                   │
│                 ) = abi.decode(datas, (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));                                                                                             │
│                 takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);                                                                                                                 │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {                                                                                                                          │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         if (loan.status == LOAN_OUTSTANDING) {                                                                                                                                                                  │
│             // The lender can change terms so long as the changes are strictly                                                                                                                                  │
│             // the same or better for the borrower:                                                                                                                                                             │
│             require(msg.sender == loan.lender, "NFTPair: not the lender");                                                                                                                                      │
│             TokenLoanParams memory cur = tokenLoanParams;                                                                                                                                                       │
│             require(                                                                                                                                                                                            │
│                 params.duration >= cur.duration &&                                                                                                                                                              │
│                     params.valuation <= cur.valuation &&                                                                                                                                                        │
│                     params.annualInterestBPS <= cur.annualInterestBPS &&                                                                                                                                        │
│                     params.ltvBPS <= cur.ltvBPS,                                                                                                                                                                │
│                 "NFTPair: worse params"                                                                                                                                                                         │
│             );                                                                                                                                                                                                  │
│         } else if (loan.status == LOAN_REQUESTED) {                                                                                                                                                             │
│             // The borrower has already deposited the collateral and can                                                                                                                                        │
│             // change whatever they like                                                                                                                                                                        │
│             require(msg.sender == loan.borrower, "NFTPair: not the borrower");                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             // The loan has not been taken out yet; the borrower needs to                                                                                                                                       │
│             // provide collateral.                                                                                                                                                                              │
│             revert("NFTPair: no collateral");                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         tokenLoanParams = params;                                                                                                                                                                               │
│         emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _requestLoan(                                                                                                                                                                                      │
│         address collateralProvider,                                                                                                                                                                             │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         address to,                                                                                                                                                                                             │
│         bool skim                                                                                                                                                                                               │
│     ) private {                                                                                                                                                                                                 │
│         // Edge case: valuation can be zero. That effectively gifts the NFT and                                                                                                                                 │
│         // is therefore a bad idea, but does not break the contract.                                                                                                                                            │
│         require(tokenLoan.status == LOAN_INITIAL, "NFTPair: loan exists");                                                                                                                                      │
│         if (skim) {                                                                                                                                                                                             │
│             require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");                                                                                                                      │
│         } else {                                                                                                                                                                                                │
│             collateral.transferFrom(collateralProvider, address(this), tokenId);                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         TokenLoan memory loan;                                                                                                                                                                                  │
│         loan.borrower = to;                                                                                                                                                                                     │
│         loan.status = LOAN_REQUESTED;                                                                                                                                                                           │
│         tokenLoan = loan;                                                                                                                                                                                       │
│         tokenLoanParams = params;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function removeCollateral(uint256 tokenId, address to) public {                                                                                                                                             │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         if (loan.status == LOAN_REQUESTED) {                                                                                                                                                                    │
│             // We are withdrawing collateral that is not in use:                                                                                                                                                │
│             require(msg.sender == loan.borrower, "NFTPair: not the borrower");                                                                                                                                  │
│         } else if (loan.status == LOAN_OUTSTANDING) {                                                                                                                                                           │
│             // We are seizing collateral towards the lender. The loan has to be                                                                                                                                 │
│             // expired and not paid off, or underwater and not paid off:                                                                                                                                        │
│             require(to == loan.lender, "NFTPair: not the lender");                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             if (uint256(loan.startTime) + tokenLoanParams.duration > block.timestamp) {                                                                                                                         │
│                 TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                            │
│                 // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                           │
│                 // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                          │
│                 uint256 interest = calculateInterest(                                                                                                                                                           │
│                     loanParams.valuation,                                                                                                                                                                       │
│                     uint64(block.timestamp - loan.startTime),                                                                                                                                                   │
│                     loanParams.annualInterestBPS                                                                                                                                                                │
│                 ).to128();                                                                                                                                                                                      │
│                 uint256 amount = loanParams.valuation + interest;                                                                                                                                               │
│                 (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);                                                                                                                               │
│                 require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");                                                                                                                     │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         // If there somehow is collateral but no accompanying loan, then anyone                                                                                                                                 │
│         // can claim it by first requesting a loan with `skim` set to true, and                                                                                                                                 │
│         // then withdrawing. So we might as well allow it here..                                                                                                                                                │
│         delete tokenLoan;                                                                                                                                                                                       │
│         collateral.transferFrom(address(this), to, tokenId);                                                                                                                                                    │
│         emit LogRemoveCollateral(tokenId, to);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS &&                                                                                                                                       │
│                 params.ltvBPS >= accepted.ltvBPS,                                                                                                                                                               │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (params.oracle != INFTOracle(0)) {                                                                                                                                                                   │
│             (, uint256 rate) = params.oracle.get(address(this), tokenId);                                                                                                                                       │
│             require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function takeCollateralAndLend(                                                                                                                                                                             │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address borrower,                                                                                                                                                                                       │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimFunds,                                                                                                                                                                                         │
│         uint256 deadline,                                                                                                                                                                                       │
│         uint8 v,                                                                                                                                                                                                │
│         bytes32 r,                                                                                                                                                                                              │
│         bytes32 s                                                                                                                                                                                               │
│     ) public {                                                                                                                                                                                                  │
│         require(block.timestamp <= deadline, "NFTPair: signature expired");                                                                                                                                     │
│         uint256 nonce = nonces++;                                                                                                                                                                               │
│         bytes32 dataHash = keccak256(                                                                                                                                                                           │
│             abi.encode(                                                                                                                                                                                         │
│                 BORROW_SIGNATURE_HASH,                                                                                                                                                                          │
│                 address(this),                                                                                                                                                                                  │
│                 tokenId,                                                                                                                                                                                        │
│                 params.valuation,                                                                                                                                                                               │
│                 params.duration,                                                                                                                                                                                │
│                 params.annualInterestBPS,                                                                                                                                                                       │
│                 nonce,                                                                                                                                                                                          │
│                 deadline                                                                                                                                                                                        │
│             )                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, "NFTPair: signature invalid");                                                                                                            │
│         _requestLoan(borrower, tokenId, params, borrower, false);                                                                                                                                               │
│         _lend(msg.sender, tokenId, params, skimFunds);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS &&                                                                                                                                       │
│                 params.ltvBPS >= accepted.ltvBPS,                                                                                                                                                               │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (params.oracle != INFTOracle(0)) {                                                                                                                                                                   │
│             (, uint256 rate) = params.oracle.get(address(this), tokenId);                                                                                                                                       │
│             require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function requestAndBorrow(                                                                                                                                                                                  │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address lender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimCollateral,                                                                                                                                                                                    │
│         bool anyTokenId,                                                                                                                                                                                        │
│         SignatureParams memory signature                                                                                                                                                                        │
│     ) public {                                                                                                                                                                                                  │
│         if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {                                                                                                                       │
│             require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             require(block.timestamp <= signature.deadline, "NFTPair: signature expired");                                                                                                                       │
│             uint256 nonce = nonces++;                                                                                                                                                                           │
│             bytes32 dataHash = keccak256(                                                                                                                                                                       │
│                 abi.encode(                                                                                                                                                                                     │
│                     LEND_SIGNATURE_HASH,                                                                                                                                                                        │
│                     address(this),                                                                                                                                                                              │
│                     anyTokenId ? 0 : tokenId,                                                                                                                                                                   │
│                     anyTokenId,                                                                                                                                                                                 │
│                     params.valuation,                                                                                                                                                                           │
│                     params.duration,                                                                                                                                                                            │
│                     params.annualInterestBPS,                                                                                                                                                                   │
│                     params.ltvBPS,                                                                                                                                                                              │
│                     params.oracle,                                                                                                                                                                              │
│                     nonce,                                                                                                                                                                                      │
│                     signature.deadline                                                                                                                                                                          │
│                 )                                                                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│             require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");                                                                            │
│         }                                                                                                                                                                                                       │
│         _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);                                                                                                                                   │
│         _lend(lender, tokenId, params, false);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS &&                                                                                                                                       │
│                 params.ltvBPS >= accepted.ltvBPS,                                                                                                                                                               │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (params.oracle != INFTOracle(0)) {                                                                                                                                                                   │
│             (, uint256 rate) = params.oracle.get(address(this), tokenId);                                                                                                                                       │
│             require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function takeCollateralAndLend(                                                                                                                                                                             │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address borrower,                                                                                                                                                                                       │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimFunds,                                                                                                                                                                                         │
│         SignatureParams memory signature                                                                                                                                                                        │
│     ) public {                                                                                                                                                                                                  │
│         require(block.timestamp <= signature.deadline, "NFTPair: signature expired");                                                                                                                           │
│         uint256 nonce = nonces++;                                                                                                                                                                               │
│         bytes32 dataHash = keccak256(                                                                                                                                                                           │
│             abi.encode(                                                                                                                                                                                         │
│                 BORROW_SIGNATURE_HASH,                                                                                                                                                                          │
│                 address(this),                                                                                                                                                                                  │
│                 tokenId,                                                                                                                                                                                        │
│                 params.valuation,                                                                                                                                                                               │
│                 params.duration,                                                                                                                                                                                │
│                 params.annualInterestBPS,                                                                                                                                                                       │
│                 params.ltvBPS,                                                                                                                                                                                  │
│                 params.oracle,                                                                                                                                                                                  │
│                 nonce,                                                                                                                                                                                          │
│                 signature.deadline                                                                                                                                                                              │
│             )                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");                                                                              │
│         _requestLoan(borrower, tokenId, params, borrower, false);                                                                                                                                               │
│         _lend(msg.sender, tokenId, params, skimFunds);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS &&                                                                                                                                       │
│                 params.ltvBPS >= accepted.ltvBPS,                                                                                                                                                               │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (params.oracle != INFTOracle(0)) {                                                                                                                                                                   │
│             (, uint256 rate) = params.oracle.get(address(this), tokenId);                                                                                                                                       │
│             require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function requestAndBorrow(                                                                                                                                                                                  │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address lender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimCollateral,                                                                                                                                                                                    │
│         bool anyTokenId,                                                                                                                                                                                        │
│         uint256 deadline,                                                                                                                                                                                       │
│         uint8 v,                                                                                                                                                                                                │
│         bytes32 r,                                                                                                                                                                                              │
│         bytes32 s                                                                                                                                                                                               │
│     ) public {                                                                                                                                                                                                  │
│         if (v == 0 && r == bytes32(0) && s == bytes32(0)) {                                                                                                                                                     │
│             require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             require(block.timestamp <= deadline, "NFTPair: signature expired");                                                                                                                                 │
│             uint256 nonce = nonces++;                                                                                                                                                                           │
│             bytes32 dataHash = keccak256(                                                                                                                                                                       │
│                 abi.encode(                                                                                                                                                                                     │
│                     LEND_SIGNATURE_HASH,                                                                                                                                                                        │
│                     address(this),                                                                                                                                                                              │
│                     anyTokenId ? 0 : tokenId,                                                                                                                                                                   │
│                     anyTokenId,                                                                                                                                                                                 │
│                     params.valuation,                                                                                                                                                                           │
│                     params.duration,                                                                                                                                                                            │
│                     params.annualInterestBPS,                                                                                                                                                                   │
│                     nonce,                                                                                                                                                                                      │
│                     deadline                                                                                                                                                                                    │
│                 )                                                                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│             require(ecrecover(_getDigest(dataHash), v, r, s) == lender, "NFTPair: signature invalid");                                                                                                          │
│         }                                                                                                                                                                                                       │
│         _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);                                                                                                                                   │
│         _lend(lender, tokenId, params, false);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     function _lend(                                                                                                                                                                                             │
│         address lender,                                                                                                                                                                                         │
│         uint256 tokenId,                                                                                                                                                                                        │
│         TokenLoanParams memory accepted,                                                                                                                                                                        │
│         bool skim                                                                                                                                                                                               │
│     ) internal {                                                                                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_REQUESTED, "NFTPair: not available");                                                                                                                                       │
│         TokenLoanParams memory params = tokenLoanParams;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│         require(                                                                                                                                                                                                │
│             params.valuation == accepted.valuation &&                                                                                                                                                           │
│                 params.duration <= accepted.duration &&                                                                                                                                                         │
│                 params.annualInterestBPS >= accepted.annualInterestBPS &&                                                                                                                                       │
│                 params.ltvBPS >= accepted.ltvBPS,                                                                                                                                                               │
│             "NFTPair: bad params"                                                                                                                                                                               │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (params.oracle != INFTOracle(0)) {                                                                                                                                                                   │
│             (, uint256 rate) = params.oracle.get(address(this), tokenId);                                                                                                                                       │
│             require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);                                                                                                                                  │
│         // No overflow: at most 128 + 16 bits (fits in BentoBox)                                                                                                                                                │
│         uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;                                                                                                                                               │
│         uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (skim) {                                                                                                                                                                                             │
│             require(                                                                                                                                                                                            │
│                 bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),                                                                                   │
│                 "NFTPair: skim too much"                                                                                                                                                                        │
│             );                                                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);                                                                                                      │
│         }                                                                                                                                                                                                       │
│         // No underflow: follows from OPEN_FEE_BPS <= BPS                                                                                                                                                       │
│         uint256 borrowerShare = totalShare - openFeeShare;                                                                                                                                                      │
│         bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);                                                                                                                                  │
│         // No overflow: addends (and result) must fit in BentoBox                                                                                                                                               │
│         feesEarnedShare += protocolFeeShare;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         loan.lender = lender;                                                                                                                                                                                   │
│         loan.status = LOAN_OUTSTANDING;                                                                                                                                                                         │
│         loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..                                                                                                                                │
│         tokenLoan = loan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogLend(lender, tokenId);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function requestAndBorrow(                                                                                                                                                                                  │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address lender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimCollateral,                                                                                                                                                                                    │
│         bool anyTokenId,                                                                                                                                                                                        │
│         SignatureParams memory signature                                                                                                                                                                        │
│     ) public {                                                                                                                                                                                                  │
│         if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {                                                                                                                       │
│             require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             require(block.timestamp <= signature.deadline, "NFTPair: signature expired");                                                                                                                       │
│             uint256 nonce = nonces++;                                                                                                                                                                           │
│             bytes32 dataHash = keccak256(                                                                                                                                                                       │
│                 abi.encode(                                                                                                                                                                                     │
│                     LEND_SIGNATURE_HASH,                                                                                                                                                                        │
│                     address(this),                                                                                                                                                                              │
│                     anyTokenId ? 0 : tokenId,                                                                                                                                                                   │
│                     anyTokenId,                                                                                                                                                                                 │
│                     params.valuation,                                                                                                                                                                           │
│                     params.duration,                                                                                                                                                                            │
│                     params.annualInterestBPS,                                                                                                                                                                   │
│                     params.ltvBPS,                                                                                                                                                                              │
│                     params.oracle,                                                                                                                                                                              │
│                     nonce,                                                                                                                                                                                      │
│                     signature.deadline                                                                                                                                                                          │
│                 )                                                                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│             require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");                                                                            │
│         }                                                                                                                                                                                                       │
│         _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);                                                                                                                                   │
│         _lend(lender, tokenId, params, false);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function takeCollateralAndLend(                                                                                                                                                                             │
│         uint256 tokenId,                                                                                                                                                                                        │
│         address borrower,                                                                                                                                                                                       │
│         TokenLoanParams memory params,                                                                                                                                                                          │
│         bool skimFunds,                                                                                                                                                                                         │
│         SignatureParams memory signature                                                                                                                                                                        │
│     ) public {                                                                                                                                                                                                  │
│         require(block.timestamp <= signature.deadline, "NFTPair: signature expired");                                                                                                                           │
│         uint256 nonce = nonces++;                                                                                                                                                                               │
│         bytes32 dataHash = keccak256(                                                                                                                                                                           │
│             abi.encode(                                                                                                                                                                                         │
│                 BORROW_SIGNATURE_HASH,                                                                                                                                                                          │
│                 address(this),                                                                                                                                                                                  │
│                 tokenId,                                                                                                                                                                                        │
│                 params.valuation,                                                                                                                                                                               │
│                 params.duration,                                                                                                                                                                                │
│                 params.annualInterestBPS,                                                                                                                                                                       │
│                 params.ltvBPS,                                                                                                                                                                                  │
│                 params.oracle,                                                                                                                                                                                  │
│                 nonce,                                                                                                                                                                                          │
│                 signature.deadline                                                                                                                                                                              │
│             )                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");                                                                              │
│         _requestLoan(borrower, tokenId, params, borrower, false);                                                                                                                                               │
│         _lend(msg.sender, tokenId, params, skimFunds);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function calculateInterest(                                                                                                                                                                                 │
│         uint256 principal,                                                                                                                                                                                      │
│         uint64 t,                                                                                                                                                                                               │
│         uint16 aprBPS                                                                                                                                                                                           │
│     ) public pure returns (uint256 interest) {                                                                                                                                                                  │
│         // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // We calculate                                                                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         //  ----- n                                       ----- n                                                                                                                                               │
│         //   \           principal * (t * aprBPS)^k        \                                                                                                                                                    │
│         //    )          --------------------------   =:    )          term_k                                                                                                                                   │
│         //   /                k! * YEAR_BPS^k              /                                                                                                                                                    │
│         //  ----- k = 1                                   ----- k = 1                                                                                                                                           │
│         //                                                                                                                                                                                                      │
│         // which approaches, but never exceeds the "theoretical" result,                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         // as n goes to infinity. We use the fact that                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)                                                                                                                                          │
│         //      term_k = ---------------------------------------------                                                                                                                                          │
│         //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         //                             t * aprBPS                                                                                                                                                               │
│         //             = term_{k-1} * ------------                          (*)                                                                                                                                 │
│         //                            k * YEAR_BPS                                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         // to calculate the terms one by one. The principal affords us the                                                                                                                                      │
│         // precision to carry out the division without resorting to fixed-point                                                                                                                                 │
│         // math. Any rounding error is downward, which we consider acceptable.                                                                                                                                  │
│         //                                                                                                                                                                                                      │
│         // Since all numbers involved are positive, each term is certainly                                                                                                                                      │
│         // bounded above by M. From (*) we see that any intermediate results                                                                                                                                    │
│         // are at most                                                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //                      denom_k := k * YEAR_BPS.                                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,                                                                                                                                    │
│         // which proves that all calculations will certainly not overflow if M                                                                                                                                  │
│         // fits in 128 bits.                                                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // If M does not fit, then the intermediate results for some term may                                                                                                                                   │
│         // eventually overflow, but this cannot happen at the first term, and                                                                                                                                   │
│         // neither can the total overflow because it uses checked math.                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         // This constitutes a guarantee of specified behavior when M >= 2^128.                                                                                                                                  │
│         uint256 x = uint256(t) * aprBPS;                                                                                                                                                                        │
│         uint256 term_k = (principal * x) / YEAR_BPS;                                                                                                                                                            │
│         uint256 denom_k = YEAR_BPS;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         interest = term_k;                                                                                                                                                                                      │
│         for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {                                                                                                                                                │
│             denom_k += YEAR_BPS;                                                                                                                                                                                │
│             term_k = (term_k * x) / denom_k;                                                                                                                                                                    │
│             interest = interest.add(term_k); // <- Only overflow check we need                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (interest >= 2**128) {                                                                                                                                                                               │
│             revert();                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function calculateInterest(                                                                                                                                                                                 │
│         uint256 principal,                                                                                                                                                                                      │
│         uint64 t,                                                                                                                                                                                               │
│         uint16 aprBPS                                                                                                                                                                                           │
│     ) public pure returns (uint256 interest) {                                                                                                                                                                  │
│         // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // We calculate                                                                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         //  ----- n                                       ----- n                                                                                                                                               │
│         //   \           principal * (t * aprBPS)^k        \                                                                                                                                                    │
│         //    )          --------------------------   =:    )          term_k                                                                                                                                   │
│         //   /                k! * YEAR_BPS^k              /                                                                                                                                                    │
│         //  ----- k = 1                                   ----- k = 1                                                                                                                                           │
│         //                                                                                                                                                                                                      │
│         // which approaches, but never exceeds the "theoretical" result,                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         // as n goes to infinity. We use the fact that                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)                                                                                                                                          │
│         //      term_k = ---------------------------------------------                                                                                                                                          │
│         //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         //                             t * aprBPS                                                                                                                                                               │
│         //             = term_{k-1} * ------------                          (*)                                                                                                                                 │
│         //                            k * YEAR_BPS                                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         // to calculate the terms one by one. The principal affords us the                                                                                                                                      │
│         // precision to carry out the division without resorting to fixed-point                                                                                                                                 │
│         // math. Any rounding error is downward, which we consider acceptable.                                                                                                                                  │
│         //                                                                                                                                                                                                      │
│         // Since all numbers involved are positive, each term is certainly                                                                                                                                      │
│         // bounded above by M. From (*) we see that any intermediate results                                                                                                                                    │
│         // are at most                                                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //                      denom_k := k * YEAR_BPS.                                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,                                                                                                                                    │
│         // which proves that all calculations will certainly not overflow if M                                                                                                                                  │
│         // fits in 128 bits.                                                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // If M does not fit, then the intermediate results for some term may                                                                                                                                   │
│         // eventually overflow, but this cannot happen at the first term, and                                                                                                                                   │
│         // neither can the total overflow because it uses checked math.                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         // This constitutes a guarantee of specified behavior when M >= 2^128.                                                                                                                                  │
│         uint256 x = uint256(t) * aprBPS;                                                                                                                                                                        │
│         uint256 term_k = (principal * x) / YEAR_BPS;                                                                                                                                                            │
│         uint256 denom_k = YEAR_BPS;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         interest = term_k;                                                                                                                                                                                      │
│         for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {                                                                                                                                                │
│             denom_k += YEAR_BPS;                                                                                                                                                                                │
│             term_k = (term_k * x) / denom_k;                                                                                                                                                                    │
│             interest = interest.add(term_k); // <- Only overflow check we need                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (interest >= 2**128) {                                                                                                                                                                               │
│             revert();                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function cook(                                                                                                                                                                                              │
│         uint8[] calldata actions,                                                                                                                                                                               │
│         uint256[] calldata values,                                                                                                                                                                              │
│         bytes[] calldata datas                                                                                                                                                                                  │
│     ) external payable returns (uint256 value1, uint256 value2) {                                                                                                                                               │
│         for (uint256 i = 0; i < actions.length; i++) {                                                                                                                                                          │
│             uint8 action = actions;                                                                                                                                                                             │
│             if (action == ACTION_REPAY) {                                                                                                                                                                       │
│                 (uint256 tokenId, bool skim) = abi.decode(datas, (uint256, bool));                                                                                                                              │
│                 repay(tokenId, skim);                                                                                                                                                                           │
│             } else if (action == ACTION_REMOVE_COLLATERAL) {                                                                                                                                                    │
│                 (uint256 tokenId, address to) = abi.decode(datas, (uint256, address));                                                                                                                          │
│                 removeCollateral(tokenId, to);                                                                                                                                                                  │
│             } else if (action == ACTION_REQUEST_LOAN) {                                                                                                                                                         │
│                 (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                                                                                                           │
│                     datas,                                                                                                                                                                                      │
│                     (uint256, TokenLoanParams, address, bool)                                                                                                                                                   │
│                 );                                                                                                                                                                                              │
│                 requestLoan(tokenId, params, to, skim);                                                                                                                                                         │
│             } else if (action == ACTION_LEND) {                                                                                                                                                                 │
│                 (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas, (uint256, TokenLoanParams, bool));                                                                              │
│                 lend(tokenId, params, skim);                                                                                                                                                                    │
│             } else if (action == ACTION_BENTO_SETAPPROVAL) {                                                                                                                                                    │
│                 (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                                                                                             │
│                     datas,                                                                                                                                                                                      │
│                     (address, address, bool, uint8, bytes32, bytes32)                                                                                                                                           │
│                 );                                                                                                                                                                                              │
│                 bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);                                                                                                                   │
│             } else if (action == ACTION_BENTO_DEPOSIT) {                                                                                                                                                        │
│                 (value1, value2) = _bentoDeposit(datas, values, value1, value2);                                                                                                                                │
│             } else if (action == ACTION_BENTO_WITHDRAW) {                                                                                                                                                       │
│                 (value1, value2) = _bentoWithdraw(datas, value1, value2);                                                                                                                                       │
│             } else if (action == ACTION_BENTO_TRANSFER) {                                                                                                                                                       │
│                 (IERC20 token, address to, int256 share) = abi.decode(datas, (IERC20, address, int256));                                                                                                        │
│                 bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));                                                                                                                          │
│             } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {                                                                                                                                              │
│                 (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas, (IERC20, address[], uint256[]));                                                                              │
│                 bentoBox.transferMultiple(token, msg.sender, tos, shares);                                                                                                                                      │
│             } else if (action == ACTION_CALL) {                                                                                                                                                                 │
│                 (bytes memory returnData, uint8 returnValues) = _call(values, datas, value1, value2);                                                                                                           │
│                                                                                                                                                                                                                 │
│                 if (returnValues == 1) {                                                                                                                                                                        │
│                     (value1) = abi.decode(returnData, (uint256));                                                                                                                                               │
│                 } else if (returnValues == 2) {                                                                                                                                                                 │
│                     (value1, value2) = abi.decode(returnData, (uint256, uint256));                                                                                                                              │
│                 }                                                                                                                                                                                               │
│             } else if (action == ACTION_REQUEST_AND_BORROW) {                                                                                                                                                   │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address lender,                                                                                                                                                                             │
│                     address recipient,                                                                                                                                                                          │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimCollateral,                                                                                                                                                                        │
│                     bool anyTokenId,                                                                                                                                                                            │
│                     uint256 deadline,                                                                                                                                                                           │
│                     uint8 v,                                                                                                                                                                                    │
│                     bytes32 r,                                                                                                                                                                                  │
│                     bytes32 s                                                                                                                                                                                   │
│                 ) = abi.decode(datas, (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));                                                                              │
│                 requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);                                                                                            │
│             } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {                                                                                                                                             │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address borrower,                                                                                                                                                                           │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimFunds,                                                                                                                                                                             │
│                     uint256 deadline,                                                                                                                                                                           │
│                     uint8 v,                                                                                                                                                                                    │
│                     bytes32 r,                                                                                                                                                                                  │
│                     bytes32 s                                                                                                                                                                                   │
│                 ) = abi.decode(datas, (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));                                                                                             │
│                 takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);                                                                                                                 │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function cook(                                                                                                                                                                                              │
│         uint8[] calldata actions,                                                                                                                                                                               │
│         uint256[] calldata values,                                                                                                                                                                              │
│         bytes[] calldata datas                                                                                                                                                                                  │
│     ) external payable returns (uint256 value1, uint256 value2) {                                                                                                                                               │
│         for (uint256 i = 0; i < actions.length; i++) {                                                                                                                                                          │
│             uint8 action = actions;                                                                                                                                                                             │
│             if (action == ACTION_REPAY) {                                                                                                                                                                       │
│                 (uint256 tokenId, bool skim) = abi.decode(datas, (uint256, bool));                                                                                                                              │
│                 repay(tokenId, skim);                                                                                                                                                                           │
│             } else if (action == ACTION_REMOVE_COLLATERAL) {                                                                                                                                                    │
│                 (uint256 tokenId, address to) = abi.decode(datas, (uint256, address));                                                                                                                          │
│                 removeCollateral(tokenId, to);                                                                                                                                                                  │
│             } else if (action == ACTION_REQUEST_LOAN) {                                                                                                                                                         │
│                 (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                                                                                                           │
│                     datas,                                                                                                                                                                                      │
│                     (uint256, TokenLoanParams, address, bool)                                                                                                                                                   │
│                 );                                                                                                                                                                                              │
│                 requestLoan(tokenId, params, to, skim);                                                                                                                                                         │
│             } else if (action == ACTION_LEND) {                                                                                                                                                                 │
│                 (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas, (uint256, TokenLoanParams, bool));                                                                              │
│                 lend(tokenId, params, skim);                                                                                                                                                                    │
│             } else if (action == ACTION_BENTO_SETAPPROVAL) {                                                                                                                                                    │
│                 (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                                                                                             │
│                     datas,                                                                                                                                                                                      │
│                     (address, address, bool, uint8, bytes32, bytes32)                                                                                                                                           │
│                 );                                                                                                                                                                                              │
│                 bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);                                                                                                                   │
│             } else if (action == ACTION_BENTO_DEPOSIT) {                                                                                                                                                        │
│                 (value1, value2) = _bentoDeposit(datas, values, value1, value2);                                                                                                                                │
│             } else if (action == ACTION_BENTO_WITHDRAW) {                                                                                                                                                       │
│                 (value1, value2) = _bentoWithdraw(datas, value1, value2);                                                                                                                                       │
│             } else if (action == ACTION_BENTO_TRANSFER) {                                                                                                                                                       │
│                 (IERC20 token, address to, int256 share) = abi.decode(datas, (IERC20, address, int256));                                                                                                        │
│                 bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));                                                                                                                          │
│             } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {                                                                                                                                              │
│                 (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas, (IERC20, address[], uint256[]));                                                                              │
│                 bentoBox.transferMultiple(token, msg.sender, tos, shares);                                                                                                                                      │
│             } else if (action == ACTION_CALL) {                                                                                                                                                                 │
│                 (bytes memory returnData, uint8 returnValues) = _call(values, datas, value1, value2);                                                                                                           │
│                                                                                                                                                                                                                 │
│                 if (returnValues == 1) {                                                                                                                                                                        │
│                     (value1) = abi.decode(returnData, (uint256));                                                                                                                                               │
│                 } else if (returnValues == 2) {                                                                                                                                                                 │
│                     (value1, value2) = abi.decode(returnData, (uint256, uint256));                                                                                                                              │
│                 }                                                                                                                                                                                               │
│             } else if (action == ACTION_REQUEST_AND_BORROW) {                                                                                                                                                   │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address lender,                                                                                                                                                                             │
│                     address recipient,                                                                                                                                                                          │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimCollateral,                                                                                                                                                                        │
│                     bool anyTokenId,                                                                                                                                                                            │
│                     SignatureParams memory signature                                                                                                                                                            │
│                 ) = abi.decode(datas, (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));                                                                                               │
│                 requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);                                                                                                    │
│             } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {                                                                                                                                             │
│                 (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                                                                      │
│                     .decode(datas, (uint256, address, TokenLoanParams, bool, SignatureParams));                                                                                                                 │
│                 takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);                                                                                                                         │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer,                                                                                                                           │
│ Code:                                                                                                                                                                                                           │
│     function cook(                                                                                                                                                                                              │
│         uint8[] calldata actions,                                                                                                                                                                               │
│         uint256[] calldata values,                                                                                                                                                                              │
│         bytes[] calldata datas                                                                                                                                                                                  │
│     ) external payable returns (uint256 value1, uint256 value2) {                                                                                                                                               │
│         for (uint256 i = 0; i < actions.length; i++) {                                                                                                                                                          │
│             uint8 action = actions;                                                                                                                                                                             │
│             if (action == ACTION_REPAY) {                                                                                                                                                                       │
│                 (uint256 tokenId, bool skim) = abi.decode(datas, (uint256, bool));                                                                                                                              │
│                 repay(tokenId, skim);                                                                                                                                                                           │
│             } else if (action == ACTION_REMOVE_COLLATERAL) {                                                                                                                                                    │
│                 (uint256 tokenId, address to) = abi.decode(datas, (uint256, address));                                                                                                                          │
│                 removeCollateral(tokenId, to);                                                                                                                                                                  │
│             } else if (action == ACTION_REQUEST_LOAN) {                                                                                                                                                         │
│                 (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                                                                                                           │
│                     datas,                                                                                                                                                                                      │
│                     (uint256, TokenLoanParams, address, bool)                                                                                                                                                   │
│                 );                                                                                                                                                                                              │
│                 requestLoan(tokenId, params, to, skim);                                                                                                                                                         │
│             } else if (action == ACTION_LEND) {                                                                                                                                                                 │
│                 (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas, (uint256, TokenLoanParams, bool));                                                                              │
│                 lend(tokenId, params, skim);                                                                                                                                                                    │
│             } else if (action == ACTION_BENTO_SETAPPROVAL) {                                                                                                                                                    │
│                 (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                                                                                             │
│                     datas,                                                                                                                                                                                      │
│                     (address, address, bool, uint8, bytes32, bytes32)                                                                                                                                           │
│                 );                                                                                                                                                                                              │
│                 bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);                                                                                                                   │
│             } else if (action == ACTION_BENTO_DEPOSIT) {                                                                                                                                                        │
│                 (value1, value2) = _bentoDeposit(datas, values, value1, value2);                                                                                                                                │
│             } else if (action == ACTION_BENTO_WITHDRAW) {                                                                                                                                                       │
│                 (value1, value2) = _bentoWithdraw(datas, value1, value2);                                                                                                                                       │
│             } else if (action == ACTION_BENTO_TRANSFER) {                                                                                                                                                       │
│                 (IERC20 token, address to, int256 share) = abi.decode(datas, (IERC20, address, int256));                                                                                                        │
│                 bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));                                                                                                                          │
│             } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {                                                                                                                                              │
│                 (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas, (IERC20, address[], uint256[]));                                                                              │
│                 bentoBox.transferMultiple(token, msg.sender, tos, shares);                                                                                                                                      │
│             } else if (action == ACTION_CALL) {                                                                                                                                                                 │
│                 (bytes memory returnData, uint8 returnValues) = _call(values, datas, value1, value2);                                                                                                           │
│                                                                                                                                                                                                                 │
│                 if (returnValues == 1) {                                                                                                                                                                        │
│                     (value1) = abi.decode(returnData, (uint256));                                                                                                                                               │
│                 } else if (returnValues == 2) {                                                                                                                                                                 │
│                     (value1, value2) = abi.decode(returnData, (uint256, uint256));                                                                                                                              │
│                 }                                                                                                                                                                                               │
│             } else if (action == ACTION_REQUEST_AND_BORROW) {                                                                                                                                                   │
│                 (                                                                                                                                                                                               │
│                     uint256 tokenId,                                                                                                                                                                            │
│                     address lender,                                                                                                                                                                             │
│                     address recipient,                                                                                                                                                                          │
│                     TokenLoanParams memory params,                                                                                                                                                              │
│                     bool skimCollateral,                                                                                                                                                                        │
│                     bool anyTokenId,                                                                                                                                                                            │
│                     SignatureParams memory signature                                                                                                                                                            │
│                 ) = abi.decode(datas, (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));                                                                                               │
│                 requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);                                                                                                    │
│             } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {                                                                                                                                             │
│                 (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                                                                      │
│                     .decode(datas, (uint256, address, TokenLoanParams, bool, SignatureParams));                                                                                                                 │
│                 takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);                                                                                                                         │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         IERC20 token_,                                                                                                                                                                                          │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount,                                                                                                                                                                                         │
│         uint256 share                                                                                                                                                                                           │
│     ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {                                                                                                                              │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;                                                                                                                                             │
│         Rebase memory total = totals;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.                                                                                        │
│         require(total.elastic != 0 || token.totalSupply() > 0, "BentoBox: No tokens");                                                                                                                          │
│         if (share == 0) {                                                                                                                                                                                       │
│             // value of the share may be lower than the amount due to rounding, that's ok                                                                                                                       │
│             share = total.toBase(amount, false);                                                                                                                                                                │
│             // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)                                                                                          │
│             if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {                                                                                                                                        │
│                 return (0, 0);                                                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)                                                                                     │
│             amount = total.toElastic(share, true);                                                                                                                                                              │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // In case of skimming, check that only the skimmable amount is taken.                                                                                                                                  │
│         // For ETH, the full balance is available, so no need to check.                                                                                                                                         │
│         // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.                                                                             │
│         require(                                                                                                                                                                                                │
│             from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic),                                                                                             │
│             "BentoBox: Skim too much"                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         balanceOf = balanceOf.add(share);                                                                                                                                                                       │
│         total.base = total.base.add(share.to128());                                                                                                                                                             │
│         total.elastic = total.elastic.add(amount.to128());                                                                                                                                                      │
│         totals = total;                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Interactions                                                                                                                                                                                         │
│         // During the first deposit, we check that this token is 'real'                                                                                                                                         │
│         if (token_ == USE_ETHEREUM) {                                                                                                                                                                           │
│             // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)                                                                                                        │
│             // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)                                                                            │
│             IWETH(address(wethToken)).deposit{value: amount}();                                                                                                                                                 │
│         } else if (from != address(this)) {                                                                                                                                                                     │
│             // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)                                                                                                        │
│             // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.                                                                                                        │
│             token.safeTransferFrom(from, address(this), amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         emit LogDeposit(token, from, to, amount, share);                                                                                                                                                        │
│         amountOut = amount;                                                                                                                                                                                     │
│         shareOut = share;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         IERC20 token_,                                                                                                                                                                                          │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount,                                                                                                                                                                                         │
│         uint256 share                                                                                                                                                                                           │
│     ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {                                                                                                                              │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;                                                                                                                                             │
│         Rebase memory total = totals;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.                                                                                        │
│         require(total.elastic != 0 || token.totalSupply() > 0, "BentoBox: No tokens");                                                                                                                          │
│         if (share == 0) {                                                                                                                                                                                       │
│             // value of the share may be lower than the amount due to rounding, that's ok                                                                                                                       │
│             share = total.toBase(amount, false);                                                                                                                                                                │
│             // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)                                                                                          │
│             if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {                                                                                                                                        │
│                 return (0, 0);                                                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)                                                                                     │
│             amount = total.toElastic(share, true);                                                                                                                                                              │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // In case of skimming, check that only the skimmable amount is taken.                                                                                                                                  │
│         // For ETH, the full balance is available, so no need to check.                                                                                                                                         │
│         // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.                                                                             │
│         require(                                                                                                                                                                                                │
│             from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic),                                                                                             │
│             "BentoBox: Skim too much"                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         balanceOf = balanceOf.add(share);                                                                                                                                                                       │
│         total.base = total.base.add(share.to128());                                                                                                                                                             │
│         total.elastic = total.elastic.add(amount.to128());                                                                                                                                                      │
│         totals = total;                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Interactions                                                                                                                                                                                         │
│         // During the first deposit, we check that this token is 'real'                                                                                                                                         │
│         if (token_ == USE_ETHEREUM) {                                                                                                                                                                           │
│             // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)                                                                                                        │
│             // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)                                                                            │
│             IWETH(address(wethToken)).deposit{value: amount}();                                                                                                                                                 │
│         } else if (from != address(this)) {                                                                                                                                                                     │
│             // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)                                                                                                        │
│             // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.                                                                                                        │
│             token.safeTransferFrom(from, address(this), amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         emit LogDeposit(token, from, to, amount, share);                                                                                                                                                        │
│         amountOut = amount;                                                                                                                                                                                     │
│         shareOut = share;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         IERC20 token_,                                                                                                                                                                                          │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount,                                                                                                                                                                                         │
│         uint256 share                                                                                                                                                                                           │
│     ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {                                                                                                                                      │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;                                                                                                                                             │
│         Rebase memory total = totals;                                                                                                                                                                           │
│         if (share == 0) {                                                                                                                                                                                       │
│             // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)                                                                         │
│             share = total.toBase(amount, true);                                                                                                                                                                 │
│         } else {                                                                                                                                                                                                │
│             // amount may be lower than the value of share due to rounding, that's ok                                                                                                                           │
│             amount = total.toElastic(share, false);                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         balanceOf = balanceOf.sub(share);                                                                                                                                                                       │
│         total.elastic = total.elastic.sub(amount.to128());                                                                                                                                                      │
│         total.base = total.base.sub(share.to128());                                                                                                                                                             │
│         // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)                                                                                    │
│         require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, "BentoBox: cannot empty");                                                                                                              │
│         totals = total;                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Interactions                                                                                                                                                                                         │
│         if (token_ == USE_ETHEREUM) {                                                                                                                                                                           │
│             // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.                                                                                               │
│             IWETH(address(wethToken)).withdraw(amount);                                                                                                                                                         │
│             // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.                                                                                           │
│             (bool success, ) = to.call{value: amount}("");                                                                                                                                                      │
│             require(success, "BentoBox: ETH transfer failed");                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             // X2, X3: A malicious token could block withdrawal of just THAT token.                                                                                                                             │
│             //         masterContracts may want to take care not to rely on withdraw always succeeding.                                                                                                         │
│             token.safeTransfer(to, amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         emit LogWithdraw(token, from, to, amount, share);                                                                                                                                                       │
│         amountOut = amount;                                                                                                                                                                                     │
│         shareOut = share;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         IERC20 token_,                                                                                                                                                                                          │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount,                                                                                                                                                                                         │
│         uint256 share                                                                                                                                                                                           │
│     ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {                                                                                                                                      │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;                                                                                                                                             │
│         Rebase memory total = totals;                                                                                                                                                                           │
│         if (share == 0) {                                                                                                                                                                                       │
│             // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)                                                                         │
│             share = total.toBase(amount, true);                                                                                                                                                                 │
│         } else {                                                                                                                                                                                                │
│             // amount may be lower than the value of share due to rounding, that's ok                                                                                                                           │
│             amount = total.toElastic(share, false);                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         balanceOf = balanceOf.sub(share);                                                                                                                                                                       │
│         total.elastic = total.elastic.sub(amount.to128());                                                                                                                                                      │
│         total.base = total.base.sub(share.to128());                                                                                                                                                             │
│         // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)                                                                                    │
│         require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, "BentoBox: cannot empty");                                                                                                              │
│         totals = total;                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Interactions                                                                                                                                                                                         │
│         if (token_ == USE_ETHEREUM) {                                                                                                                                                                           │
│             // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.                                                                                               │
│             IWETH(address(wethToken)).withdraw(amount);                                                                                                                                                         │
│             // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.                                                                                           │
│             (bool success, ) = to.call{value: amount}("");                                                                                                                                                      │
│             require(success, "BentoBox: ETH transfer failed");                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             // X2, X3: A malicious token could block withdrawal of just THAT token.                                                                                                                             │
│             //         masterContracts may want to take care not to rely on withdraw always succeeding.                                                                                                         │
│             token.safeTransfer(to, amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         emit LogWithdraw(token, from, to, amount, share);                                                                                                                                                       │
│         amountOut = amount;                                                                                                                                                                                     │
│         shareOut = share;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         IERC20 token_,                                                                                                                                                                                          │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount,                                                                                                                                                                                         │
│         uint256 share                                                                                                                                                                                           │
│     ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {                                                                                                                                      │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;                                                                                                                                             │
│         Rebase memory total = totals;                                                                                                                                                                           │
│         if (share == 0) {                                                                                                                                                                                       │
│             // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)                                                                         │
│             share = total.toBase(amount, true);                                                                                                                                                                 │
│         } else {                                                                                                                                                                                                │
│             // amount may be lower than the value of share due to rounding, that's ok                                                                                                                           │
│             amount = total.toElastic(share, false);                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         balanceOf = balanceOf.sub(share);                                                                                                                                                                       │
│         total.elastic = total.elastic.sub(amount.to128());                                                                                                                                                      │
│         total.base = total.base.sub(share.to128());                                                                                                                                                             │
│         // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)                                                                                    │
│         require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, "BentoBox: cannot empty");                                                                                                              │
│         totals = total;                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Interactions                                                                                                                                                                                         │
│         if (token_ == USE_ETHEREUM) {                                                                                                                                                                           │
│             // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.                                                                                               │
│             IWETH(address(wethToken)).withdraw(amount);                                                                                                                                                         │
│             // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.                                                                                           │
│             (bool success, ) = to.call{value: amount}("");                                                                                                                                                      │
│             require(success, "BentoBox: ETH transfer failed");                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             // X2, X3: A malicious token could block withdrawal of just THAT token.                                                                                                                             │
│             //         masterContracts may want to take care not to rely on withdraw always succeeding.                                                                                                         │
│             token.safeTransfer(to, amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         emit LogWithdraw(token, from, to, amount, share);                                                                                                                                                       │
│         amountOut = amount;                                                                                                                                                                                     │
│         shareOut = share;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender                                                                                                                              │
│ have code statements that get or calculate LP token's value/price                                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function transfer(                                                                                                                                                                                          │
│         IERC20 token,                                                                                                                                                                                           │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 share                                                                                                                                                                                           │
│     ) public allowed(from) {                                                                                                                                                                                    │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(share);                                                                                                                                                                       │
│         balanceOf = balanceOf.add(share);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogTransfer(token, from, to, share);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes",                                                                                                                                                                                                 │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender and there is no check of allowance/approval from the address owner                                                           │
│ Code:                                                                                                                                                                                                           │
│     function transfer(                                                                                                                                                                                          │
│         IERC20 token,                                                                                                                                                                                           │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 share                                                                                                                                                                                           │
│     ) public allowed(from) {                                                                                                                                                                                    │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(share);                                                                                                                                                                       │
│         balanceOf = balanceOf.add(share);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogTransfer(token, from, to, share);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 wad) public {                                                                                                                                                                     │
│         require(balanceOf >= wad, "WETH9: Error");                                                                                                                                                              │
│         balanceOf -= wad;                                                                                                                                                                                       │
│         msg.sender.transfer(wad);                                                                                                                                                                               │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function transfer(                                                                                                                                                                                          │
│         IERC20 token,                                                                                                                                                                                           │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 share                                                                                                                                                                                           │
│     ) public allowed(from) {                                                                                                                                                                                    │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         balanceOf = balanceOf.sub(share);                                                                                                                                                                       │
│         balanceOf = balanceOf.add(share);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit LogTransfer(token, from, to, share);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender                                                                                                                              │
│ have code statements that get or calculate LP token's value/price                                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function transferMultiple(                                                                                                                                                                                  │
│         IERC20 token,                                                                                                                                                                                           │
│         address from,                                                                                                                                                                                           │
│         address[] calldata tos,                                                                                                                                                                                 │
│         uint256[] calldata shares                                                                                                                                                                               │
│     ) public allowed(from) {                                                                                                                                                                                    │
│         // Checks                                                                                                                                                                                               │
│         require(tos[0] != address(0), "BentoBox: to[0] not set"); // To avoid a bad UI from burning funds                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         uint256 totalAmount;                                                                                                                                                                                    │
│         uint256 len = tos.length;                                                                                                                                                                               │
│         for (uint256 i = 0; i < len; i++) {                                                                                                                                                                     │
│             address to = tos;                                                                                                                                                                                   │
│             balanceOf = balanceOf.add(shares);                                                                                                                                                                  │
│             totalAmount = totalAmount.add(shares);                                                                                                                                                              │
│             emit LogTransfer(token, from, to, shares);                                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         balanceOf = balanceOf.sub(totalAmount);                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function flashLoan(                                                                                                                                                                                         │
│         IFlashBorrower borrower,                                                                                                                                                                                │
│         address receiver,                                                                                                                                                                                       │
│         IERC20 token,                                                                                                                                                                                           │
│         uint256 amount,                                                                                                                                                                                         │
│         bytes calldata data                                                                                                                                                                                     │
│     ) public {                                                                                                                                                                                                  │
│         uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;                                                                                                                                    │
│         token.safeTransfer(receiver, amount);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         borrower.onFlashLoan(msg.sender, token, amount, fee, data);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         require(_tokenBalanceOf(token) >= totals.addElastic(fee.to128()), "BentoBox: Wrong amount");                                                                                                            │
│         emit LogFlashLoan(address(borrower), token, amount, fee, receiver);                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function batchFlashLoan(                                                                                                                                                                                    │
│         IBatchFlashBorrower borrower,                                                                                                                                                                           │
│         address[] calldata receivers,                                                                                                                                                                           │
│         IERC20[] calldata tokens,                                                                                                                                                                               │
│         uint256[] calldata amounts,                                                                                                                                                                             │
│         bytes calldata data                                                                                                                                                                                     │
│     ) public {                                                                                                                                                                                                  │
│         uint256[] memory fees = new uint256[](tokens.length);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 len = tokens.length;                                                                                                                                                                            │
│         for (uint256 i = 0; i < len; i++) {                                                                                                                                                                     │
│             uint256 amount = amounts;                                                                                                                                                                           │
│             fees = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             tokens.safeTransfer(receivers, amounts);                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         for (uint256 i = 0; i < len; i++) {                                                                                                                                                                     │
│             IERC20 token = tokens;                                                                                                                                                                              │
│             require(_tokenBalanceOf(token) >= totals.addElastic(fees.to128()), "BentoBox: Wrong amount");                                                                                                       │
│             emit LogFlashLoan(address(borrower), token, amounts, fees, receivers);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function harvest(                                                                                                                                                                                           │
│         IERC20 token,                                                                                                                                                                                           │
│         bool balance,                                                                                                                                                                                           │
│         uint256 maxChangeAmount                                                                                                                                                                                 │
│     ) public {                                                                                                                                                                                                  │
│         StrategyData memory data = strategyData;                                                                                                                                                                │
│         IStrategy _strategy = strategy;                                                                                                                                                                         │
│         int256 balanceChange = _strategy.harvest(data.balance, msg.sender);                                                                                                                                     │
│         if (balanceChange == 0 && !balance) {                                                                                                                                                                   │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalElastic = totals.elastic;                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (balanceChange > 0) {                                                                                                                                                                                │
│             uint256 add = uint256(balanceChange);                                                                                                                                                               │
│             totalElastic = totalElastic.add(add);                                                                                                                                                               │
│             totals.elastic = totalElastic.to128();                                                                                                                                                              │
│             emit LogStrategyProfit(token, add);                                                                                                                                                                 │
│         } else if (balanceChange < 0) {                                                                                                                                                                         │
│             // C1 - All math done through BoringMath (SWC-101)                                                                                                                                                  │
│             // C1: balanceChange could overflow if it's max negative int128.                                                                                                                                    │
│             // But tokens with balances that large are not supported by the BentoBox.                                                                                                                           │
│             uint256 sub = uint256(-balanceChange);                                                                                                                                                              │
│             totalElastic = totalElastic.sub(sub);                                                                                                                                                               │
│             totals.elastic = totalElastic.to128();                                                                                                                                                              │
│             data.balance = data.balance.sub(sub.to128());                                                                                                                                                       │
│             emit LogStrategyLoss(token, sub);                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (balance) {                                                                                                                                                                                          │
│             uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;                                                                                                                              │
│             // if data.balance == targetBalance there is nothing to update                                                                                                                                      │
│             if (data.balance < targetBalance) {                                                                                                                                                                 │
│                 uint256 amountOut = targetBalance.sub(data.balance);                                                                                                                                            │
│                 if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {                                                                                                                                      │
│                     amountOut = maxChangeAmount;                                                                                                                                                                │
│                 }                                                                                                                                                                                               │
│                 token.safeTransfer(address(_strategy), amountOut);                                                                                                                                              │
│                 data.balance = data.balance.add(amountOut.to128());                                                                                                                                             │
│                 _strategy.skim(amountOut);                                                                                                                                                                      │
│                 emit LogStrategyInvest(token, amountOut);                                                                                                                                                       │
│             } else if (data.balance > targetBalance) {                                                                                                                                                          │
│                 uint256 amountIn = data.balance.sub(targetBalance.to128());                                                                                                                                     │
│                 if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {                                                                                                                                       │
│                     amountIn = maxChangeAmount;                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 uint256 actualAmountIn = _strategy.withdraw(amountIn);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│                 data.balance = data.balance.sub(actualAmountIn.to128());                                                                                                                                        │
│                 emit LogStrategyDivest(token, actualAmountIn);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         strategyData = data;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function harvest(                                                                                                                                                                                           │
│         IERC20 token,                                                                                                                                                                                           │
│         bool balance,                                                                                                                                                                                           │
│         uint256 maxChangeAmount                                                                                                                                                                                 │
│     ) public {                                                                                                                                                                                                  │
│         StrategyData memory data = strategyData;                                                                                                                                                                │
│         IStrategy _strategy = strategy;                                                                                                                                                                         │
│         int256 balanceChange = _strategy.harvest(data.balance, msg.sender);                                                                                                                                     │
│         if (balanceChange == 0 && !balance) {                                                                                                                                                                   │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalElastic = totals.elastic;                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (balanceChange > 0) {                                                                                                                                                                                │
│             uint256 add = uint256(balanceChange);                                                                                                                                                               │
│             totalElastic = totalElastic.add(add);                                                                                                                                                               │
│             totals.elastic = totalElastic.to128();                                                                                                                                                              │
│             emit LogStrategyProfit(token, add);                                                                                                                                                                 │
│         } else if (balanceChange < 0) {                                                                                                                                                                         │
│             // C1 - All math done through BoringMath (SWC-101)                                                                                                                                                  │
│             // C1: balanceChange could overflow if it's max negative int128.                                                                                                                                    │
│             // But tokens with balances that large are not supported by the BentoBox.                                                                                                                           │
│             uint256 sub = uint256(-balanceChange);                                                                                                                                                              │
│             totalElastic = totalElastic.sub(sub);                                                                                                                                                               │
│             totals.elastic = totalElastic.to128();                                                                                                                                                              │
│             data.balance = data.balance.sub(sub.to128());                                                                                                                                                       │
│             emit LogStrategyLoss(token, sub);                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (balance) {                                                                                                                                                                                          │
│             uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;                                                                                                                              │
│             // if data.balance == targetBalance there is nothing to update                                                                                                                                      │
│             if (data.balance < targetBalance) {                                                                                                                                                                 │
│                 uint256 amountOut = targetBalance.sub(data.balance);                                                                                                                                            │
│                 if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {                                                                                                                                      │
│                     amountOut = maxChangeAmount;                                                                                                                                                                │
│                 }                                                                                                                                                                                               │
│                 token.safeTransfer(address(_strategy), amountOut);                                                                                                                                              │
│                 data.balance = data.balance.add(amountOut.to128());                                                                                                                                             │
│                 _strategy.skim(amountOut);                                                                                                                                                                      │
│                 emit LogStrategyInvest(token, amountOut);                                                                                                                                                       │
│             } else if (data.balance > targetBalance) {                                                                                                                                                          │
│                 uint256 amountIn = data.balance.sub(targetBalance.to128());                                                                                                                                     │
│                 if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {                                                                                                                                       │
│                     amountIn = maxChangeAmount;                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 uint256 actualAmountIn = _strategy.withdraw(amountIn);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│                 data.balance = data.balance.sub(actualAmountIn.to128());                                                                                                                                        │
│                 emit LogStrategyDivest(token, actualAmountIn);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         strategyData = data;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 wad) public {                                                                                                                                                                     │
│         require(balanceOf >= wad, "WETH9: Error");                                                                                                                                                              │
│         balanceOf -= wad;                                                                                                                                                                                       │
│         msg.sender.transfer(wad);                                                                                                                                                                               │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         IERC20 token_,                                                                                                                                                                                          │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount,                                                                                                                                                                                         │
│         uint256 share                                                                                                                                                                                           │
│     ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {                                                                                                                                      │
│         // Checks                                                                                                                                                                                               │
│         require(to != address(0), "BentoBox: to not set"); // To avoid a bad UI from burning funds                                                                                                              │
│                                                                                                                                                                                                                 │
│         // Effects                                                                                                                                                                                              │
│         IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;                                                                                                                                             │
│         Rebase memory total = totals;                                                                                                                                                                           │
│         if (share == 0) {                                                                                                                                                                                       │
│             // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)                                                                         │
│             share = total.toBase(amount, true);                                                                                                                                                                 │
│         } else {                                                                                                                                                                                                │
│             // amount may be lower than the value of share due to rounding, that's ok                                                                                                                           │
│             amount = total.toElastic(share, false);                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         balanceOf = balanceOf.sub(share);                                                                                                                                                                       │
│         total.elastic = total.elastic.sub(amount.to128());                                                                                                                                                      │
│         total.base = total.base.sub(share.to128());                                                                                                                                                             │
│         // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)                                                                                    │
│         require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, "BentoBox: cannot empty");                                                                                                              │
│         totals = total;                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Interactions                                                                                                                                                                                         │
│         if (token_ == USE_ETHEREUM) {                                                                                                                                                                           │
│             // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.                                                                                               │
│             IWETH(address(wethToken)).withdraw(amount);                                                                                                                                                         │
│             // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.                                                                                           │
│             (bool success, ) = to.call{value: amount}("");                                                                                                                                                      │
│             require(success, "BentoBox: ETH transfer failed");                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             // X2, X3: A malicious token could block withdrawal of just THAT token.                                                                                                                             │
│             //         masterContracts may want to take care not to rely on withdraw always succeeding.                                                                                                         │
│             token.safeTransfer(to, amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         emit LogWithdraw(token, from, to, amount, share);                                                                                                                                                       │
│         amountOut = amount;                                                                                                                                                                                     │
│         shareOut = share;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 wad) public {                                                                                                                                                                     │
│         require(balanceOf >= wad, "WETH9: Error");                                                                                                                                                              │
│         balanceOf -= wad;                                                                                                                                                                                       │
│         msg.sender.transfer(wad);                                                                                                                                                                               │
│         emit Withdrawal(msg.sender, wad);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function transferFrom(                                                                                                                                                                                      │
│         address src,                                                                                                                                                                                            │
│         address dst,                                                                                                                                                                                            │
│         uint256 wad                                                                                                                                                                                             │
│     ) public returns (bool) {                                                                                                                                                                                   │
│         require(balanceOf >= wad, "WETH9: Error");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (src != msg.sender && allowance != uint256(-1)) {                                                                                                                                                    │
│             require(allowance >= wad, "WETH9: Error");                                                                                                                                                          │
│             allowance -= wad;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         balanceOf -= wad;                                                                                                                                                                                       │
│         balanceOf += wad;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Transfer(src, dst, wad);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function willLend(uint256 tokenId, TokenLoanParams memory requested) external view returns (bool) {                                                                                                         │
│         if (msg.sender != address(nftPair)) {                                                                                                                                                                   │
│             return false;                                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│         TokenLoanParams memory accepted = _lendingConditions(tokenId);                                                                                                                                          │
│         // Valuation has to be an exact match, everything else must be at least                                                                                                                                 │
│         // as good for the lender as `accepted`.                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         return                                                                                                                                                                                                  │
│             requested.valuation == accepted.valuation &&                                                                                                                                                        │
│             requested.duration <= accepted.duration &&                                                                                                                                                          │
│             requested.annualInterestBPS >= accepted.annualInterestBPS;                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _lendingConditions(uint256 tokenId) private pure returns (TokenLoanParams memory) {                                                                                                                │
│         TokenLoanParams memory conditions;                                                                                                                                                                      │
│         // No specific conditions given, but we'll take all even-numbered                                                                                                                                       │
│         // ones at 100% APY:                                                                                                                                                                                    │
│         if (tokenId % 2 == 0) {                                                                                                                                                                                 │
│             // 256-bit addition fits by the above check.                                                                                                                                                        │
│             // Cast is.. relatively safe: this is a mock implementation,                                                                                                                                        │
│             // production use is unlikely to follow this pattern for valuing                                                                                                                                    │
│             // loans, and manipulating the token ID can only break the logic by                                                                                                                                 │
│             // making the loan "safer" for the lender.                                                                                                                                                          │
│             conditions.valuation = uint128((tokenId + 1) * 10**18);                                                                                                                                             │
│             conditions.duration = 365 days;                                                                                                                                                                     │
│             conditions.annualInterestBPS = 10_000;                                                                                                                                                              │
│         }                                                                                                                                                                                                       │
│         return conditions;                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function calculateInterest(                                                                                                                                                                                 │
│         uint256 principal,                                                                                                                                                                                      │
│         uint64 t,                                                                                                                                                                                               │
│         uint16 aprBPS                                                                                                                                                                                           │
│     ) public pure returns (uint256 interest) {                                                                                                                                                                  │
│         // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // We calculate                                                                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         //  ----- n                                       ----- n                                                                                                                                               │
│         //   \           principal * (t * aprBPS)^k        \                                                                                                                                                    │
│         //    )          --------------------------   =:    )          term_k                                                                                                                                   │
│         //   /                k! * YEAR_BPS^k              /                                                                                                                                                    │
│         //  ----- k = 1                                   ----- k = 1                                                                                                                                           │
│         //                                                                                                                                                                                                      │
│         // which approaches, but never exceeds the "theoretical" result,                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         // as n goes to infinity. We use the fact that                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)                                                                                                                                          │
│         //      term_k = ---------------------------------------------                                                                                                                                          │
│         //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         //                             t * aprBPS                                                                                                                                                               │
│         //             = term_{k-1} * ------------                          (*)                                                                                                                                 │
│         //                            k * YEAR_BPS                                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         // to calculate the terms one by one. The principal affords us the                                                                                                                                      │
│         // precision to carry out the division without resorting to fixed-point                                                                                                                                 │
│         // math. Any rounding error is downward, which we consider acceptable.                                                                                                                                  │
│         //                                                                                                                                                                                                      │
│         // Since all numbers involved are positive, each term is certainly                                                                                                                                      │
│         // bounded above by M. From (*) we see that any intermediate results                                                                                                                                    │
│         // are at most                                                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //                      denom_k := k * YEAR_BPS.                                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,                                                                                                                                    │
│         // which proves that all calculations will certainly not overflow if M                                                                                                                                  │
│         // fits in 128 bits.                                                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // If M does not fit, then the intermediate results for some term may                                                                                                                                   │
│         // eventually overflow, but this cannot happen at the first term, and                                                                                                                                   │
│         // neither can the total overflow because it uses checked math.                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         // This constitutes a guarantee of specified behavior when M >= 2^128.                                                                                                                                  │
│         uint256 x = uint256(t) * aprBPS;                                                                                                                                                                        │
│         uint256 term_k = (principal * x) / YEAR_BPS;                                                                                                                                                            │
│         uint256 denom_k = YEAR_BPS;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         interest = term_k;                                                                                                                                                                                      │
│         for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {                                                                                                                                                │
│             denom_k += YEAR_BPS;                                                                                                                                                                                │
│             term_k = (term_k * x) / denom_k;                                                                                                                                                                    │
│             interest = interest.add(term_k); // <- Only overflow check we need                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (interest >= 2**128) {                                                                                                                                                                               │
│             revert();                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 x = uint256(t) * aprBPS;`                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function calculateInterest(                                                                                                                                                                                 │
│         uint256 principal,                                                                                                                                                                                      │
│         uint64 t,                                                                                                                                                                                               │
│         uint16 aprBPS                                                                                                                                                                                           │
│     ) public pure returns (uint256 interest) {                                                                                                                                                                  │
│         // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // We calculate                                                                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         //  ----- n                                       ----- n                                                                                                                                               │
│         //   \           principal * (t * aprBPS)^k        \                                                                                                                                                    │
│         //    )          --------------------------   =:    )          term_k                                                                                                                                   │
│         //   /                k! * YEAR_BPS^k              /                                                                                                                                                    │
│         //  ----- k = 1                                   ----- k = 1                                                                                                                                           │
│         //                                                                                                                                                                                                      │
│         // which approaches, but never exceeds the "theoretical" result,                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         // as n goes to infinity. We use the fact that                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)                                                                                                                                          │
│         //      term_k = ---------------------------------------------                                                                                                                                          │
│         //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         //                             t * aprBPS                                                                                                                                                               │
│         //             = term_{k-1} * ------------                          (*)                                                                                                                                 │
│         //                            k * YEAR_BPS                                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         // to calculate the terms one by one. The principal affords us the                                                                                                                                      │
│         // precision to carry out the division without resorting to fixed-point                                                                                                                                 │
│         // math. Any rounding error is downward, which we consider acceptable.                                                                                                                                  │
│         //                                                                                                                                                                                                      │
│         // Since all numbers involved are positive, each term is certainly                                                                                                                                      │
│         // bounded above by M. From (*) we see that any intermediate results                                                                                                                                    │
│         // are at most                                                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //                      denom_k := k * YEAR_BPS.                                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,                                                                                                                                    │
│         // which proves that all calculations will certainly not overflow if M                                                                                                                                  │
│         // fits in 128 bits.                                                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // If M does not fit, then the intermediate results for some term may                                                                                                                                   │
│         // eventually overflow, but this cannot happen at the first term, and                                                                                                                                   │
│         // neither can the total overflow because it uses checked math.                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         // This constitutes a guarantee of specified behavior when M >= 2^128.                                                                                                                                  │
│         uint256 x = uint256(t) * aprBPS;                                                                                                                                                                        │
│         uint256 term_k = (principal * x) / YEAR_BPS;                                                                                                                                                            │
│         uint256 denom_k = YEAR_BPS;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         interest = term_k;                                                                                                                                                                                      │
│         for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {                                                                                                                                                │
│             denom_k += YEAR_BPS;                                                                                                                                                                                │
│             term_k = (term_k * x) / denom_k;                                                                                                                                                                    │
│             interest = interest.add(term_k); // <- Only overflow check we need                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (interest >= 2**128) {                                                                                                                                                                               │
│             revert();                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 term_k = (principal * x) / YEAR_BPS;`                                                                                                                                                                  │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:47:43] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/contracts/NFTPair.sol, current function:     tasks.py:260
                             calculateInterest, current vul: wrong-order-interest                                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `amount = principal + interest;`.                                                                                                                │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `amount = principal + interest;`                                                                                                                                                                                │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:47:44] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/contracts/NFTPair.sol, current function:     tasks.py:260
                             repay, current vul: wrong-order-interest                                                                                                                                              
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function calculateInterest(                                                                                                                                                                                 │
│         uint256 principal,                                                                                                                                                                                      │
│         uint64 t,                                                                                                                                                                                               │
│         uint16 aprBPS                                                                                                                                                                                           │
│     ) public pure returns (uint256 interest) {                                                                                                                                                                  │
│         // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // We calculate                                                                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         //  ----- n                                       ----- n                                                                                                                                               │
│         //   \           principal * (t * aprBPS)^k        \                                                                                                                                                    │
│         //    )          --------------------------   =:    )          term_k                                                                                                                                   │
│         //   /                k! * YEAR_BPS^k              /                                                                                                                                                    │
│         //  ----- k = 1                                   ----- k = 1                                                                                                                                           │
│         //                                                                                                                                                                                                      │
│         // which approaches, but never exceeds the "theoretical" result,                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         // as n goes to infinity. We use the fact that                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)                                                                                                                                          │
│         //      term_k = ---------------------------------------------                                                                                                                                          │
│         //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         //                             t * aprBPS                                                                                                                                                               │
│         //             = term_{k-1} * ------------                          (*)                                                                                                                                 │
│         //                            k * YEAR_BPS                                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         // to calculate the terms one by one. The principal affords us the                                                                                                                                      │
│         // precision to carry out the division without resorting to fixed-point                                                                                                                                 │
│         // math. Any rounding error is downward, which we consider acceptable.                                                                                                                                  │
│         //                                                                                                                                                                                                      │
│         // Since all numbers involved are positive, each term is certainly                                                                                                                                      │
│         // bounded above by M. From (*) we see that any intermediate results                                                                                                                                    │
│         // are at most                                                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //                      denom_k := k * YEAR_BPS.                                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,                                                                                                                                    │
│         // which proves that all calculations will certainly not overflow if M                                                                                                                                  │
│         // fits in 128 bits.                                                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // If M does not fit, then the intermediate results for some term may                                                                                                                                   │
│         // eventually overflow, but this cannot happen at the first term, and                                                                                                                                   │
│         // neither can the total overflow because it uses checked math.                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         // This constitutes a guarantee of specified behavior when M >= 2^128.                                                                                                                                  │
│         uint256 x = uint256(t) * aprBPS;                                                                                                                                                                        │
│         uint256 term_k = (principal * x) / YEAR_BPS;                                                                                                                                                            │
│         uint256 denom_k = YEAR_BPS;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         interest = term_k;                                                                                                                                                                                      │
│         for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {                                                                                                                                                │
│             denom_k += YEAR_BPS;                                                                                                                                                                                │
│             term_k = (term_k * x) / denom_k;                                                                                                                                                                    │
│             interest = interest.add(term_k); // <- Only overflow check we need                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (interest >= 2**128) {                                                                                                                                                                               │
│             revert();                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 x = uint256(t) * aprBPS;`                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function calculateInterest(                                                                                                                                                                                 │
│         uint256 principal,                                                                                                                                                                                      │
│         uint64 t,                                                                                                                                                                                               │
│         uint16 aprBPS                                                                                                                                                                                           │
│     ) public pure returns (uint256 interest) {                                                                                                                                                                  │
│         // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // We calculate                                                                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         //  ----- n                                       ----- n                                                                                                                                               │
│         //   \           principal * (t * aprBPS)^k        \                                                                                                                                                    │
│         //    )          --------------------------   =:    )          term_k                                                                                                                                   │
│         //   /                k! * YEAR_BPS^k              /                                                                                                                                                    │
│         //  ----- k = 1                                   ----- k = 1                                                                                                                                           │
│         //                                                                                                                                                                                                      │
│         // which approaches, but never exceeds the "theoretical" result,                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         // as n goes to infinity. We use the fact that                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)                                                                                                                                          │
│         //      term_k = ---------------------------------------------                                                                                                                                          │
│         //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         //                             t * aprBPS                                                                                                                                                               │
│         //             = term_{k-1} * ------------                          (*)                                                                                                                                 │
│         //                            k * YEAR_BPS                                                                                                                                                              │
│         //                                                                                                                                                                                                      │
│         // to calculate the terms one by one. The principal affords us the                                                                                                                                      │
│         // precision to carry out the division without resorting to fixed-point                                                                                                                                 │
│         // math. Any rounding error is downward, which we consider acceptable.                                                                                                                                  │
│         //                                                                                                                                                                                                      │
│         // Since all numbers involved are positive, each term is certainly                                                                                                                                      │
│         // bounded above by M. From (*) we see that any intermediate results                                                                                                                                    │
│         // are at most                                                                                                                                                                                          │
│         //                                                                                                                                                                                                      │
│         //                      denom_k := k * YEAR_BPS.                                                                                                                                                        │
│         //                                                                                                                                                                                                      │
│         // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,                                                                                                                                    │
│         // which proves that all calculations will certainly not overflow if M                                                                                                                                  │
│         // fits in 128 bits.                                                                                                                                                                                    │
│         //                                                                                                                                                                                                      │
│         // If M does not fit, then the intermediate results for some term may                                                                                                                                   │
│         // eventually overflow, but this cannot happen at the first term, and                                                                                                                                   │
│         // neither can the total overflow because it uses checked math.                                                                                                                                         │
│         //                                                                                                                                                                                                      │
│         // This constitutes a guarantee of specified behavior when M >= 2^128.                                                                                                                                  │
│         uint256 x = uint256(t) * aprBPS;                                                                                                                                                                        │
│         uint256 term_k = (principal * x) / YEAR_BPS;                                                                                                                                                            │
│         uint256 denom_k = YEAR_BPS;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         interest = term_k;                                                                                                                                                                                      │
│         for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {                                                                                                                                                │
│             denom_k += YEAR_BPS;                                                                                                                                                                                │
│             term_k = (term_k * x) / denom_k;                                                                                                                                                                    │
│             interest = interest.add(term_k); // <- Only overflow check we need                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (interest >= 2**128) {                                                                                                                                                                               │
│             revert();                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 term_k = (principal * x) / YEAR_BPS;`                                                                                                                                                                  │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:47:45] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/contracts/NFTPairWithOracle.sol, current     tasks.py:260
                             function: calculateInterest, current vul: wrong-order-interest                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();`                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {                                                                                                                                │
│         TokenLoan memory loan = tokenLoan;                                                                                                                                                                      │
│         require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");                                                                                                                                           │
│         TokenLoanParams memory loanParams = tokenLoanParams;                                                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             // Addition is safe: both summands are smaller than 256 bits                                                                                                                                        │
│             uint256(loan.startTime) + loanParams.duration > block.timestamp,                                                                                                                                    │
│             "NFTPair: loan expired"                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint128 principal = loanParams.valuation;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // No underflow: loan.startTime is only ever set to a block timestamp                                                                                                                                   │
│         // Cast is safe: if this overflows, then all loans have expired anyway                                                                                                                                  │
│         uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();                                                                        │
│         uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;                                                                                                                                                      │
│         amount = principal + interest;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 totalShare = bentoBox.toShare(asset, amount, false);                                                                                                                                            │
│         uint256 feeShare = bentoBox.toShare(asset, fee, false);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         address from;                                                                                                                                                                                           │
│         if (skim) {                                                                                                                                                                                             │
│             require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");                                                                                      │
│             from = address(this);                                                                                                                                                                               │
│             // No overflow: result fits in BentoBox                                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             bentoBox.transfer(asset, msg.sender, address(this), feeShare);                                                                                                                                      │
│             from = msg.sender;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // No underflow: PROTOCOL_FEE_BPS < BPS by construction.                                                                                                                                                │
│         feesEarnedShare += feeShare;                                                                                                                                                                            │
│         delete tokenLoan;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);                                                                                                                                     │
│         collateral.transferFrom(address(this), loan.borrower, tokenId);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LogRepay(from, tokenId);                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `amount = principal + interest;`                                                                                                                                                                                │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:47:46] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/contracts/NFTPairWithOracle.sol, current     tasks.py:260
                             function: repay, current vul: wrong-order-interest                                                                                                                                    
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "share": "Holds the value of total minted share or amount"                                                                                                                                              │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "total": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                                │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:47:47] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/contracts/BentoBoxFlat.sol, current          tasks.py:260
                             function: deposit, current vul: first-deposit                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "from": "Variable from holds the sender's address of transfer"                                                                                                                                              │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:47:48] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/contracts/BentoBoxFlat.sol, current          tasks.py:260
                             function: transfer, current vul: unauthorized-transfer                                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function harvest(                                                                                                                                                                                           │
│         IERC20 token,                                                                                                                                                                                           │
│         bool balance,                                                                                                                                                                                           │
│         uint256 maxChangeAmount                                                                                                                                                                                 │
│     ) public {                                                                                                                                                                                                  │
│         StrategyData memory data = strategyData;                                                                                                                                                                │
│         IStrategy _strategy = strategy;                                                                                                                                                                         │
│         int256 balanceChange = _strategy.harvest(data.balance, msg.sender);                                                                                                                                     │
│         if (balanceChange == 0 && !balance) {                                                                                                                                                                   │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalElastic = totals.elastic;                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (balanceChange > 0) {                                                                                                                                                                                │
│             uint256 add = uint256(balanceChange);                                                                                                                                                               │
│             totalElastic = totalElastic.add(add);                                                                                                                                                               │
│             totals.elastic = totalElastic.to128();                                                                                                                                                              │
│             emit LogStrategyProfit(token, add);                                                                                                                                                                 │
│         } else if (balanceChange < 0) {                                                                                                                                                                         │
│             // C1 - All math done through BoringMath (SWC-101)                                                                                                                                                  │
│             // C1: balanceChange could overflow if it's max negative int128.                                                                                                                                    │
│             // But tokens with balances that large are not supported by the BentoBox.                                                                                                                           │
│             uint256 sub = uint256(-balanceChange);                                                                                                                                                              │
│             totalElastic = totalElastic.sub(sub);                                                                                                                                                               │
│             totals.elastic = totalElastic.to128();                                                                                                                                                              │
│             data.balance = data.balance.sub(sub.to128());                                                                                                                                                       │
│             emit LogStrategyLoss(token, sub);                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (balance) {                                                                                                                                                                                          │
│             uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;                                                                                                                              │
│             // if data.balance == targetBalance there is nothing to update                                                                                                                                      │
│             if (data.balance < targetBalance) {                                                                                                                                                                 │
│                 uint256 amountOut = targetBalance.sub(data.balance);                                                                                                                                            │
│                 if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {                                                                                                                                      │
│                     amountOut = maxChangeAmount;                                                                                                                                                                │
│                 }                                                                                                                                                                                               │
│                 token.safeTransfer(address(_strategy), amountOut);                                                                                                                                              │
│                 data.balance = data.balance.add(amountOut.to128());                                                                                                                                             │
│                 _strategy.skim(amountOut);                                                                                                                                                                      │
│                 emit LogStrategyInvest(token, amountOut);                                                                                                                                                       │
│             } else if (data.balance > targetBalance) {                                                                                                                                                          │
│                 uint256 amountIn = data.balance.sub(targetBalance.to128());                                                                                                                                     │
│                 if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {                                                                                                                                       │
│                     amountIn = maxChangeAmount;                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 uint256 actualAmountIn = _strategy.withdraw(amountIn);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│                 data.balance = data.balance.sub(actualAmountIn.to128());                                                                                                                                        │
│                 emit LogStrategyDivest(token, actualAmountIn);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         strategyData = data;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is the statement inside the backquotes: `totalElastic = totalElastic.add(add);`.                                                                    │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function harvest(                                                                                                                                                                                           │
│         IERC20 token,                                                                                                                                                                                           │
│         bool balance,                                                                                                                                                                                           │
│         uint256 maxChangeAmount                                                                                                                                                                                 │
│     ) public {                                                                                                                                                                                                  │
│         StrategyData memory data = strategyData;                                                                                                                                                                │
│         IStrategy _strategy = strategy;                                                                                                                                                                         │
│         int256 balanceChange = _strategy.harvest(data.balance, msg.sender);                                                                                                                                     │
│         if (balanceChange == 0 && !balance) {                                                                                                                                                                   │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 totalElastic = totals.elastic;                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (balanceChange > 0) {                                                                                                                                                                                │
│             uint256 add = uint256(balanceChange);                                                                                                                                                               │
│             totalElastic = totalElastic.add(add);                                                                                                                                                               │
│             totals.elastic = totalElastic.to128();                                                                                                                                                              │
│             emit LogStrategyProfit(token, add);                                                                                                                                                                 │
│         } else if (balanceChange < 0) {                                                                                                                                                                         │
│             // C1 - All math done through BoringMath (SWC-101)                                                                                                                                                  │
│             // C1: balanceChange could overflow if it's max negative int128.                                                                                                                                    │
│             // But tokens with balances that large are not supported by the BentoBox.                                                                                                                           │
│             uint256 sub = uint256(-balanceChange);                                                                                                                                                              │
│             totalElastic = totalElastic.sub(sub);                                                                                                                                                               │
│             totals.elastic = totalElastic.to128();                                                                                                                                                              │
│             data.balance = data.balance.sub(sub.to128());                                                                                                                                                       │
│             emit LogStrategyLoss(token, sub);                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (balance) {                                                                                                                                                                                          │
│             uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;                                                                                                                              │
│             // if data.balance == targetBalance there is nothing to update                                                                                                                                      │
│             if (data.balance < targetBalance) {                                                                                                                                                                 │
│                 uint256 amountOut = targetBalance.sub(data.balance);                                                                                                                                            │
│                 if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {                                                                                                                                      │
│                     amountOut = maxChangeAmount;                                                                                                                                                                │
│                 }                                                                                                                                                                                               │
│                 token.safeTransfer(address(_strategy), amountOut);                                                                                                                                              │
│                 data.balance = data.balance.add(amountOut.to128());                                                                                                                                             │
│                 _strategy.skim(amountOut);                                                                                                                                                                      │
│                 emit LogStrategyInvest(token, amountOut);                                                                                                                                                       │
│             } else if (data.balance > targetBalance) {                                                                                                                                                          │
│                 uint256 amountIn = data.balance.sub(targetBalance.to128());                                                                                                                                     │
│                 if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {                                                                                                                                       │
│                     amountIn = maxChangeAmount;                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 uint256 actualAmountIn = _strategy.withdraw(amountIn);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│                 data.balance = data.balance.sub(actualAmountIn.to128());                                                                                                                                        │
│                 emit LogStrategyDivest(token, actualAmountIn);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         strategyData = data;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `totals.elastic = totalElastic.to128();`                                                                                                                                                                        │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:47:49] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-abranft-main/contracts/BentoBoxFlat.sol, current          tasks.py:260
                             function: harvest, current vul: wrong-order-interest                                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                   Summary                   
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value              ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 12                 │
│ Contracts            │ 35                 │
│ Functions            │ 50                 │
│ Lines of Code        │ 2968               │
│ Used Time            │ 305.88033843040466 │
│ Estimated Cost (USD) │ 0.061608           │
└──────────────────────┴────────────────────┘
