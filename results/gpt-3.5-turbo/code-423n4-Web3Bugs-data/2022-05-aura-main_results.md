

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[19:58:04] Loaded 10 rules                                                                                                                                                                             tasks.py:119
[12/08/24 19:58:04] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-05-aura-main)                 subprocess.py:41
[12/08/24 19:58:06] ERROR    CryticCompile: 'npx' returned non-zero exit code 127                                                                                                                  subprocess.py:60
                    ERROR    CryticCompile: sh: 1: hardhat: not found                                                                                                                              subprocess.py:68
                    INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-05-aura-main)        subprocess.py:41
[12/08/24 19:58:08] ERROR    CryticCompile: 'npx' returned non-zero exit code 127                                                                                                                  subprocess.py:60
                    ERROR    CryticCompile: sh: 1: hardhat: not found                                                                                                                              subprocess.py:68
[12/08/24 19:58:11] INFO     CryticCompile: Problem executing hardhat: sh: 1: hardhat: not found                                                                                                     hardhat.py:327
                                                                                                                                                                                                                   
                    INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-05-aura-main)       subprocess.py:41
[12/08/24 19:58:13] ERROR    CryticCompile: 'npx' returned non-zero exit code 127                                                                                                                  subprocess.py:60
                    ERROR    CryticCompile: sh: 1: hardhat: not found                                                                                                                              subprocess.py:68
[12/08/24 19:58:19] INFO     antlr4helper.callgraph: In whitelist: ERC4626._approve(address,address,uint) returns()                                                                                 callgraph.py:21
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external{                                                                                                                                                        │
│         require(msg.sender == operator, "!authorized");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedRewards);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));                                                                                                                                  │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rewardRate * elapsedTime;                                                                                                                                                        │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│         if(queuedRatio < newRewardRatio){                                                                                                                                                                       │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│         }else{                                                                                                                                                                                                  │
│             queuedRewards = _rewards;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external{                                                                                                                                                        │
│         require(msg.sender == operator, "!authorized");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedRewards);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));                                                                                                                                  │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rewardRate * elapsedTime;                                                                                                                                                        │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│         if(queuedRatio < newRewardRatio){                                                                                                                                                                       │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│         }else{                                                                                                                                                                                                  │
│             queuedRewards = _rewards;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(uint256 reward)                                                                                                                                                                 │
│         internal                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         historicalRewards = historicalRewards.add(reward);                                                                                                                                                      │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = periodFinish.sub(block.timestamp);                                                                                                                                              │
│             uint256 leftover = remaining.mul(rewardRate);                                                                                                                                                       │
│             reward = reward.add(leftover);                                                                                                                                                                      │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         currentRewards = reward;                                                                                                                                                                                │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│         emit RewardAdded(reward);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(uint256 reward)                                                                                                                                                                 │
│         internal                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         historicalRewards = historicalRewards.add(reward);                                                                                                                                                      │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = periodFinish.sub(block.timestamp);                                                                                                                                              │
│             uint256 leftover = remaining.mul(rewardRate);                                                                                                                                                       │
│             reward = reward.add(leftover);                                                                                                                                                                      │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         currentRewards = reward;                                                                                                                                                                                │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│         emit RewardAdded(reward);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function processStash() external returns(bool){                                                                                                                                                             │
│         require(msg.sender == operator, "!operator");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 tCount = tokenList.length;                                                                                                                                                                      │
│         for(uint i=0; i < tCount; i++){                                                                                                                                                                         │
│             TokenInfo storage t = tokenInfo[tokenList];                                                                                                                                                         │
│             address token = t.token;                                                                                                                                                                            │
│             if(token == address(0)) continue;                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             uint256 amount = IERC20(token).balanceOf(address(this));                                                                                                                                            │
│             if (amount > 0) {                                                                                                                                                                                   │
│                 historicalRewards = historicalRewards.add(amount);                                                                                                                                              │
│                 if(token == crv){                                                                                                                                                                               │
│                     //if crv, send back to booster to distribute                                                                                                                                                │
│                     IERC20(token).safeTransfer(operator, amount);                                                                                                                                               │
│                     continue;                                                                                                                                                                                   │
│                 }                                                                                                                                                                                               │
│                 //add to reward contract                                                                                                                                                                        │
│                 address rewards = t.rewardAddress;                                                                                                                                                              │
│                 if(rewards == address(0)) continue;                                                                                                                                                             │
│                 IERC20(token).safeTransfer(rewards, amount);                                                                                                                                                    │
│                 IRewards(rewards).queueNewRewards(amount);                                                                                                                                                      │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _earmarkRewards(uint256 _pid) internal {                                                                                                                                                           │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //claim crv                                                                                                                                                                                             │
│         IStaker(staker).claimCrv(gauge);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //check if there are extra rewards                                                                                                                                                                      │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             //claim extra rewards                                                                                                                                                                               │
│             IStash(stash).claimRewards();                                                                                                                                                                       │
│             //process extra rewards                                                                                                                                                                             │
│             IStash(stash).processStash();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //crv balance                                                                                                                                                                                           │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             // LockIncentive = cvxCrv stakers (currently 10%)                                                                                                                                                   │
│             uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             // StakerIncentive = cvx stakers (currently 5%)                                                                                                                                                     │
│             uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);                                                                                                                        │
│             // CallIncentive = caller of this contract (currently 1%)                                                                                                                                           │
│             uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);                                                                                                                         │
│                                                                                                                                                                                                                 │
│             // Treasury = vlCVX (currently 1%)                                                                                                                                                                  │
│             if(treasury != address(0) && treasury != address(this) && platformFee > 0){                                                                                                                         │
│                 //only subtract after address condition check                                                                                                                                                   │
│                 uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);                                                                                                                               │
│                 crvBal = crvBal.sub(_platform);                                                                                                                                                                 │
│                 IERC20(crv).safeTransfer(treasury, _platform);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //remove incentives from balance                                                                                                                                                                    │
│             crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);                                                                                                                      │
│                                                                                                                                                                                                                 │
│             //send incentives for calling                                                                                                                                                                       │
│             IERC20(crv).safeTransfer(msg.sender, _callIncentive);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send crv to lp provider reward contract                                                                                                                                                           │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(crv).safeTransfer(rewardContract, crvBal);                                                                                                                                                   │
│             IRewards(rewardContract).queueNewRewards(crvBal);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //send lockers' share of crv to reward contract                                                                                                                                                     │
│             IERC20(crv).safeTransfer(lockRewards, _lockIncentive);                                                                                                                                              │
│             IRewards(lockRewards).queueNewRewards(_lockIncentive);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             //send stakers's share of crv to reward contract                                                                                                                                                    │
│             IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function processStash() external returns(bool){                                                                                                                                                             │
│         require(msg.sender == operator, "!operator");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 tCount = tokenList.length;                                                                                                                                                                      │
│         for(uint i=0; i < tCount; i++){                                                                                                                                                                         │
│             TokenInfo storage t = tokenInfo[tokenList];                                                                                                                                                         │
│             address token = t.token;                                                                                                                                                                            │
│             if(token == address(0)) continue;                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             uint256 amount = IERC20(token).balanceOf(address(this));                                                                                                                                            │
│             if (amount > 0) {                                                                                                                                                                                   │
│                 historicalRewards = historicalRewards.add(amount);                                                                                                                                              │
│                 if(token == crv){                                                                                                                                                                               │
│                     //if crv, send back to booster to distribute                                                                                                                                                │
│                     IERC20(token).safeTransfer(operator, amount);                                                                                                                                               │
│                     continue;                                                                                                                                                                                   │
│                 }                                                                                                                                                                                               │
│                 //add to reward contract                                                                                                                                                                        │
│                 address rewards = t.rewardAddress;                                                                                                                                                              │
│                 if(rewards == address(0)) continue;                                                                                                                                                             │
│                 IERC20(token).safeTransfer(rewards, amount);                                                                                                                                                    │
│                 IRewards(rewards).queueNewRewards(amount);                                                                                                                                                      │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distribute() external {                                                                                                                                                                            │
│         // If keeper enabled, require                                                                                                                                                                           │
│         if (keeper != address(0)) {                                                                                                                                                                             │
│             require(msg.sender == keeper, "!auth");                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //convert crv to cvxCrv                                                                                                                                                                                 │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             uint256 minOut = ICrvDepositorWrapper(crvDepositorWrapper).getMinOut(crvBal, outputBps);                                                                                                            │
│             ICrvDepositorWrapper(crvDepositorWrapper).deposit(crvBal, minOut, true, address(0));                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //distribute cvxcrv                                                                                                                                                                                     │
│         uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBal > 0) {                                                                                                                                                                                    │
│             uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);                                                                                                                            │
│             cvxCrvBal = cvxCrvBal.sub(incentiveAmount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             IERC20(cvxCrv).safeTransfer(msg.sender, incentiveAmount);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             IAuraLocker(rewards).queueNewRewards(cvxCrvBal);                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(cvxCrv, cvxCrvBal);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){                                                                                                                          │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //send to proxy to stake                                                                                                                                                                                │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //stake                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│         require(gauge != address(0),"!gauge setting");                                                                                                                                                          │
│         IStaker(staker).deposit(lptoken,gauge);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when depositing, stash them in a seperate contract until next claim                                                                                                         │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address token = pool.token;                                                                                                                                                                             │
│         if(_stake){                                                                                                                                                                                             │
│             //mint here and send to rewards on user behalf                                                                                                                                                      │
│             ITokenMinter(token).mint(address(this),_amount);                                                                                                                                                    │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(token).safeApprove(rewardContract,0);                                                                                                                                                        │
│             IERC20(token).safeApprove(rewardContract,_amount);                                                                                                                                                  │
│             IRewards(rewardContract).stakeFor(msg.sender,_amount);                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //add user balance directly                                                                                                                                                                         │
│             ITokenMinter(token).mint(msg.sender,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Deposited(msg.sender, _pid, _amount);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositAll(uint256 _pid, bool _stake) external returns(bool){                                                                                                                                      │
│         address lptoken = poolInfo[_pid].lptoken;                                                                                                                                                               │
│         uint256 balance = IERC20(lptoken).balanceOf(msg.sender);                                                                                                                                                │
│         deposit(_pid,balance,_stake);                                                                                                                                                                           │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _claimExtras( // solhint-disable-line                                                                                                                                                              │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 removeCrvBalance,                                                                                                                                                                               │
│         uint256 removeCvxBalance,                                                                                                                                                                               │
│         uint256 options                                                                                                                                                                                         │
│     ) internal {                                                                                                                                                                                                │
│         //claim from cvxCrv rewards                                                                                                                                                                             │
│         if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {                                                                                                                                              │
│             IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //claim from locker                                                                                                                                                                                     │
│         if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {                                                                                                                                           │
│             IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //reset remove balances if we want to also stake/lock funds already in our wallet                                                                                                                       │
│         if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {                                                                                                                                        │
│             removeCrvBalance = 0;                                                                                                                                                                               │
│             removeCvxBalance = 0;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //lock upto given amount of crv and stake                                                                                                                                                               │
│         if (depositCrvMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);                                                                                                                       │
│             crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             if (crvBalance > 0) {                                                                                                                                                                               │
│                 //pull crv                                                                                                                                                                                      │
│                 IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);                                                                                                                            │
│                 //deposit                                                                                                                                                                                       │
│                 ICrvDepositorWrapper(crvDepositWrapper).deposit(                                                                                                                                                │
│                     crvBalance,                                                                                                                                                                                 │
│                     minAmountOut,                                                                                                                                                                               │
│                     _checkOption(options, uint256(Options.LockCrvDeposit)),                                                                                                                                     │
│                     address(0)                                                                                                                                                                                  │
│                 );                                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                │
│                 //stake for msg.sender                                                                                                                                                                          │
│                 IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //stake up to given amount of cvx                                                                                                                                                                       │
│         if (depositCvxMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);                                                                                                                       │
│             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);                                                                                                                                         │
│             if (cvxBalance > 0) {                                                                                                                                                                               │
│                 //pull cvx                                                                                                                                                                                      │
│                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                                                                                                                            │
│                 if (_checkOption(options, uint256(Options.LockCvx))) {                                                                                                                                          │
│                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                                                                                                                                           │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         if (_balance < _amount) {                                                                                                                                                                               │
│             _amount = _withdrawSome(_gauge, _amount.sub(_balance));                                                                                                                                             │
│             _amount = _amount.add(_balance);                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         IERC20(_token).safeTransfer(msg.sender, _amount);                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //remove lp balance                                                                                                                                                                                     │
│         address token = pool.token;                                                                                                                                                                             │
│         ITokenMinter(token).burn(_from,_amount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //pull from gauge if not shutdown                                                                                                                                                                       │
│         // if shutdown tokens will be in this contract                                                                                                                                                          │
│         if (!pool.shutdown) {                                                                                                                                                                                   │
│             IStaker(staker).withdraw(lptoken,gauge, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim                                                                                                        │
│         //do not call if shutdown since stashes wont have access                                                                                                                                                │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0) && !isShutdown && !pool.shutdown){                                                                                                                                               │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //return lp tokens                                                                                                                                                                                      │
│         IERC20(lptoken).safeTransfer(_to, _amount);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_to, _pid, _amount);                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│     function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         if (_balance < _amount) {                                                                                                                                                                               │
│             _amount = _withdrawSome(_gauge, _amount.sub(_balance));                                                                                                                                             │
│             _amount = _amount.add(_balance);                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         IERC20(_token).safeTransfer(msg.sender, _amount);                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(address _token, address _gauge) external returns(bool){                                                                                                                                │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));                                                                                                                    │
│         withdraw(_token, _gauge, amount);                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         if (_balance < _amount) {                                                                                                                                                                               │
│             _amount = _withdrawSome(_gauge, _amount.sub(_balance));                                                                                                                                             │
│             _amount = _amount.add(_balance);                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         IERC20(_token).safeTransfer(msg.sender, _amount);                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         if (_balance < _amount) {                                                                                                                                                                               │
│             _amount = _withdrawSome(_gauge, _amount.sub(_balance));                                                                                                                                             │
│             _amount = _amount.add(_balance);                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         IERC20(_token).safeTransfer(msg.sender, _amount);                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         if (_balance < _amount) {                                                                                                                                                                               │
│             _amount = _withdrawSome(_gauge, _amount.sub(_balance));                                                                                                                                             │
│             _amount = _amount.add(_balance);                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         IERC20(_token).safeTransfer(msg.sender, _amount);                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(uint256 _pid) public returns(bool){                                                                                                                                                    │
│         address token = poolInfo[_pid].token;                                                                                                                                                                   │
│         uint256 userBal = IERC20(token).balanceOf(msg.sender);                                                                                                                                                  │
│         withdraw(_pid, userBal);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         if (_balance < _amount) {                                                                                                                                                                               │
│             _amount = _withdrawSome(_gauge, _amount.sub(_balance));                                                                                                                                             │
│             _amount = _amount.add(_balance);                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         IERC20(_token).safeTransfer(msg.sender, _amount);                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function release() external returns(bool){                                                                                                                                                                  │
│         require(msg.sender == depositor, "!auth");                                                                                                                                                              │
│         ICurveVoteEscrow(escrow).withdraw();                                                                                                                                                                    │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         if (_balance < _amount) {                                                                                                                                                                               │
│             _amount = _withdrawSome(_gauge, _amount.sub(_balance));                                                                                                                                             │
│             _amount = _amount.add(_balance);                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         IERC20(_token).safeTransfer(msg.sender, _amount);                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(address _token, address _gauge) external returns(bool){                                                                                                                                │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));                                                                                                                    │
│         withdraw(_token, _gauge, amount);                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function shutdownSystem() external{                                                                                                                                                                         │
│         require(msg.sender == owner, "!auth");                                                                                                                                                                  │
│         isShutdown = true;                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         for(uint i=0; i < poolInfo.length; i++){                                                                                                                                                                │
│             PoolInfo storage pool = poolInfo;                                                                                                                                                                   │
│             if (pool.shutdown) continue;                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             address token = pool.lptoken;                                                                                                                                                                       │
│             address gauge = pool.gauge;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //withdraw from gauge                                                                                                                                                                               │
│             try IStaker(staker).withdrawAll(token,gauge){                                                                                                                                                       │
│                 pool.shutdown = true;                                                                                                                                                                           │
│             }catch{}                                                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function withdrawAll(address _token, address _gauge) external returns(bool){                                                                                                                                │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));                                                                                                                    │
│         withdraw(_token, _gauge, amount);                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function shutdownPool(uint256 _pid) external returns(bool){                                                                                                                                                 │
│         require(msg.sender==poolManager, "!auth");                                                                                                                                                              │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //withdraw from gauge                                                                                                                                                                                   │
│         try IStaker(staker).withdrawAll(pool.lptoken,pool.gauge){                                                                                                                                               │
│         }catch{}                                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         pool.shutdown = true;                                                                                                                                                                                   │
│         gaugeMap = false;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit PoolShutdown(_pid);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdrawAll(address _token, address _gauge) external returns(bool){                                                                                                                                │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));                                                                                                                    │
│         withdraw(_token, _gauge, amount);                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: calculate vote amount/number                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                           │
│     function voteGaugeWeight(address _gauge, uint256 _weight) external returns(bool){                                                                                                                           │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //vote                                                                                                                                                                                                  │
│         IVoting(gaugeController).vote_for_gauge_weights(_gauge, _weight);                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: calculate vote amount/number                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                           │
│     function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool){                                                                                                    │
│         require(msg.sender == voteDelegate, "!auth");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         for(uint256 i = 0; i < _gauge.length; i++){                                                                                                                                                             │
│             IStaker(staker).voteGaugeWeight(_gauge,_weight);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function voteGaugeWeight(address _gauge, uint256 _weight) external returns(bool){                                                                                                                           │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //vote                                                                                                                                                                                                  │
│         IVoting(gaugeController).vote_for_gauge_weights(_gauge, _weight);                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimCrv(address _gauge) external returns (uint256){                                                                                                                                               │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 _balance = 0;                                                                                                                                                                                   │
│         try IMinter(mintr).mint(_gauge){                                                                                                                                                                        │
│             _balance = IERC20(crv).balanceOf(address(this));                                                                                                                                                    │
│             IERC20(crv).safeTransfer(operator, _balance);                                                                                                                                                       │
│         }catch{}                                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         return _balance;                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _earmarkRewards(uint256 _pid) internal {                                                                                                                                                           │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //claim crv                                                                                                                                                                                             │
│         IStaker(staker).claimCrv(gauge);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //check if there are extra rewards                                                                                                                                                                      │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             //claim extra rewards                                                                                                                                                                               │
│             IStash(stash).claimRewards();                                                                                                                                                                       │
│             //process extra rewards                                                                                                                                                                             │
│             IStash(stash).processStash();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //crv balance                                                                                                                                                                                           │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             // LockIncentive = cvxCrv stakers (currently 10%)                                                                                                                                                   │
│             uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             // StakerIncentive = cvx stakers (currently 5%)                                                                                                                                                     │
│             uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);                                                                                                                        │
│             // CallIncentive = caller of this contract (currently 1%)                                                                                                                                           │
│             uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);                                                                                                                         │
│                                                                                                                                                                                                                 │
│             // Treasury = vlCVX (currently 1%)                                                                                                                                                                  │
│             if(treasury != address(0) && treasury != address(this) && platformFee > 0){                                                                                                                         │
│                 //only subtract after address condition check                                                                                                                                                   │
│                 uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);                                                                                                                               │
│                 crvBal = crvBal.sub(_platform);                                                                                                                                                                 │
│                 IERC20(crv).safeTransfer(treasury, _platform);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //remove incentives from balance                                                                                                                                                                    │
│             crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);                                                                                                                      │
│                                                                                                                                                                                                                 │
│             //send incentives for calling                                                                                                                                                                       │
│             IERC20(crv).safeTransfer(msg.sender, _callIncentive);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send crv to lp provider reward contract                                                                                                                                                           │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(crv).safeTransfer(rewardContract, crvBal);                                                                                                                                                   │
│             IRewards(rewardContract).queueNewRewards(crvBal);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //send lockers' share of crv to reward contract                                                                                                                                                     │
│             IERC20(crv).safeTransfer(lockRewards, _lockIncentive);                                                                                                                                              │
│             IRewards(lockRewards).queueNewRewards(_lockIncentive);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             //send stakers's share of crv to reward contract                                                                                                                                                    │
│             IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function claimCrv(address _gauge) external returns (uint256){                                                                                                                                               │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 _balance = 0;                                                                                                                                                                                   │
│         try IMinter(mintr).mint(_gauge){                                                                                                                                                                        │
│             _balance = IERC20(crv).balanceOf(address(this));                                                                                                                                                    │
│             IERC20(crv).safeTransfer(operator, _balance);                                                                                                                                                       │
│         }catch{}                                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         return _balance;                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimFees(address _distroContract, address _token) external returns (uint256){                                                                                                                     │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         IFeeDistributor(_distroContract).claimToken(address(this), _token);                                                                                                                                     │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         IERC20(_token).safeTransfer(operator, _balance);                                                                                                                                                        │
│         return _balance;                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function earmarkFees(address _feeToken) external returns(bool){                                                                                                                                             │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         FeeDistro memory feeDistro = feeTokens[_feeToken];                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         require(feeDistro.active, "Inactive distro");                                                                                                                                                           │
│         require(!gaugeMap[_feeToken], "Invalid token");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //claim fee rewards                                                                                                                                                                                     │
│         uint256 tokenBalanceBefore = IERC20(_feeToken).balanceOf(address(this));                                                                                                                                │
│         IStaker(staker).claimFees(feeDistro.distro, _feeToken);                                                                                                                                                 │
│         uint256 tokenBalanceAfter = IERC20(_feeToken).balanceOf(address(this));                                                                                                                                 │
│         uint256 feesClaimed = tokenBalanceAfter.sub(tokenBalanceBefore);                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send fee rewards to reward contract                                                                                                                                                                   │
│         IERC20(_feeToken).safeTransfer(feeDistro.rewards, feesClaimed);                                                                                                                                         │
│         IRewards(feeDistro.rewards).queueNewRewards(feesClaimed);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function claimFees(address _distroContract, address _token) external returns (uint256){                                                                                                                     │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         IFeeDistributor(_distroContract).claimToken(address(this), _token);                                                                                                                                     │
│         uint256 _balance = IERC20(_token).balanceOf(address(this));                                                                                                                                             │
│         IERC20(_token).safeTransfer(operator, _balance);                                                                                                                                                        │
│         return _balance;                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function pendingCvx(uint256 _pid, address _user)                                                                                                                                                            │
│         external                                                                                                                                                                                                │
│         view                                                                                                                                                                                                    │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid][_user];                                                                                                                                                          │
│         uint256 accCvxPerShare = pool.accCvxPerShare;                                                                                                                                                           │
│         uint256 lpSupply = pool.lpToken.balanceOf(address(this));                                                                                                                                               │
│         if (block.number > pool.lastRewardBlock && lpSupply != 0) {                                                                                                                                             │
│             uint256 multiplier = getMultiplier(                                                                                                                                                                 │
│                 pool.lastRewardBlock,                                                                                                                                                                           │
│                 block.number                                                                                                                                                                                    │
│             );                                                                                                                                                                                                  │
│             uint256 cvxReward = multiplier                                                                                                                                                                      │
│                 .mul(rewardPerBlock)                                                                                                                                                                            │
│                 .mul(pool.allocPoint)                                                                                                                                                                           │
│                 .div(totalAllocPoint);                                                                                                                                                                          │
│             accCvxPerShare = accCvxPerShare.add(                                                                                                                                                                │
│                 cvxReward.mul(1e12).div(lpSupply)                                                                                                                                                               │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);                                                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function updatePool(uint256 _pid) public {                                                                                                                                                                  │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         if (block.number <= pool.lastRewardBlock) {                                                                                                                                                             │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 lpSupply = pool.lpToken.balanceOf(address(this));                                                                                                                                               │
│         if (lpSupply == 0) {                                                                                                                                                                                    │
│             pool.lastRewardBlock = block.number;                                                                                                                                                                │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);                                                                                                                                 │
│         uint256 cvxReward = multiplier                                                                                                                                                                          │
│             .mul(rewardPerBlock)                                                                                                                                                                                │
│             .mul(pool.allocPoint)                                                                                                                                                                               │
│             .div(totalAllocPoint);                                                                                                                                                                              │
│         //cvx.mint(address(this), cvxReward);                                                                                                                                                                   │
│         pool.accCvxPerShare = pool.accCvxPerShare.add(                                                                                                                                                          │
│             cvxReward.mul(1e12).div(lpSupply)                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         pool.lastRewardBlock = block.number;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function claim(uint256 _pid, address _account) external{                                                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid][_account];                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         updatePool(_pid);                                                                                                                                                                                       │
│         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(                                                                                                                                   │
│             user.rewardDebt                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         safeRewardTransfer(_account, pending);                                                                                                                                                                  │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, _account, _account, pending, user.amount);                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardPaid(_account, _pid, pending);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function updatePool(uint256 _pid) public {                                                                                                                                                                  │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         if (block.number <= pool.lastRewardBlock) {                                                                                                                                                             │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 lpSupply = pool.lpToken.balanceOf(address(this));                                                                                                                                               │
│         if (lpSupply == 0) {                                                                                                                                                                                    │
│             pool.lastRewardBlock = block.number;                                                                                                                                                                │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);                                                                                                                                 │
│         uint256 cvxReward = multiplier                                                                                                                                                                          │
│             .mul(rewardPerBlock)                                                                                                                                                                                │
│             .mul(pool.allocPoint)                                                                                                                                                                               │
│             .div(totalAllocPoint);                                                                                                                                                                              │
│         //cvx.mint(address(this), cvxReward);                                                                                                                                                                   │
│         pool.accCvxPerShare = pool.accCvxPerShare.add(                                                                                                                                                          │
│             cvxReward.mul(1e12).div(lpSupply)                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         pool.lastRewardBlock = block.number;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount) public {                                                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid];                                                                                                                                                                 │
│         updatePool(_pid);                                                                                                                                                                                       │
│         if (user.amount > 0) {                                                                                                                                                                                  │
│             uint256 pending = user                                                                                                                                                                              │
│                 .amount                                                                                                                                                                                         │
│                 .mul(pool.accCvxPerShare)                                                                                                                                                                       │
│                 .div(1e12)                                                                                                                                                                                      │
│                 .sub(user.rewardDebt);                                                                                                                                                                          │
│             safeRewardTransfer(msg.sender, pending);                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│         pool.lpToken.safeTransferFrom(                                                                                                                                                                          │
│             address(msg.sender),                                                                                                                                                                                │
│             address(this),                                                                                                                                                                                      │
│             _amount                                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│         user.amount = user.amount.add(_amount);                                                                                                                                                                 │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, _pid, _amount);                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function updatePool(uint256 _pid) public {                                                                                                                                                                  │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         if (block.number <= pool.lastRewardBlock) {                                                                                                                                                             │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 lpSupply = pool.lpToken.balanceOf(address(this));                                                                                                                                               │
│         if (lpSupply == 0) {                                                                                                                                                                                    │
│             pool.lastRewardBlock = block.number;                                                                                                                                                                │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);                                                                                                                                 │
│         uint256 cvxReward = multiplier                                                                                                                                                                          │
│             .mul(rewardPerBlock)                                                                                                                                                                                │
│             .mul(pool.allocPoint)                                                                                                                                                                               │
│             .div(totalAllocPoint);                                                                                                                                                                              │
│         //cvx.mint(address(this), cvxReward);                                                                                                                                                                   │
│         pool.accCvxPerShare = pool.accCvxPerShare.add(                                                                                                                                                          │
│             cvxReward.mul(1e12).div(lpSupply)                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         pool.lastRewardBlock = block.number;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount) public {                                                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid];                                                                                                                                                                 │
│         updatePool(_pid);                                                                                                                                                                                       │
│         if (user.amount > 0) {                                                                                                                                                                                  │
│             uint256 pending = user                                                                                                                                                                              │
│                 .amount                                                                                                                                                                                         │
│                 .mul(pool.accCvxPerShare)                                                                                                                                                                       │
│                 .div(1e12)                                                                                                                                                                                      │
│                 .sub(user.rewardDebt);                                                                                                                                                                          │
│             safeRewardTransfer(msg.sender, pending);                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│         pool.lpToken.safeTransferFrom(                                                                                                                                                                          │
│             address(msg.sender),                                                                                                                                                                                │
│             address(this),                                                                                                                                                                                      │
│             _amount                                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│         user.amount = user.amount.add(_amount);                                                                                                                                                                 │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, _pid, _amount);                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function updatePool(uint256 _pid) public {                                                                                                                                                                  │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         if (block.number <= pool.lastRewardBlock) {                                                                                                                                                             │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 lpSupply = pool.lpToken.balanceOf(address(this));                                                                                                                                               │
│         if (lpSupply == 0) {                                                                                                                                                                                    │
│             pool.lastRewardBlock = block.number;                                                                                                                                                                │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);                                                                                                                                 │
│         uint256 cvxReward = multiplier                                                                                                                                                                          │
│             .mul(rewardPerBlock)                                                                                                                                                                                │
│             .mul(pool.allocPoint)                                                                                                                                                                               │
│             .div(totalAllocPoint);                                                                                                                                                                              │
│         //cvx.mint(address(this), cvxReward);                                                                                                                                                                   │
│         pool.accCvxPerShare = pool.accCvxPerShare.add(                                                                                                                                                          │
│             cvxReward.mul(1e12).div(lpSupply)                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         pool.lastRewardBlock = block.number;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _pid, uint256 _amount) public {                                                                                                                                                   │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid];                                                                                                                                                                 │
│         require(user.amount >= _amount, "withdraw: not good");                                                                                                                                                  │
│         updatePool(_pid);                                                                                                                                                                                       │
│         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(                                                                                                                                   │
│             user.rewardDebt                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         safeRewardTransfer(msg.sender, pending);                                                                                                                                                                │
│         user.amount = user.amount.sub(_amount);                                                                                                                                                                 │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│         pool.lpToken.safeTransfer(address(msg.sender), _amount);                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardPaid(msg.sender, _pid, pending);                                                                                                                                                             │
│         emit Withdraw(msg.sender, _pid, _amount);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function updatePool(uint256 _pid) public {                                                                                                                                                                  │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         if (block.number <= pool.lastRewardBlock) {                                                                                                                                                             │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 lpSupply = pool.lpToken.balanceOf(address(this));                                                                                                                                               │
│         if (lpSupply == 0) {                                                                                                                                                                                    │
│             pool.lastRewardBlock = block.number;                                                                                                                                                                │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);                                                                                                                                 │
│         uint256 cvxReward = multiplier                                                                                                                                                                          │
│             .mul(rewardPerBlock)                                                                                                                                                                                │
│             .mul(pool.allocPoint)                                                                                                                                                                               │
│             .div(totalAllocPoint);                                                                                                                                                                              │
│         //cvx.mint(address(this), cvxReward);                                                                                                                                                                   │
│         pool.accCvxPerShare = pool.accCvxPerShare.add(                                                                                                                                                          │
│             cvxReward.mul(1e12).div(lpSupply)                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         pool.lastRewardBlock = block.number;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _pid, uint256 _amount) public {                                                                                                                                                   │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid];                                                                                                                                                                 │
│         require(user.amount >= _amount, "withdraw: not good");                                                                                                                                                  │
│         updatePool(_pid);                                                                                                                                                                                       │
│         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(                                                                                                                                   │
│             user.rewardDebt                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         safeRewardTransfer(msg.sender, pending);                                                                                                                                                                │
│         user.amount = user.amount.sub(_amount);                                                                                                                                                                 │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│         pool.lpToken.safeTransfer(address(msg.sender), _amount);                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardPaid(msg.sender, _pid, pending);                                                                                                                                                             │
│         emit Withdraw(msg.sender, _pid, _amount);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function updatePool(uint256 _pid) public {                                                                                                                                                                  │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         if (block.number <= pool.lastRewardBlock) {                                                                                                                                                             │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 lpSupply = pool.lpToken.balanceOf(address(this));                                                                                                                                               │
│         if (lpSupply == 0) {                                                                                                                                                                                    │
│             pool.lastRewardBlock = block.number;                                                                                                                                                                │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);                                                                                                                                 │
│         uint256 cvxReward = multiplier                                                                                                                                                                          │
│             .mul(rewardPerBlock)                                                                                                                                                                                │
│             .mul(pool.allocPoint)                                                                                                                                                                               │
│             .div(totalAllocPoint);                                                                                                                                                                              │
│         //cvx.mint(address(this), cvxReward);                                                                                                                                                                   │
│         pool.accCvxPerShare = pool.accCvxPerShare.add(                                                                                                                                                          │
│             cvxReward.mul(1e12).div(lpSupply)                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         pool.lastRewardBlock = block.number;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function massUpdatePools() public {                                                                                                                                                                         │
│         uint256 length = poolInfo.length;                                                                                                                                                                       │
│         for (uint256 pid = 0; pid < length; ++pid) {                                                                                                                                                            │
│             updatePool(pid);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function updatePool(uint256 _pid) public {                                                                                                                                                                  │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         if (block.number <= pool.lastRewardBlock) {                                                                                                                                                             │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 lpSupply = pool.lpToken.balanceOf(address(this));                                                                                                                                               │
│         if (lpSupply == 0) {                                                                                                                                                                                    │
│             pool.lastRewardBlock = block.number;                                                                                                                                                                │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);                                                                                                                                 │
│         uint256 cvxReward = multiplier                                                                                                                                                                          │
│             .mul(rewardPerBlock)                                                                                                                                                                                │
│             .mul(pool.allocPoint)                                                                                                                                                                               │
│             .div(totalAllocPoint);                                                                                                                                                                              │
│         //cvx.mint(address(this), cvxReward);                                                                                                                                                                   │
│         pool.accCvxPerShare = pool.accCvxPerShare.add(                                                                                                                                                          │
│             cvxReward.mul(1e12).div(lpSupply)                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         pool.lastRewardBlock = block.number;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function safeRewardTransfer(address _to, uint256 _amount) internal {                                                                                                                                        │
│         uint256 cvxBal = cvx.balanceOf(address(this));                                                                                                                                                          │
│         if (_amount > cvxBal) {                                                                                                                                                                                 │
│             cvx.safeTransfer(_to, cvxBal);                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                │
│             cvx.safeTransfer(_to, _amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claim(uint256 _pid, address _account) external{                                                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid][_account];                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         updatePool(_pid);                                                                                                                                                                                       │
│         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(                                                                                                                                   │
│             user.rewardDebt                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         safeRewardTransfer(_account, pending);                                                                                                                                                                  │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, _account, _account, pending, user.amount);                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardPaid(_account, _pid, pending);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function safeRewardTransfer(address _to, uint256 _amount) internal {                                                                                                                                        │
│         uint256 cvxBal = cvx.balanceOf(address(this));                                                                                                                                                          │
│         if (_amount > cvxBal) {                                                                                                                                                                                 │
│             cvx.safeTransfer(_to, cvxBal);                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                │
│             cvx.safeTransfer(_to, _amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount) public {                                                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid];                                                                                                                                                                 │
│         updatePool(_pid);                                                                                                                                                                                       │
│         if (user.amount > 0) {                                                                                                                                                                                  │
│             uint256 pending = user                                                                                                                                                                              │
│                 .amount                                                                                                                                                                                         │
│                 .mul(pool.accCvxPerShare)                                                                                                                                                                       │
│                 .div(1e12)                                                                                                                                                                                      │
│                 .sub(user.rewardDebt);                                                                                                                                                                          │
│             safeRewardTransfer(msg.sender, pending);                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│         pool.lpToken.safeTransferFrom(                                                                                                                                                                          │
│             address(msg.sender),                                                                                                                                                                                │
│             address(this),                                                                                                                                                                                      │
│             _amount                                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│         user.amount = user.amount.add(_amount);                                                                                                                                                                 │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, _pid, _amount);                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function safeRewardTransfer(address _to, uint256 _amount) internal {                                                                                                                                        │
│         uint256 cvxBal = cvx.balanceOf(address(this));                                                                                                                                                          │
│         if (_amount > cvxBal) {                                                                                                                                                                                 │
│             cvx.safeTransfer(_to, cvxBal);                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                │
│             cvx.safeTransfer(_to, _amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount) public {                                                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid];                                                                                                                                                                 │
│         updatePool(_pid);                                                                                                                                                                                       │
│         if (user.amount > 0) {                                                                                                                                                                                  │
│             uint256 pending = user                                                                                                                                                                              │
│                 .amount                                                                                                                                                                                         │
│                 .mul(pool.accCvxPerShare)                                                                                                                                                                       │
│                 .div(1e12)                                                                                                                                                                                      │
│                 .sub(user.rewardDebt);                                                                                                                                                                          │
│             safeRewardTransfer(msg.sender, pending);                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│         pool.lpToken.safeTransferFrom(                                                                                                                                                                          │
│             address(msg.sender),                                                                                                                                                                                │
│             address(this),                                                                                                                                                                                      │
│             _amount                                                                                                                                                                                             │
│         );                                                                                                                                                                                                      │
│         user.amount = user.amount.add(_amount);                                                                                                                                                                 │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, _pid, _amount);                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function safeRewardTransfer(address _to, uint256 _amount) internal {                                                                                                                                        │
│         uint256 cvxBal = cvx.balanceOf(address(this));                                                                                                                                                          │
│         if (_amount > cvxBal) {                                                                                                                                                                                 │
│             cvx.safeTransfer(_to, cvxBal);                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                │
│             cvx.safeTransfer(_to, _amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 _pid, uint256 _amount) public {                                                                                                                                                   │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         UserInfo storage user = userInfo[_pid];                                                                                                                                                                 │
│         require(user.amount >= _amount, "withdraw: not good");                                                                                                                                                  │
│         updatePool(_pid);                                                                                                                                                                                       │
│         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(                                                                                                                                   │
│             user.rewardDebt                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         safeRewardTransfer(msg.sender, pending);                                                                                                                                                                │
│         user.amount = user.amount.sub(_amount);                                                                                                                                                                 │
│         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);                                                                                                                                       │
│         pool.lpToken.safeTransfer(address(msg.sender), _amount);                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //extra rewards                                                                                                                                                                                         │
│         IRewarder _rewarder = pool.rewarder;                                                                                                                                                                    │
│         if (address(_rewarder) != address(0)) {                                                                                                                                                                 │
│             _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardPaid(msg.sender, _pid, pending);                                                                                                                                                             │
│         emit Withdraw(msg.sender, _pid, _amount);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function safeRewardTransfer(address _to, uint256 _amount) internal {                                                                                                                                        │
│         uint256 cvxBal = cvx.balanceOf(address(this));                                                                                                                                                          │
│         if (_amount > cvxBal) {                                                                                                                                                                                 │
│             cvx.safeTransfer(_to, cvxBal);                                                                                                                                                                      │
│         } else {                                                                                                                                                                                                │
│             cvx.safeTransfer(_to, _amount);                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function shutdownPool(uint256 _pid) external onlyOperator returns(bool){                                                                                                                                    │
│         //get pool info                                                                                                                                                                                         │
│         (address lptoken, address depositToken,,,,bool isshutdown) = IPools(booster).poolInfo(_pid);                                                                                                            │
│         require(!isshutdown, "already shutdown");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //shutdown pool and get before and after amounts                                                                                                                                                        │
│         uint256 beforeBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                             │
│         IPools(pools).shutdownPool(_pid);                                                                                                                                                                       │
│         uint256 afterBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //check that proper amount of tokens were withdrawn(will also fail if already shutdown)                                                                                                                 │
│         require( afterBalance.sub(beforeBalance) >= IERC20(depositToken).totalSupply(), "supply mismatch");                                                                                                     │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function shutdownPool(uint256 _pid) external onlyOperator returns(bool){                                                                                                                                    │
│         //get pool info                                                                                                                                                                                         │
│         (address lptoken, address depositToken,,,,bool isshutdown) = IPools(booster).poolInfo(_pid);                                                                                                            │
│         require(!isshutdown, "already shutdown");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //shutdown pool and get before and after amounts                                                                                                                                                        │
│         uint256 beforeBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                             │
│         IPools(pools).shutdownPool(_pid);                                                                                                                                                                       │
│         uint256 afterBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //check that proper amount of tokens were withdrawn(will also fail if already shutdown)                                                                                                                 │
│         require( afterBalance.sub(beforeBalance) >= IERC20(depositToken).totalSupply(), "supply mismatch");                                                                                                     │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function shutdownPool(uint256 _pid) external onlyOperator returns(bool){                                                                                                                                    │
│         //get pool info                                                                                                                                                                                         │
│         (address lptoken, address depositToken,,,,bool isshutdown) = IPools(booster).poolInfo(_pid);                                                                                                            │
│         require(!isshutdown, "already shutdown");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //shutdown pool and get before and after amounts                                                                                                                                                        │
│         uint256 beforeBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                             │
│         IPools(pools).shutdownPool(_pid);                                                                                                                                                                       │
│         uint256 afterBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //check that proper amount of tokens were withdrawn(will also fail if already shutdown)                                                                                                                 │
│         require( afterBalance.sub(beforeBalance) >= IERC20(depositToken).totalSupply(), "supply mismatch");                                                                                                     │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function shutdownPool(uint256 _pid) external onlyOperator returns(bool){                                                                                                                                    │
│         //get pool info                                                                                                                                                                                         │
│         (address lptoken, address depositToken,,,,bool isshutdown) = IPools(booster).poolInfo(_pid);                                                                                                            │
│         require(!isshutdown, "already shutdown");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //shutdown pool and get before and after amounts                                                                                                                                                        │
│         uint256 beforeBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                             │
│         IPools(pools).shutdownPool(_pid);                                                                                                                                                                       │
│         uint256 afterBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //check that proper amount of tokens were withdrawn(will also fail if already shutdown)                                                                                                                 │
│         require( afterBalance.sub(beforeBalance) >= IERC20(depositToken).totalSupply(), "supply mismatch");                                                                                                     │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function shutdownPool(uint256 _pid) external returns(bool){                                                                                                                                                 │
│         require(msg.sender==operator, "!auth");                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         IPools(pools).shutdownPool(_pid);                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function shutdownPool(uint256 _pid) external onlyOperator returns(bool){                                                                                                                                    │
│         //get pool info                                                                                                                                                                                         │
│         (address lptoken, address depositToken,,,,bool isshutdown) = IPools(booster).poolInfo(_pid);                                                                                                            │
│         require(!isshutdown, "already shutdown");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //shutdown pool and get before and after amounts                                                                                                                                                        │
│         uint256 beforeBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                             │
│         IPools(pools).shutdownPool(_pid);                                                                                                                                                                       │
│         uint256 afterBalance = IERC20(lptoken).balanceOf(booster);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //check that proper amount of tokens were withdrawn(will also fail if already shutdown)                                                                                                                 │
│         require( afterBalance.sub(beforeBalance) >= IERC20(depositToken).totalSupply(), "supply mismatch");                                                                                                     │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function stakeAll() external returns(bool){                                                                                                                                                                 │
│         uint256 balance = stakingToken.balanceOf(msg.sender);                                                                                                                                                   │
│         stake(balance);                                                                                                                                                                                         │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function stake(uint256 _amount)                                                                                                                                                                             │
│         public                                                                                                                                                                                                  │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         _processStake(_amount, msg.sender);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function stake(uint256 _amount)                                                                                                                                                                             │
│         public                                                                                                                                                                                                  │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         _processStake(_amount, msg.sender);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount)                                                                                                                                                            │
│         public                                                                                                                                                                                                  │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         _processStake(_amount, _for);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount)                                                                                                                                                            │
│         public                                                                                                                                                                                                  │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         _processStake(_amount, _for);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //remove lp balance                                                                                                                                                                                     │
│         address token = pool.token;                                                                                                                                                                             │
│         ITokenMinter(token).burn(_from,_amount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //pull from gauge if not shutdown                                                                                                                                                                       │
│         // if shutdown tokens will be in this contract                                                                                                                                                          │
│         if (!pool.shutdown) {                                                                                                                                                                                   │
│             IStaker(staker).withdraw(lptoken,gauge, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim                                                                                                        │
│         //do not call if shutdown since stashes wont have access                                                                                                                                                │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0) && !isShutdown && !pool.shutdown){                                                                                                                                               │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //return lp tokens                                                                                                                                                                                      │
│         IERC20(lptoken).safeTransfer(_to, _amount);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_to, _pid, _amount);                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //remove lp balance                                                                                                                                                                                     │
│         address token = pool.token;                                                                                                                                                                             │
│         ITokenMinter(token).burn(_from,_amount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //pull from gauge if not shutdown                                                                                                                                                                       │
│         // if shutdown tokens will be in this contract                                                                                                                                                          │
│         if (!pool.shutdown) {                                                                                                                                                                                   │
│             IStaker(staker).withdraw(lptoken,gauge, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim                                                                                                        │
│         //do not call if shutdown since stashes wont have access                                                                                                                                                │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0) && !isShutdown && !pool.shutdown){                                                                                                                                               │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //return lp tokens                                                                                                                                                                                      │
│         IERC20(lptoken).safeTransfer(_to, _amount);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_to, _pid, _amount);                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(address _token, address _gauge) external returns(bool){                                                                                                                                │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));                                                                                                                    │
│         withdraw(_token, _gauge, amount);                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(uint256 _pid) public returns(bool){                                                                                                                                                    │
│         address token = poolInfo[_pid].token;                                                                                                                                                                   │
│         uint256 userBal = IERC20(token).balanceOf(msg.sender);                                                                                                                                                  │
│         withdraw(_pid, userBal);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function release() external returns(bool){                                                                                                                                                                  │
│         require(msg.sender == depositor, "!auth");                                                                                                                                                              │
│         ICurveVoteEscrow(escrow).withdraw();                                                                                                                                                                    │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAndUnwrap(uint256 amount, bool claim) public returns(bool){                                                                                                                                │
│         _withdrawAndUnwrapTo(amount, msg.sender, msg.sender);                                                                                                                                                   │
│         //get rewards too                                                                                                                                                                                       │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAndUnwrap(uint256 amount, bool claim) public returns(bool){                                                                                                                                │
│         _withdrawAndUnwrapTo(amount, msg.sender, msg.sender);                                                                                                                                                   │
│         //get rewards too                                                                                                                                                                                       │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 assets,                                                                                                                                                                                         │
│         address receiver,                                                                                                                                                                                       │
│         address owner                                                                                                                                                                                           │
│     ) public virtual override nonReentrant returns (uint256) {                                                                                                                                                  │
│         if (msg.sender != owner) {                                                                                                                                                                              │
│             _approve(owner, msg.sender, _allowances.sub(assets, "ERC4626: withdrawal amount exceeds allowance"));                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _withdrawAndUnwrapTo(assets, owner, receiver);                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         emit Withdraw(msg.sender, receiver, owner, assets, assets);                                                                                                                                             │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external returns(bool){                                                                                                                                          │
│         require(msg.sender == operator, "!authorized");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedRewards);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│             return true;                                                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));                                                                                                                                  │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rewardRate * elapsedTime;                                                                                                                                                        │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);                                                                                                                                         │
│         if(queuedRatio < newRewardRatio){                                                                                                                                                                       │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│         }else{                                                                                                                                                                                                  │
│             queuedRewards = _rewards;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external returns(bool){                                                                                                                                          │
│         require(msg.sender == operator, "!authorized");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedRewards);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│             return true;                                                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));                                                                                                                                  │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rewardRate * elapsedTime;                                                                                                                                                        │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);                                                                                                                                         │
│         if(queuedRatio < newRewardRatio){                                                                                                                                                                       │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│         }else{                                                                                                                                                                                                  │
│             queuedRewards = _rewards;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(uint256 reward)                                                                                                                                                                 │
│         internal                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         historicalRewards = historicalRewards.add(reward);                                                                                                                                                      │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = periodFinish.sub(block.timestamp);                                                                                                                                              │
│             uint256 leftover = remaining.mul(rewardRate);                                                                                                                                                       │
│             reward = reward.add(leftover);                                                                                                                                                                      │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         currentRewards = reward;                                                                                                                                                                                │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│         emit RewardAdded(reward);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(uint256 reward)                                                                                                                                                                 │
│         internal                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         historicalRewards = historicalRewards.add(reward);                                                                                                                                                      │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = periodFinish.sub(block.timestamp);                                                                                                                                              │
│             uint256 leftover = remaining.mul(rewardRate);                                                                                                                                                       │
│             reward = reward.add(leftover);                                                                                                                                                                      │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         currentRewards = reward;                                                                                                                                                                                │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│         emit RewardAdded(reward);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){                                                                                                                          │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //send to proxy to stake                                                                                                                                                                                │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //stake                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│         require(gauge != address(0),"!gauge setting");                                                                                                                                                          │
│         IStaker(staker).deposit(lptoken,gauge);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when depositing, stash them in a seperate contract until next claim                                                                                                         │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address token = pool.token;                                                                                                                                                                             │
│         if(_stake){                                                                                                                                                                                             │
│             //mint here and send to rewards on user behalf                                                                                                                                                      │
│             ITokenMinter(token).mint(address(this),_amount);                                                                                                                                                    │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(token).safeApprove(rewardContract,0);                                                                                                                                                        │
│             IERC20(token).safeApprove(rewardContract,_amount);                                                                                                                                                  │
│             IRewards(rewardContract).stakeFor(msg.sender,_amount);                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //add user balance directly                                                                                                                                                                         │
│             ITokenMinter(token).mint(msg.sender,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Deposited(msg.sender, _pid, _amount);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositAll(uint256 _pid, bool _stake) external returns(bool){                                                                                                                                      │
│         address lptoken = poolInfo[_pid].lptoken;                                                                                                                                                               │
│         uint256 balance = IERC20(lptoken).balanceOf(msg.sender);                                                                                                                                                │
│         deposit(_pid,balance,_stake);                                                                                                                                                                           │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //remove lp balance                                                                                                                                                                                     │
│         address token = pool.token;                                                                                                                                                                             │
│         ITokenMinter(token).burn(_from,_amount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //pull from gauge if not shutdown                                                                                                                                                                       │
│         // if shutdown tokens will be in this contract                                                                                                                                                          │
│         if (!pool.shutdown) {                                                                                                                                                                                   │
│             IStaker(staker).withdraw(lptoken,gauge, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim                                                                                                        │
│         //do not call if shutdown since stashes wont have access                                                                                                                                                │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0) && !isShutdown && !pool.shutdown){                                                                                                                                               │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //return lp tokens                                                                                                                                                                                      │
│         IERC20(lptoken).safeTransfer(_to, _amount);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_to, _pid, _amount);                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(uint256 _pid) public returns(bool){                                                                                                                                                    │
│         address token = poolInfo[_pid].token;                                                                                                                                                                   │
│         uint256 userBal = IERC20(token).balanceOf(msg.sender);                                                                                                                                                  │
│         withdraw(_pid, userBal);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function shutdownSystem() external{                                                                                                                                                                         │
│         require(msg.sender == owner, "!auth");                                                                                                                                                                  │
│         isShutdown = true;                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         for(uint i=0; i < poolInfo.length; i++){                                                                                                                                                                │
│             PoolInfo storage pool = poolInfo;                                                                                                                                                                   │
│             if (pool.shutdown) continue;                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             address token = pool.lptoken;                                                                                                                                                                       │
│             address gauge = pool.gauge;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //withdraw from gauge                                                                                                                                                                               │
│             try IStaker(staker).withdrawAll(token,gauge){                                                                                                                                                       │
│                 pool.shutdown = true;                                                                                                                                                                           │
│             }catch{}                                                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function withdrawAll(uint256 _pid) public returns(bool){                                                                                                                                                    │
│         address token = poolInfo[_pid].token;                                                                                                                                                                   │
│         uint256 userBal = IERC20(token).balanceOf(msg.sender);                                                                                                                                                  │
│         withdraw(_pid, userBal);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function shutdownPool(uint256 _pid) external returns(bool){                                                                                                                                                 │
│         require(msg.sender==poolManager, "!auth");                                                                                                                                                              │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //withdraw from gauge                                                                                                                                                                                   │
│         try IStaker(staker).withdrawAll(pool.lptoken,pool.gauge){                                                                                                                                               │
│         }catch{}                                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         pool.shutdown = true;                                                                                                                                                                                   │
│         gaugeMap = false;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit PoolShutdown(_pid);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdrawAll(uint256 _pid) public returns(bool){                                                                                                                                                    │
│         address token = poolInfo[_pid].token;                                                                                                                                                                   │
│         uint256 userBal = IERC20(token).balanceOf(msg.sender);                                                                                                                                                  │
│         withdraw(_pid, userBal);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: calculate vote amount/number                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                           │
│     function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool){                                                                                                    │
│         require(msg.sender == voteDelegate, "!auth");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         for(uint256 i = 0; i < _gauge.length; i++){                                                                                                                                                             │
│             IStaker(staker).voteGaugeWeight(_gauge,_weight);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: calculate vote amount/number                                                                                                                                                                         │
│ Code:                                                                                                                                                                                                           │
│     function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool){                                                                                                    │
│         require(msg.sender == voteDelegate, "!auth");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         for(uint256 i = 0; i < _gauge.length; i++){                                                                                                                                                             │
│             IStaker(staker).voteGaugeWeight(_gauge,_weight);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool){                                                                                                    │
│         require(msg.sender == voteDelegate, "!auth");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         for(uint256 i = 0; i < _gauge.length; i++){                                                                                                                                                             │
│             IStaker(staker).voteGaugeWeight(_gauge,_weight);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _earmarkRewards(uint256 _pid) internal {                                                                                                                                                           │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //claim crv                                                                                                                                                                                             │
│         IStaker(staker).claimCrv(gauge);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //check if there are extra rewards                                                                                                                                                                      │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             //claim extra rewards                                                                                                                                                                               │
│             IStash(stash).claimRewards();                                                                                                                                                                       │
│             //process extra rewards                                                                                                                                                                             │
│             IStash(stash).processStash();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //crv balance                                                                                                                                                                                           │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             // LockIncentive = cvxCrv stakers (currently 10%)                                                                                                                                                   │
│             uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             // StakerIncentive = cvx stakers (currently 5%)                                                                                                                                                     │
│             uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);                                                                                                                        │
│             // CallIncentive = caller of this contract (currently 1%)                                                                                                                                           │
│             uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);                                                                                                                         │
│                                                                                                                                                                                                                 │
│             // Treasury = vlCVX (currently 1%)                                                                                                                                                                  │
│             if(treasury != address(0) && treasury != address(this) && platformFee > 0){                                                                                                                         │
│                 //only subtract after address condition check                                                                                                                                                   │
│                 uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);                                                                                                                               │
│                 crvBal = crvBal.sub(_platform);                                                                                                                                                                 │
│                 IERC20(crv).safeTransfer(treasury, _platform);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //remove incentives from balance                                                                                                                                                                    │
│             crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);                                                                                                                      │
│                                                                                                                                                                                                                 │
│             //send incentives for calling                                                                                                                                                                       │
│             IERC20(crv).safeTransfer(msg.sender, _callIncentive);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send crv to lp provider reward contract                                                                                                                                                           │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(crv).safeTransfer(rewardContract, crvBal);                                                                                                                                                   │
│             IRewards(rewardContract).queueNewRewards(crvBal);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //send lockers' share of crv to reward contract                                                                                                                                                     │
│             IERC20(crv).safeTransfer(lockRewards, _lockIncentive);                                                                                                                                              │
│             IRewards(lockRewards).queueNewRewards(_lockIncentive);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             //send stakers's share of crv to reward contract                                                                                                                                                    │
│             IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _earmarkRewards(uint256 _pid) internal {                                                                                                                                                           │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //claim crv                                                                                                                                                                                             │
│         IStaker(staker).claimCrv(gauge);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //check if there are extra rewards                                                                                                                                                                      │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             //claim extra rewards                                                                                                                                                                               │
│             IStash(stash).claimRewards();                                                                                                                                                                       │
│             //process extra rewards                                                                                                                                                                             │
│             IStash(stash).processStash();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //crv balance                                                                                                                                                                                           │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             // LockIncentive = cvxCrv stakers (currently 10%)                                                                                                                                                   │
│             uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             // StakerIncentive = cvx stakers (currently 5%)                                                                                                                                                     │
│             uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);                                                                                                                        │
│             // CallIncentive = caller of this contract (currently 1%)                                                                                                                                           │
│             uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);                                                                                                                         │
│                                                                                                                                                                                                                 │
│             // Treasury = vlCVX (currently 1%)                                                                                                                                                                  │
│             if(treasury != address(0) && treasury != address(this) && platformFee > 0){                                                                                                                         │
│                 //only subtract after address condition check                                                                                                                                                   │
│                 uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);                                                                                                                               │
│                 crvBal = crvBal.sub(_platform);                                                                                                                                                                 │
│                 IERC20(crv).safeTransfer(treasury, _platform);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //remove incentives from balance                                                                                                                                                                    │
│             crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);                                                                                                                      │
│                                                                                                                                                                                                                 │
│             //send incentives for calling                                                                                                                                                                       │
│             IERC20(crv).safeTransfer(msg.sender, _callIncentive);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send crv to lp provider reward contract                                                                                                                                                           │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(crv).safeTransfer(rewardContract, crvBal);                                                                                                                                                   │
│             IRewards(rewardContract).queueNewRewards(crvBal);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //send lockers' share of crv to reward contract                                                                                                                                                     │
│             IERC20(crv).safeTransfer(lockRewards, _lockIncentive);                                                                                                                                              │
│             IRewards(lockRewards).queueNewRewards(_lockIncentive);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             //send stakers's share of crv to reward contract                                                                                                                                                    │
│             IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function earmarkRewards(uint256 _pid) external returns(bool){                                                                                                                                               │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         _earmarkRewards(_pid);                                                                                                                                                                                  │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function _earmarkRewards(uint256 _pid) internal {                                                                                                                                                           │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //claim crv                                                                                                                                                                                             │
│         IStaker(staker).claimCrv(gauge);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //check if there are extra rewards                                                                                                                                                                      │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             //claim extra rewards                                                                                                                                                                               │
│             IStash(stash).claimRewards();                                                                                                                                                                       │
│             //process extra rewards                                                                                                                                                                             │
│             IStash(stash).processStash();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //crv balance                                                                                                                                                                                           │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             // LockIncentive = cvxCrv stakers (currently 10%)                                                                                                                                                   │
│             uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             // StakerIncentive = cvx stakers (currently 5%)                                                                                                                                                     │
│             uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);                                                                                                                        │
│             // CallIncentive = caller of this contract (currently 1%)                                                                                                                                           │
│             uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);                                                                                                                         │
│                                                                                                                                                                                                                 │
│             // Treasury = vlCVX (currently 1%)                                                                                                                                                                  │
│             if(treasury != address(0) && treasury != address(this) && platformFee > 0){                                                                                                                         │
│                 //only subtract after address condition check                                                                                                                                                   │
│                 uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);                                                                                                                               │
│                 crvBal = crvBal.sub(_platform);                                                                                                                                                                 │
│                 IERC20(crv).safeTransfer(treasury, _platform);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //remove incentives from balance                                                                                                                                                                    │
│             crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);                                                                                                                      │
│                                                                                                                                                                                                                 │
│             //send incentives for calling                                                                                                                                                                       │
│             IERC20(crv).safeTransfer(msg.sender, _callIncentive);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send crv to lp provider reward contract                                                                                                                                                           │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(crv).safeTransfer(rewardContract, crvBal);                                                                                                                                                   │
│             IRewards(rewardContract).queueNewRewards(crvBal);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //send lockers' share of crv to reward contract                                                                                                                                                     │
│             IERC20(crv).safeTransfer(lockRewards, _lockIncentive);                                                                                                                                              │
│             IRewards(lockRewards).queueNewRewards(_lockIncentive);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             //send stakers's share of crv to reward contract                                                                                                                                                    │
│             IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function earmarkFees(address _feeToken) external returns(bool){                                                                                                                                             │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         FeeDistro memory feeDistro = feeTokens[_feeToken];                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         require(feeDistro.active, "Inactive distro");                                                                                                                                                           │
│         require(!gaugeMap[_feeToken], "Invalid token");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //claim fee rewards                                                                                                                                                                                     │
│         uint256 tokenBalanceBefore = IERC20(_feeToken).balanceOf(address(this));                                                                                                                                │
│         IStaker(staker).claimFees(feeDistro.distro, _feeToken);                                                                                                                                                 │
│         uint256 tokenBalanceAfter = IERC20(_feeToken).balanceOf(address(this));                                                                                                                                 │
│         uint256 feesClaimed = tokenBalanceAfter.sub(tokenBalanceBefore);                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send fee rewards to reward contract                                                                                                                                                                   │
│         IERC20(_feeToken).safeTransfer(feeDistro.rewards, feesClaimed);                                                                                                                                         │
│         IRewards(feeDistro.rewards).queueNewRewards(feesClaimed);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function onRewardClaim() external{                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //get balance                                                                                                                                                                                           │
│         uint256 bal = IERC20(rewardToken).balanceOf(address(this));                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //send                                                                                                                                                                                                  │
│         IERC20(rewardToken).safeTransfer(stash,bal);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimRewards() external returns (bool) {                                                                                                                                                           │
│         require(msg.sender == operator, "!operator");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //this is updateable from v2 gauges now so must check each time.                                                                                                                                        │
│         checkForNewRewardTokens();                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //make sure we're redirected                                                                                                                                                                            │
│         if(!hasRedirected){                                                                                                                                                                                     │
│             IDeposit(operator).setGaugeRedirect(pid);                                                                                                                                                           │
│             hasRedirected = true;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if(hasCurveRewards){                                                                                                                                                                                    │
│             //claim rewards on gauge for staker                                                                                                                                                                 │
│             //using reward_receiver so all rewards will be moved to this stash                                                                                                                                  │
│             IDeposit(operator).claimRewards(pid,gauge);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //hook for reward pulls                                                                                                                                                                                 │
│         if(rewardHook != address(0)){                                                                                                                                                                           │
│             try IRewardHook(rewardHook).onRewardClaim(){                                                                                                                                                        │
│             }catch{}                                                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function onRewardClaim() external{                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //get balance                                                                                                                                                                                           │
│         uint256 bal = IERC20(rewardToken).balanceOf(address(this));                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //send                                                                                                                                                                                                  │
│         IERC20(rewardToken).safeTransfer(stash,bal);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distribute() external {                                                                                                                                                                            │
│         // If keeper enabled, require                                                                                                                                                                           │
│         if (keeper != address(0)) {                                                                                                                                                                             │
│             require(msg.sender == keeper, "!auth");                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //convert crv to cvxCrv                                                                                                                                                                                 │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             uint256 minOut = ICrvDepositorWrapper(crvDepositorWrapper).getMinOut(crvBal, outputBps);                                                                                                            │
│             ICrvDepositorWrapper(crvDepositorWrapper).deposit(crvBal, minOut, true, address(0));                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //distribute cvxcrv                                                                                                                                                                                     │
│         uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBal > 0) {                                                                                                                                                                                    │
│             uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);                                                                                                                            │
│             cvxCrvBal = cvxCrvBal.sub(incentiveAmount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             IERC20(cvxCrv).safeTransfer(msg.sender, incentiveAmount);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             IAuraLocker(rewards).queueNewRewards(cvxCrvBal);                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(cvxCrv, cvxCrvBal);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){                                                                                                                          │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //send to proxy to stake                                                                                                                                                                                │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //stake                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│         require(gauge != address(0),"!gauge setting");                                                                                                                                                          │
│         IStaker(staker).deposit(lptoken,gauge);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when depositing, stash them in a seperate contract until next claim                                                                                                         │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address token = pool.token;                                                                                                                                                                             │
│         if(_stake){                                                                                                                                                                                             │
│             //mint here and send to rewards on user behalf                                                                                                                                                      │
│             ITokenMinter(token).mint(address(this),_amount);                                                                                                                                                    │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(token).safeApprove(rewardContract,0);                                                                                                                                                        │
│             IERC20(token).safeApprove(rewardContract,_amount);                                                                                                                                                  │
│             IRewards(rewardContract).stakeFor(msg.sender,_amount);                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //add user balance directly                                                                                                                                                                         │
│             ITokenMinter(token).mint(msg.sender,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Deposited(msg.sender, _pid, _amount);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositAll(uint256 _pid, bool _stake) external returns(bool){                                                                                                                                      │
│         address lptoken = poolInfo[_pid].lptoken;                                                                                                                                                               │
│         uint256 balance = IERC20(lptoken).balanceOf(msg.sender);                                                                                                                                                │
│         deposit(_pid,balance,_stake);                                                                                                                                                                           │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _claimExtras( // solhint-disable-line                                                                                                                                                              │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 removeCrvBalance,                                                                                                                                                                               │
│         uint256 removeCvxBalance,                                                                                                                                                                               │
│         uint256 options                                                                                                                                                                                         │
│     ) internal {                                                                                                                                                                                                │
│         //claim from cvxCrv rewards                                                                                                                                                                             │
│         if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {                                                                                                                                              │
│             IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //claim from locker                                                                                                                                                                                     │
│         if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {                                                                                                                                           │
│             IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //reset remove balances if we want to also stake/lock funds already in our wallet                                                                                                                       │
│         if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {                                                                                                                                        │
│             removeCrvBalance = 0;                                                                                                                                                                               │
│             removeCvxBalance = 0;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //lock upto given amount of crv and stake                                                                                                                                                               │
│         if (depositCrvMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);                                                                                                                       │
│             crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             if (crvBalance > 0) {                                                                                                                                                                               │
│                 //pull crv                                                                                                                                                                                      │
│                 IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);                                                                                                                            │
│                 //deposit                                                                                                                                                                                       │
│                 ICrvDepositorWrapper(crvDepositWrapper).deposit(                                                                                                                                                │
│                     crvBalance,                                                                                                                                                                                 │
│                     minAmountOut,                                                                                                                                                                               │
│                     _checkOption(options, uint256(Options.LockCrvDeposit)),                                                                                                                                     │
│                     address(0)                                                                                                                                                                                  │
│                 );                                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                │
│                 //stake for msg.sender                                                                                                                                                                          │
│                 IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //stake up to given amount of cvx                                                                                                                                                                       │
│         if (depositCvxMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);                                                                                                                       │
│             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);                                                                                                                                         │
│             if (cvxBalance > 0) {                                                                                                                                                                               │
│                 //pull cvx                                                                                                                                                                                      │
│                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                                                                                                                            │
│                 if (_checkOption(options, uint256(Options.LockCvx))) {                                                                                                                                          │
│                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                                                                                                                                           │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function initialLock() external{                                                                                                                                                                            │
│         require(!cooldown, "cooldown");                                                                                                                                                                         │
│         require(msg.sender==feeManager, "!auth");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 vecrv = IERC20(escrow).balanceOf(staker);                                                                                                                                                       │
│         if(vecrv == 0){                                                                                                                                                                                         │
│             uint256 unlockAt = block.timestamp + MAXTIME;                                                                                                                                                       │
│             uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             //release old lock if exists                                                                                                                                                                        │
│             IStaker(staker).release();                                                                                                                                                                          │
│             //create new lock                                                                                                                                                                                   │
│             uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);                                                                                                                                        │
│             IStaker(staker).createLock(crvBalanceStaker, unlockAt);                                                                                                                                             │
│             unlockTime = unlockInWeeks;                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _lockCurve() internal {                                                                                                                                                                            │
│         if(cooldown) {                                                                                                                                                                                          │
│           return;                                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));                                                                                                                                           │
│         if(crvBalance > 0){                                                                                                                                                                                     │
│             IERC20(crvBpt).safeTransfer(staker, crvBalance);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //increase ammount                                                                                                                                                                                      │
│         uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);                                                                                                                                            │
│         if(crvBalanceStaker == 0){                                                                                                                                                                              │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //increase amount                                                                                                                                                                                       │
│         IStaker(staker).increaseAmount(crvBalanceStaker);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256 unlockAt = block.timestamp + MAXTIME;                                                                                                                                                           │
│         uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //increase time too if over 2 week buffer                                                                                                                                                               │
│         if(unlockInWeeks.sub(unlockTime) > 2){                                                                                                                                                                  │
│             IStaker(staker).increaseTime(unlockAt);                                                                                                                                                             │
│             unlockTime = unlockInWeeks;                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {                                                                                                                │
│         require(_amount > 0,"!>0");                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         if(_lock){                                                                                                                                                                                              │
│             //lock immediately, transfer directly to staker to skip an erc20 transfer                                                                                                                           │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                       │
│             _lockCurve();                                                                                                                                                                                       │
│             if(incentiveCrv > 0){                                                                                                                                                                               │
│                 //add the incentive tokens here so they can be staked together                                                                                                                                  │
│                 _amount = _amount.add(incentiveCrv);                                                                                                                                                            │
│                 incentiveCrv = 0;                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }else{                                                                                                                                                                                                  │
│             //move tokens here                                                                                                                                                                                  │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                │
│             //defer lock cost to another user                                                                                                                                                                   │
│             uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             _amount = _amount.sub(callIncentive);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //add to a pool for lock caller                                                                                                                                                                     │
│             incentiveCrv = incentiveCrv.add(callIncentive);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bool depositOnly = _stakeAddress == address(0);                                                                                                                                                         │
│         if(depositOnly){                                                                                                                                                                                        │
│             //mint for to                                                                                                                                                                                       │
│             ITokenMinter(minter).mint(to,_amount);                                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //mint here                                                                                                                                                                                         │
│             ITokenMinter(minter).mint(address(this),_amount);                                                                                                                                                   │
│             //stake for to                                                                                                                                                                                      │
│             IERC20(minter).safeApprove(_stakeAddress,0);                                                                                                                                                        │
│             IERC20(minter).safeApprove(_stakeAddress,_amount);                                                                                                                                                  │
│             IRewards(_stakeAddress).stakeFor(to,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _lockCurve() internal {                                                                                                                                                                            │
│         if(cooldown) {                                                                                                                                                                                          │
│           return;                                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));                                                                                                                                           │
│         if(crvBalance > 0){                                                                                                                                                                                     │
│             IERC20(crvBpt).safeTransfer(staker, crvBalance);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //increase ammount                                                                                                                                                                                      │
│         uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);                                                                                                                                            │
│         if(crvBalanceStaker == 0){                                                                                                                                                                              │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //increase amount                                                                                                                                                                                       │
│         IStaker(staker).increaseAmount(crvBalanceStaker);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256 unlockAt = block.timestamp + MAXTIME;                                                                                                                                                           │
│         uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //increase time too if over 2 week buffer                                                                                                                                                               │
│         if(unlockInWeeks.sub(unlockTime) > 2){                                                                                                                                                                  │
│             IStaker(staker).increaseTime(unlockAt);                                                                                                                                                             │
│             unlockTime = unlockInWeeks;                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function lockCurve() external {                                                                                                                                                                             │
│         require(!cooldown, "cooldown");                                                                                                                                                                         │
│         _lockCurve();                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //mint incentives                                                                                                                                                                                       │
│         if(incentiveCrv > 0){                                                                                                                                                                                   │
│             ITokenMinter(minter).mint(msg.sender,incentiveCrv);                                                                                                                                                 │
│             incentiveCrv = 0;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _lockCurve() internal {                                                                                                                                                                            │
│         if(cooldown) {                                                                                                                                                                                          │
│           return;                                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));                                                                                                                                           │
│         if(crvBalance > 0){                                                                                                                                                                                     │
│             IERC20(crvBpt).safeTransfer(staker, crvBalance);                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //increase ammount                                                                                                                                                                                      │
│         uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);                                                                                                                                            │
│         if(crvBalanceStaker == 0){                                                                                                                                                                              │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //increase amount                                                                                                                                                                                       │
│         IStaker(staker).increaseAmount(crvBalanceStaker);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256 unlockAt = block.timestamp + MAXTIME;                                                                                                                                                           │
│         uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //increase time too if over 2 week buffer                                                                                                                                                               │
│         if(unlockInWeeks.sub(unlockTime) > 2){                                                                                                                                                                  │
│             IStaker(staker).increaseTime(unlockAt);                                                                                                                                                             │
│             unlockTime = unlockInWeeks;                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {                                                                                                                            │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances = _balances.add(_amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {                                                                                                                            │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances = _balances.add(_amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function stakeAll() external returns(bool){                                                                                                                                                                 │
│         uint256 balance = stakingToken.balanceOf(msg.sender);                                                                                                                                                   │
│         stake(balance);                                                                                                                                                                                         │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {                                                                                                                            │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances = _balances.add(_amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function stakeAll() external returns(bool){                                                                                                                                                                 │
│         uint256 balance = stakingToken.balanceOf(msg.sender);                                                                                                                                                   │
│         stake(balance);                                                                                                                                                                                         │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {                                                                                                                            │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances = _balances.add(_amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function stakeAll() external returns (bool) {                                                                                                                                                               │
│         uint256 balance = stakingToken.balanceOf(msg.sender);                                                                                                                                                   │
│         stake(balance);                                                                                                                                                                                         │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {                                                                                                                            │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances = _balances.add(_amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function stakeAll() external returns (bool) {                                                                                                                                                               │
│         uint256 balance = stakingToken.balanceOf(msg.sender);                                                                                                                                                   │
│         stake(balance);                                                                                                                                                                                         │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {                                                                                                                            │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances = _balances.add(_amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {                                                                                                                            │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances = _balances.add(_amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {                                                                                                               │
│         require(_amount > 0, 'RewardPool : Cannot stake 0');                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //also stake to linked rewards                                                                                                                                                                          │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).stake(_receiver, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_receiver] = _balances[_receiver].add(_amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {                                                                                                                            │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances = _balances.add(_amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function stakeAll() external returns (bool) {                                                                                                                                                               │
│         uint256 balance = stakingToken.balanceOf(msg.sender);                                                                                                                                                   │
│         stake(balance);                                                                                                                                                                                         │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {                                                                                                                │
│         require(_amount > 0,"!>0");                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         if(_lock){                                                                                                                                                                                              │
│             //lock immediately, transfer directly to staker to skip an erc20 transfer                                                                                                                           │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                       │
│             _lockCurve();                                                                                                                                                                                       │
│             if(incentiveCrv > 0){                                                                                                                                                                               │
│                 //add the incentive tokens here so they can be staked together                                                                                                                                  │
│                 _amount = _amount.add(incentiveCrv);                                                                                                                                                            │
│                 incentiveCrv = 0;                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }else{                                                                                                                                                                                                  │
│             //move tokens here                                                                                                                                                                                  │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                │
│             //defer lock cost to another user                                                                                                                                                                   │
│             uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             _amount = _amount.sub(callIncentive);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //add to a pool for lock caller                                                                                                                                                                     │
│             incentiveCrv = incentiveCrv.add(callIncentive);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bool depositOnly = _stakeAddress == address(0);                                                                                                                                                         │
│         if(depositOnly){                                                                                                                                                                                        │
│             //mint for to                                                                                                                                                                                       │
│             ITokenMinter(minter).mint(to,_amount);                                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //mint here                                                                                                                                                                                         │
│             ITokenMinter(minter).mint(address(this),_amount);                                                                                                                                                   │
│             //stake for to                                                                                                                                                                                      │
│             IERC20(minter).safeApprove(_stakeAddress,0);                                                                                                                                                        │
│             IERC20(minter).safeApprove(_stakeAddress,_amount);                                                                                                                                                  │
│             IRewards(_stakeAddress).stakeFor(to,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {                                                                                                                │
│         require(_amount > 0,"!>0");                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         if(_lock){                                                                                                                                                                                              │
│             //lock immediately, transfer directly to staker to skip an erc20 transfer                                                                                                                           │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                       │
│             _lockCurve();                                                                                                                                                                                       │
│             if(incentiveCrv > 0){                                                                                                                                                                               │
│                 //add the incentive tokens here so they can be staked together                                                                                                                                  │
│                 _amount = _amount.add(incentiveCrv);                                                                                                                                                            │
│                 incentiveCrv = 0;                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }else{                                                                                                                                                                                                  │
│             //move tokens here                                                                                                                                                                                  │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                │
│             //defer lock cost to another user                                                                                                                                                                   │
│             uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             _amount = _amount.sub(callIncentive);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //add to a pool for lock caller                                                                                                                                                                     │
│             incentiveCrv = incentiveCrv.add(callIncentive);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bool depositOnly = _stakeAddress == address(0);                                                                                                                                                         │
│         if(depositOnly){                                                                                                                                                                                        │
│             //mint for to                                                                                                                                                                                       │
│             ITokenMinter(minter).mint(to,_amount);                                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //mint here                                                                                                                                                                                         │
│             ITokenMinter(minter).mint(address(this),_amount);                                                                                                                                                   │
│             //stake for to                                                                                                                                                                                      │
│             IERC20(minter).safeApprove(_stakeAddress,0);                                                                                                                                                        │
│             IERC20(minter).safeApprove(_stakeAddress,_amount);                                                                                                                                                  │
│             IRewards(_stakeAddress).stakeFor(to,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _claimExtras( // solhint-disable-line                                                                                                                                                              │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 removeCrvBalance,                                                                                                                                                                               │
│         uint256 removeCvxBalance,                                                                                                                                                                               │
│         uint256 options                                                                                                                                                                                         │
│     ) internal {                                                                                                                                                                                                │
│         //claim from cvxCrv rewards                                                                                                                                                                             │
│         if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {                                                                                                                                              │
│             IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //claim from locker                                                                                                                                                                                     │
│         if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {                                                                                                                                           │
│             IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //reset remove balances if we want to also stake/lock funds already in our wallet                                                                                                                       │
│         if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {                                                                                                                                        │
│             removeCrvBalance = 0;                                                                                                                                                                               │
│             removeCvxBalance = 0;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //lock upto given amount of crv and stake                                                                                                                                                               │
│         if (depositCrvMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);                                                                                                                       │
│             crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             if (crvBalance > 0) {                                                                                                                                                                               │
│                 //pull crv                                                                                                                                                                                      │
│                 IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);                                                                                                                            │
│                 //deposit                                                                                                                                                                                       │
│                 ICrvDepositorWrapper(crvDepositWrapper).deposit(                                                                                                                                                │
│                     crvBalance,                                                                                                                                                                                 │
│                     minAmountOut,                                                                                                                                                                               │
│                     _checkOption(options, uint256(Options.LockCrvDeposit)),                                                                                                                                     │
│                     address(0)                                                                                                                                                                                  │
│                 );                                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                │
│                 //stake for msg.sender                                                                                                                                                                          │
│                 IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //stake up to given amount of cvx                                                                                                                                                                       │
│         if (depositCvxMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);                                                                                                                       │
│             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);                                                                                                                                         │
│             if (cvxBalance > 0) {                                                                                                                                                                               │
│                 //pull cvx                                                                                                                                                                                      │
│                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                                                                                                                            │
│                 if (_checkOption(options, uint256(Options.LockCvx))) {                                                                                                                                          │
│                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                                                                                                                                           │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _claimExtras( // solhint-disable-line                                                                                                                                                              │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 removeCrvBalance,                                                                                                                                                                               │
│         uint256 removeCvxBalance,                                                                                                                                                                               │
│         uint256 options                                                                                                                                                                                         │
│     ) internal {                                                                                                                                                                                                │
│         //claim from cvxCrv rewards                                                                                                                                                                             │
│         if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {                                                                                                                                              │
│             IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //claim from locker                                                                                                                                                                                     │
│         if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {                                                                                                                                           │
│             IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //reset remove balances if we want to also stake/lock funds already in our wallet                                                                                                                       │
│         if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {                                                                                                                                        │
│             removeCrvBalance = 0;                                                                                                                                                                               │
│             removeCvxBalance = 0;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //lock upto given amount of crv and stake                                                                                                                                                               │
│         if (depositCrvMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);                                                                                                                       │
│             crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             if (crvBalance > 0) {                                                                                                                                                                               │
│                 //pull crv                                                                                                                                                                                      │
│                 IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);                                                                                                                            │
│                 //deposit                                                                                                                                                                                       │
│                 ICrvDepositorWrapper(crvDepositWrapper).deposit(                                                                                                                                                │
│                     crvBalance,                                                                                                                                                                                 │
│                     minAmountOut,                                                                                                                                                                               │
│                     _checkOption(options, uint256(Options.LockCrvDeposit)),                                                                                                                                     │
│                     address(0)                                                                                                                                                                                  │
│                 );                                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                │
│                 //stake for msg.sender                                                                                                                                                                          │
│                 IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //stake up to given amount of cvx                                                                                                                                                                       │
│         if (depositCvxMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);                                                                                                                       │
│             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);                                                                                                                                         │
│             if (cvxBalance > 0) {                                                                                                                                                                               │
│                 //pull cvx                                                                                                                                                                                      │
│                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                                                                                                                            │
│                 if (_checkOption(options, uint256(Options.LockCvx))) {                                                                                                                                          │
│                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                                                                                                                                           │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){                                                                                                                          │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //send to proxy to stake                                                                                                                                                                                │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //stake                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│         require(gauge != address(0),"!gauge setting");                                                                                                                                                          │
│         IStaker(staker).deposit(lptoken,gauge);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when depositing, stash them in a seperate contract until next claim                                                                                                         │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address token = pool.token;                                                                                                                                                                             │
│         if(_stake){                                                                                                                                                                                             │
│             //mint here and send to rewards on user behalf                                                                                                                                                      │
│             ITokenMinter(token).mint(address(this),_amount);                                                                                                                                                    │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(token).safeApprove(rewardContract,0);                                                                                                                                                        │
│             IERC20(token).safeApprove(rewardContract,_amount);                                                                                                                                                  │
│             IRewards(rewardContract).stakeFor(msg.sender,_amount);                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //add user balance directly                                                                                                                                                                         │
│             ITokenMinter(token).mint(msg.sender,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Deposited(msg.sender, _pid, _amount);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){                                                                                                                          │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //send to proxy to stake                                                                                                                                                                                │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //stake                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│         require(gauge != address(0),"!gauge setting");                                                                                                                                                          │
│         IStaker(staker).deposit(lptoken,gauge);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when depositing, stash them in a seperate contract until next claim                                                                                                         │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address token = pool.token;                                                                                                                                                                             │
│         if(_stake){                                                                                                                                                                                             │
│             //mint here and send to rewards on user behalf                                                                                                                                                      │
│             ITokenMinter(token).mint(address(this),_amount);                                                                                                                                                    │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(token).safeApprove(rewardContract,0);                                                                                                                                                        │
│             IERC20(token).safeApprove(rewardContract,_amount);                                                                                                                                                  │
│             IRewards(rewardContract).stakeFor(msg.sender,_amount);                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //add user balance directly                                                                                                                                                                         │
│             ITokenMinter(token).mint(msg.sender,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Deposited(msg.sender, _pid, _amount);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {                                                                                                              │
│         uint256 rewardTokensLength = rewardTokens.length;                                                                                                                                                       │
│         for (uint256 i; i < rewardTokensLength; i++) {                                                                                                                                                          │
│             address _rewardsToken = rewardTokens;                                                                                                                                                               │
│             uint256 reward = userData[_account][_rewardsToken].rewards;                                                                                                                                         │
│             if (reward > 0) {                                                                                                                                                                                   │
│                 userData[_account][_rewardsToken].rewards = 0;                                                                                                                                                  │
│                 if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {                                                                                                                              │
│                     IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);                                                                                                                                   │
│                 } else {                                                                                                                                                                                        │
│                     IERC20(_rewardsToken).safeTransfer(_account, reward);                                                                                                                                       │
│                 }                                                                                                                                                                                               │
│                 emit RewardPaid(_account, _rewardsToken, reward);                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {                                                                                                              │
│         uint256 rewardTokensLength = rewardTokens.length;                                                                                                                                                       │
│         for (uint256 i; i < rewardTokensLength; i++) {                                                                                                                                                          │
│             address _rewardsToken = rewardTokens;                                                                                                                                                               │
│             uint256 reward = userData[_account][_rewardsToken].rewards;                                                                                                                                         │
│             if (reward > 0) {                                                                                                                                                                                   │
│                 userData[_account][_rewardsToken].rewards = 0;                                                                                                                                                  │
│                 if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {                                                                                                                              │
│                     IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);                                                                                                                                   │
│                 } else {                                                                                                                                                                                        │
│                     IERC20(_rewardsToken).safeTransfer(_account, reward);                                                                                                                                       │
│                 }                                                                                                                                                                                               │
│                 emit RewardPaid(_account, _rewardsToken, reward);                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {                                                                                                                 │
│         require(_amount > 0, "RewardPool : Cannot stake 0");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //give to _for                                                                                                                                                                                          │
│         _totalSupply = _totalSupply.add(_amount);                                                                                                                                                               │
│         _balances[_for] = _balances[_for].add(_amount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //take away from sender                                                                                                                                                                                 │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│         emit Staked(_for, _amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //remove lp balance                                                                                                                                                                                     │
│         address token = pool.token;                                                                                                                                                                             │
│         ITokenMinter(token).burn(_from,_amount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //pull from gauge if not shutdown                                                                                                                                                                       │
│         // if shutdown tokens will be in this contract                                                                                                                                                          │
│         if (!pool.shutdown) {                                                                                                                                                                                   │
│             IStaker(staker).withdraw(lptoken,gauge, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim                                                                                                        │
│         //do not call if shutdown since stashes wont have access                                                                                                                                                │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0) && !isShutdown && !pool.shutdown){                                                                                                                                               │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //return lp tokens                                                                                                                                                                                      │
│         IERC20(lptoken).safeTransfer(_to, _amount);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_to, _pid, _amount);                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(address _token, address _gauge) external returns(bool){                                                                                                                                │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));                                                                                                                    │
│         withdraw(_token, _gauge, amount);                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(uint256 _pid) public returns(bool){                                                                                                                                                    │
│         address token = poolInfo[_pid].token;                                                                                                                                                                   │
│         uint256 userBal = IERC20(token).balanceOf(msg.sender);                                                                                                                                                  │
│         withdraw(_pid, userBal);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function release() external returns(bool){                                                                                                                                                                  │
│         require(msg.sender == depositor, "!auth");                                                                                                                                                              │
│         ICurveVoteEscrow(escrow).withdraw();                                                                                                                                                                    │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 amount,                                                                                                                                                                                         │
│         bool claim,                                                                                                                                                                                             │
│         bool lock                                                                                                                                                                                               │
│     ) public updateReward(msg.sender) returns (bool) {                                                                                                                                                          │
│         require(amount > 0, "RewardPool : Cannot withdraw 0");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if (claim) {                                                                                                                                                                                            │
│             getReward(lock);                                                                                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function initialiseRewards() external returns (bool) {                                                                                                                                                      │
│         require(msg.sender == rewardManager || block.timestamp > startTime, "!authorized");                                                                                                                     │
│         require(rewardRate == 0, "!one time");                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint256 rewardsAvailable = rewardToken.balanceOf(address(this));                                                                                                                                        │
│         require(rewardsAvailable > 0, "!balance");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         rewardRate = rewardsAvailable.div(duration);                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         emit RewardAdded(rewardsAvailable);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function forward() public {                                                                                                                                                                                 │
│         require(block.timestamp > lastDistribution + distributionDelay, "!elapsed");                                                                                                                            │
│         lastDistribution = block.timestamp;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         uint256 bal = token.balanceOf(address(this));                                                                                                                                                           │
│         require(bal > 0, "!empty");                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         distributor.addReward(address(token), bal);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         emit Forwarded(bal);                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function init(                                                                                                                                                                                              │
│         address _to,                                                                                                                                                                                            │
│         uint256 _amount,                                                                                                                                                                                        │
│         address _minter                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(msg.sender == operator, "Only operator");                                                                                                                                                       │
│         require(totalSupply() == 0, "Only once");                                                                                                                                                               │
│         require(_amount > 0, "Must mint something");                                                                                                                                                            │
│         require(_minter != address(0), "Invalid minter");                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _mint(_to, _amount);                                                                                                                                                                                    │
│         updateOperator();                                                                                                                                                                                       │
│         minter = _minter;                                                                                                                                                                                       │
│         minterMinted = 0;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Initialised();                                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function init(                                                                                                                                                                                              │
│         address _to,                                                                                                                                                                                            │
│         uint256 _amount,                                                                                                                                                                                        │
│         address _minter                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(msg.sender == operator, "Only operator");                                                                                                                                                       │
│         require(totalSupply() == 0, "Only once");                                                                                                                                                               │
│         require(_amount > 0, "Must mint something");                                                                                                                                                            │
│         require(_minter != address(0), "Invalid minter");                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _mint(_to, _amount);                                                                                                                                                                                    │
│         updateOperator();                                                                                                                                                                                       │
│         minter = _minter;                                                                                                                                                                                       │
│         minterMinted = 0;                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit Initialised();                                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function joinPool(                                                                                                                                                                                          │
│         bytes32, /* poolId */                                                                                                                                                                                   │
│         address, /* sender */                                                                                                                                                                                   │
│         address recipient,                                                                                                                                                                                      │
│         IVault.JoinPoolRequest memory request                                                                                                                                                                   │
│     ) external payable {                                                                                                                                                                                        │
│         uint256 amount = request.maxAmountsIn[0];                                                                                                                                                               │
│         uint256 price = MockBalancerPoolToken(poolToken).price();                                                                                                                                               │
│         MockBalancerPoolToken(poolToken).mint(recipient, (amount * 1e18) / price);                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function joinPool(                                                                                                                                                                                          │
│         bytes32, /* poolId */                                                                                                                                                                                   │
│         address, /* sender */                                                                                                                                                                                   │
│         address recipient,                                                                                                                                                                                      │
│         IVault.JoinPoolRequest memory request                                                                                                                                                                   │
│     ) external payable {                                                                                                                                                                                        │
│         uint256 amount = request.maxAmountsIn[0];                                                                                                                                                               │
│         uint256 price = MockBalancerPoolToken(poolToken).price();                                                                                                                                               │
│         MockBalancerPoolToken(poolToken).mint(recipient, (amount * 1e18) / price);                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function claimCrv(address _gauge) external returns (uint256){                                                                                                                                               │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 _balance = 0;                                                                                                                                                                                   │
│         try IMinter(mintr).mint(_gauge){                                                                                                                                                                        │
│             _balance = IERC20(crv).balanceOf(address(this));                                                                                                                                                    │
│             IERC20(crv).safeTransfer(operator, _balance);                                                                                                                                                       │
│         }catch{}                                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         return _balance;                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function claimCrv(address _gauge) external returns (uint256){                                                                                                                                               │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 _balance = 0;                                                                                                                                                                                   │
│         try IMinter(mintr).mint(_gauge){                                                                                                                                                                        │
│             _balance = IERC20(crv).balanceOf(address(this));                                                                                                                                                    │
│             IERC20(crv).safeTransfer(operator, _balance);                                                                                                                                                       │
│         }catch{}                                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         return _balance;                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){                                                                                                                          │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //send to proxy to stake                                                                                                                                                                                │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //stake                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│         require(gauge != address(0),"!gauge setting");                                                                                                                                                          │
│         IStaker(staker).deposit(lptoken,gauge);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when depositing, stash them in a seperate contract until next claim                                                                                                         │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address token = pool.token;                                                                                                                                                                             │
│         if(_stake){                                                                                                                                                                                             │
│             //mint here and send to rewards on user behalf                                                                                                                                                      │
│             ITokenMinter(token).mint(address(this),_amount);                                                                                                                                                    │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(token).safeApprove(rewardContract,0);                                                                                                                                                        │
│             IERC20(token).safeApprove(rewardContract,_amount);                                                                                                                                                  │
│             IRewards(rewardContract).stakeFor(msg.sender,_amount);                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //add user balance directly                                                                                                                                                                         │
│             ITokenMinter(token).mint(msg.sender,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Deposited(msg.sender, _pid, _amount);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){                                                                                                                          │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //send to proxy to stake                                                                                                                                                                                │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //stake                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│         require(gauge != address(0),"!gauge setting");                                                                                                                                                          │
│         IStaker(staker).deposit(lptoken,gauge);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when depositing, stash them in a seperate contract until next claim                                                                                                         │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address token = pool.token;                                                                                                                                                                             │
│         if(_stake){                                                                                                                                                                                             │
│             //mint here and send to rewards on user behalf                                                                                                                                                      │
│             ITokenMinter(token).mint(address(this),_amount);                                                                                                                                                    │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(token).safeApprove(rewardContract,0);                                                                                                                                                        │
│             IERC20(token).safeApprove(rewardContract,_amount);                                                                                                                                                  │
│             IRewards(rewardContract).stakeFor(msg.sender,_amount);                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //add user balance directly                                                                                                                                                                         │
│             ITokenMinter(token).mint(msg.sender,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Deposited(msg.sender, _pid, _amount);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function rewardClaimed(uint256 _pid, address _address, uint256 _amount) external returns(bool){                                                                                                             │
│         address rewardContract = poolInfo[_pid].crvRewards;                                                                                                                                                     │
│         require(msg.sender == rewardContract || msg.sender == lockRewards, "!auth");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         //mint reward tokens                                                                                                                                                                                    │
│         ITokenMinter(minter).mint(_address,_amount);                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function rewardClaimed(uint256 _pid, address _address, uint256 _amount) external returns(bool){                                                                                                             │
│         address rewardContract = poolInfo[_pid].crvRewards;                                                                                                                                                     │
│         require(msg.sender == rewardContract || msg.sender == lockRewards, "!auth");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         //mint reward tokens                                                                                                                                                                                    │
│         ITokenMinter(minter).mint(_address,_amount);                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {                                                                                                                │
│         require(_amount > 0,"!>0");                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         if(_lock){                                                                                                                                                                                              │
│             //lock immediately, transfer directly to staker to skip an erc20 transfer                                                                                                                           │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                       │
│             _lockCurve();                                                                                                                                                                                       │
│             if(incentiveCrv > 0){                                                                                                                                                                               │
│                 //add the incentive tokens here so they can be staked together                                                                                                                                  │
│                 _amount = _amount.add(incentiveCrv);                                                                                                                                                            │
│                 incentiveCrv = 0;                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }else{                                                                                                                                                                                                  │
│             //move tokens here                                                                                                                                                                                  │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                │
│             //defer lock cost to another user                                                                                                                                                                   │
│             uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             _amount = _amount.sub(callIncentive);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //add to a pool for lock caller                                                                                                                                                                     │
│             incentiveCrv = incentiveCrv.add(callIncentive);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bool depositOnly = _stakeAddress == address(0);                                                                                                                                                         │
│         if(depositOnly){                                                                                                                                                                                        │
│             //mint for to                                                                                                                                                                                       │
│             ITokenMinter(minter).mint(to,_amount);                                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //mint here                                                                                                                                                                                         │
│             ITokenMinter(minter).mint(address(this),_amount);                                                                                                                                                   │
│             //stake for to                                                                                                                                                                                      │
│             IERC20(minter).safeApprove(_stakeAddress,0);                                                                                                                                                        │
│             IERC20(minter).safeApprove(_stakeAddress,_amount);                                                                                                                                                  │
│             IRewards(_stakeAddress).stakeFor(to,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {                                                                                                                │
│         require(_amount > 0,"!>0");                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         if(_lock){                                                                                                                                                                                              │
│             //lock immediately, transfer directly to staker to skip an erc20 transfer                                                                                                                           │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                       │
│             _lockCurve();                                                                                                                                                                                       │
│             if(incentiveCrv > 0){                                                                                                                                                                               │
│                 //add the incentive tokens here so they can be staked together                                                                                                                                  │
│                 _amount = _amount.add(incentiveCrv);                                                                                                                                                            │
│                 incentiveCrv = 0;                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }else{                                                                                                                                                                                                  │
│             //move tokens here                                                                                                                                                                                  │
│             IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                │
│             //defer lock cost to another user                                                                                                                                                                   │
│             uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             _amount = _amount.sub(callIncentive);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //add to a pool for lock caller                                                                                                                                                                     │
│             incentiveCrv = incentiveCrv.add(callIncentive);                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         bool depositOnly = _stakeAddress == address(0);                                                                                                                                                         │
│         if(depositOnly){                                                                                                                                                                                        │
│             //mint for to                                                                                                                                                                                       │
│             ITokenMinter(minter).mint(to,_amount);                                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //mint here                                                                                                                                                                                         │
│             ITokenMinter(minter).mint(address(this),_amount);                                                                                                                                                   │
│             //stake for to                                                                                                                                                                                      │
│             IERC20(minter).safeApprove(_stakeAddress,0);                                                                                                                                                        │
│             IERC20(minter).safeApprove(_stakeAddress,_amount);                                                                                                                                                  │
│             IRewards(_stakeAddress).stakeFor(to,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function lockCurve() external {                                                                                                                                                                             │
│         require(!cooldown, "cooldown");                                                                                                                                                                         │
│         _lockCurve();                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //mint incentives                                                                                                                                                                                       │
│         if(incentiveCrv > 0){                                                                                                                                                                                   │
│             ITokenMinter(minter).mint(msg.sender,incentiveCrv);                                                                                                                                                 │
│             incentiveCrv = 0;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function lockCurve() external {                                                                                                                                                                             │
│         require(!cooldown, "cooldown");                                                                                                                                                                         │
│         _lockCurve();                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //mint incentives                                                                                                                                                                                       │
│         if(incentiveCrv > 0){                                                                                                                                                                                   │
│             ITokenMinter(minter).mint(msg.sender,incentiveCrv);                                                                                                                                                 │
│             incentiveCrv = 0;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function mint(address _to, uint256 _amount) external {                                                                                                                                                      │
│         require(totalSupply() != 0, "Not initialised");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (msg.sender != operator) {                                                                                                                                                                           │
│             // dont error just return. if a shutdown happens, rewards on old system                                                                                                                             │
│             // can still be claimed, just wont mint cvx                                                                                                                                                         │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;                                                                                                                                                       │
│         uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;                                                                                                                          │
│         // e.g. reductionPerCliff = 5e25 / 500 = 1e23                                                                                                                                                           │
│         // e.g. cliff = 1e25 / 1e23 = 100                                                                                                                                                                       │
│         uint256 cliff = emissionsMinted.div(reductionPerCliff);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // e.g. 100 < 500                                                                                                                                                                                       │
│         if (cliff < totalCliffs) {                                                                                                                                                                              │
│             // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;                                                                                                                                           │
│             // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;                                                                                                                                            │
│             uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;                                                                                                                                                  │
│             // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;                                                                                                                                                │
│             // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;                                                                                                                                                  │
│             uint256 amount = _amount.mul(reduction).div(totalCliffs);                                                                                                                                           │
│             // e.g. amtTillMax = 5e25 - 1e25 = 4e25                                                                                                                                                             │
│             uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);                                                                                                                                     │
│             if (amount > amtTillMax) {                                                                                                                                                                          │
│                 amount = amtTillMax;                                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             _mint(_to, amount);                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimRewards(                                                                                                                                                                                      │
│         address[] calldata rewardContracts,                                                                                                                                                                     │
│         address[] calldata extraRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardTokens,                                                                                                                                                                   │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 options                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(tokenRewardContracts.length == tokenRewardTokens.length, "!parity");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);                                                                                                                                                 │
│         uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //claim from main curve LP pools                                                                                                                                                                        │
│         for (uint256 i = 0; i < rewardContracts.length; i++) {                                                                                                                                                  │
│             IBasicRewards(rewardContracts).getReward(msg.sender, true);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         //claim from extra rewards                                                                                                                                                                              │
│         for (uint256 i = 0; i < extraRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(extraRewardContracts).getReward(msg.sender);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         //claim from multi reward token contract                                                                                                                                                                │
│         for (uint256 i = 0; i < tokenRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(tokenRewardContracts).getReward(msg.sender, tokenRewardTokens);                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // claim others/deposit/lock/stake                                                                                                                                                                      │
│         _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimRewards() external returns (bool) {                                                                                                                                                           │
│         require(msg.sender == operator, "!operator");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //this is updateable from v2 gauges now so must check each time.                                                                                                                                        │
│         checkForNewRewardTokens();                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //make sure we're redirected                                                                                                                                                                            │
│         if(!hasRedirected){                                                                                                                                                                                     │
│             IDeposit(operator).setGaugeRedirect(pid);                                                                                                                                                           │
│             hasRedirected = true;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if(hasCurveRewards){                                                                                                                                                                                    │
│             //claim rewards on gauge for staker                                                                                                                                                                 │
│             //using reward_receiver so all rewards will be moved to this stash                                                                                                                                  │
│             IDeposit(operator).claimRewards(pid,gauge);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //hook for reward pulls                                                                                                                                                                                 │
│         if(rewardHook != address(0)){                                                                                                                                                                           │
│             try IRewardHook(rewardHook).onRewardClaim(){                                                                                                                                                        │
│             }catch{}                                                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function claimRewards(                                                                                                                                                                                      │
│         address[] calldata rewardContracts,                                                                                                                                                                     │
│         address[] calldata extraRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardTokens,                                                                                                                                                                   │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 options                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(tokenRewardContracts.length == tokenRewardTokens.length, "!parity");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);                                                                                                                                                 │
│         uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //claim from main curve LP pools                                                                                                                                                                        │
│         for (uint256 i = 0; i < rewardContracts.length; i++) {                                                                                                                                                  │
│             IBasicRewards(rewardContracts).getReward(msg.sender, true);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         //claim from extra rewards                                                                                                                                                                              │
│         for (uint256 i = 0; i < extraRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(extraRewardContracts).getReward(msg.sender);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         //claim from multi reward token contract                                                                                                                                                                │
│         for (uint256 i = 0; i < tokenRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(tokenRewardContracts).getReward(msg.sender, tokenRewardTokens);                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // claim others/deposit/lock/stake                                                                                                                                                                      │
│         _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function claimRewards() external returns (bool) {                                                                                                                                                           │
│         require(msg.sender == operator, "!operator");                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         //this is updateable from v2 gauges now so must check each time.                                                                                                                                        │
│         checkForNewRewardTokens();                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //make sure we're redirected                                                                                                                                                                            │
│         if(!hasRedirected){                                                                                                                                                                                     │
│             IDeposit(operator).setGaugeRedirect(pid);                                                                                                                                                           │
│             hasRedirected = true;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if(hasCurveRewards){                                                                                                                                                                                    │
│             //claim rewards on gauge for staker                                                                                                                                                                 │
│             //using reward_receiver so all rewards will be moved to this stash                                                                                                                                  │
│             IDeposit(operator).claimRewards(pid,gauge);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //hook for reward pulls                                                                                                                                                                                 │
│         if(rewardHook != address(0)){                                                                                                                                                                           │
│             try IRewardHook(rewardHook).onRewardClaim(){                                                                                                                                                        │
│             }catch{}                                                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function claimRewards(                                                                                                                                                                                      │
│         address[] calldata rewardContracts,                                                                                                                                                                     │
│         address[] calldata extraRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardTokens,                                                                                                                                                                   │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 options                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(tokenRewardContracts.length == tokenRewardTokens.length, "!parity");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);                                                                                                                                                 │
│         uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //claim from main curve LP pools                                                                                                                                                                        │
│         for (uint256 i = 0; i < rewardContracts.length; i++) {                                                                                                                                                  │
│             IBasicRewards(rewardContracts).getReward(msg.sender, true);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         //claim from extra rewards                                                                                                                                                                              │
│         for (uint256 i = 0; i < extraRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(extraRewardContracts).getReward(msg.sender);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         //claim from multi reward token contract                                                                                                                                                                │
│         for (uint256 i = 0; i < tokenRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(tokenRewardContracts).getReward(msg.sender, tokenRewardTokens);                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // claim others/deposit/lock/stake                                                                                                                                                                      │
│         _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _earmarkRewards(uint256 _pid) internal {                                                                                                                                                           │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //claim crv                                                                                                                                                                                             │
│         IStaker(staker).claimCrv(gauge);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //check if there are extra rewards                                                                                                                                                                      │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             //claim extra rewards                                                                                                                                                                               │
│             IStash(stash).claimRewards();                                                                                                                                                                       │
│             //process extra rewards                                                                                                                                                                             │
│             IStash(stash).processStash();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //crv balance                                                                                                                                                                                           │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             // LockIncentive = cvxCrv stakers (currently 10%)                                                                                                                                                   │
│             uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             // StakerIncentive = cvx stakers (currently 5%)                                                                                                                                                     │
│             uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);                                                                                                                        │
│             // CallIncentive = caller of this contract (currently 1%)                                                                                                                                           │
│             uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);                                                                                                                         │
│                                                                                                                                                                                                                 │
│             // Treasury = vlCVX (currently 1%)                                                                                                                                                                  │
│             if(treasury != address(0) && treasury != address(this) && platformFee > 0){                                                                                                                         │
│                 //only subtract after address condition check                                                                                                                                                   │
│                 uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);                                                                                                                               │
│                 crvBal = crvBal.sub(_platform);                                                                                                                                                                 │
│                 IERC20(crv).safeTransfer(treasury, _platform);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //remove incentives from balance                                                                                                                                                                    │
│             crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);                                                                                                                      │
│                                                                                                                                                                                                                 │
│             //send incentives for calling                                                                                                                                                                       │
│             IERC20(crv).safeTransfer(msg.sender, _callIncentive);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send crv to lp provider reward contract                                                                                                                                                           │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(crv).safeTransfer(rewardContract, crvBal);                                                                                                                                                   │
│             IRewards(rewardContract).queueNewRewards(crvBal);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //send lockers' share of crv to reward contract                                                                                                                                                     │
│             IERC20(crv).safeTransfer(lockRewards, _lockIncentive);                                                                                                                                              │
│             IRewards(lockRewards).queueNewRewards(_lockIncentive);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             //send stakers's share of crv to reward contract                                                                                                                                                    │
│             IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function claimRewards(                                                                                                                                                                                      │
│         address[] calldata rewardContracts,                                                                                                                                                                     │
│         address[] calldata extraRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardTokens,                                                                                                                                                                   │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 options                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(tokenRewardContracts.length == tokenRewardTokens.length, "!parity");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);                                                                                                                                                 │
│         uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //claim from main curve LP pools                                                                                                                                                                        │
│         for (uint256 i = 0; i < rewardContracts.length; i++) {                                                                                                                                                  │
│             IBasicRewards(rewardContracts).getReward(msg.sender, true);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         //claim from extra rewards                                                                                                                                                                              │
│         for (uint256 i = 0; i < extraRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(extraRewardContracts).getReward(msg.sender);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         //claim from multi reward token contract                                                                                                                                                                │
│         for (uint256 i = 0; i < tokenRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(tokenRewardContracts).getReward(msg.sender, tokenRewardTokens);                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // claim others/deposit/lock/stake                                                                                                                                                                      │
│         _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _earmarkRewards(uint256 _pid) internal {                                                                                                                                                           │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //claim crv                                                                                                                                                                                             │
│         IStaker(staker).claimCrv(gauge);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //check if there are extra rewards                                                                                                                                                                      │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             //claim extra rewards                                                                                                                                                                               │
│             IStash(stash).claimRewards();                                                                                                                                                                       │
│             //process extra rewards                                                                                                                                                                             │
│             IStash(stash).processStash();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //crv balance                                                                                                                                                                                           │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             // LockIncentive = cvxCrv stakers (currently 10%)                                                                                                                                                   │
│             uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);                                                                                                                            │
│             // StakerIncentive = cvx stakers (currently 5%)                                                                                                                                                     │
│             uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);                                                                                                                        │
│             // CallIncentive = caller of this contract (currently 1%)                                                                                                                                           │
│             uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);                                                                                                                         │
│                                                                                                                                                                                                                 │
│             // Treasury = vlCVX (currently 1%)                                                                                                                                                                  │
│             if(treasury != address(0) && treasury != address(this) && platformFee > 0){                                                                                                                         │
│                 //only subtract after address condition check                                                                                                                                                   │
│                 uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);                                                                                                                               │
│                 crvBal = crvBal.sub(_platform);                                                                                                                                                                 │
│                 IERC20(crv).safeTransfer(treasury, _platform);                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //remove incentives from balance                                                                                                                                                                    │
│             crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);                                                                                                                      │
│                                                                                                                                                                                                                 │
│             //send incentives for calling                                                                                                                                                                       │
│             IERC20(crv).safeTransfer(msg.sender, _callIncentive);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send crv to lp provider reward contract                                                                                                                                                           │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(crv).safeTransfer(rewardContract, crvBal);                                                                                                                                                   │
│             IRewards(rewardContract).queueNewRewards(crvBal);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //send lockers' share of crv to reward contract                                                                                                                                                     │
│             IERC20(crv).safeTransfer(lockRewards, _lockIncentive);                                                                                                                                              │
│             IRewards(lockRewards).queueNewRewards(_lockIncentive);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             //send stakers's share of crv to reward contract                                                                                                                                                    │
│             IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function claimRewards(                                                                                                                                                                                      │
│         address[] calldata rewardContracts,                                                                                                                                                                     │
│         address[] calldata extraRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardTokens,                                                                                                                                                                   │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 options                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(tokenRewardContracts.length == tokenRewardTokens.length, "!parity");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);                                                                                                                                                 │
│         uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //claim from main curve LP pools                                                                                                                                                                        │
│         for (uint256 i = 0; i < rewardContracts.length; i++) {                                                                                                                                                  │
│             IBasicRewards(rewardContracts).getReward(msg.sender, true);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         //claim from extra rewards                                                                                                                                                                              │
│         for (uint256 i = 0; i < extraRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(extraRewardContracts).getReward(msg.sender);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         //claim from multi reward token contract                                                                                                                                                                │
│         for (uint256 i = 0; i < tokenRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(tokenRewardContracts).getReward(msg.sender, tokenRewardTokens);                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // claim others/deposit/lock/stake                                                                                                                                                                      │
│         _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimRewards(uint256 _pid, address _gauge) external returns(bool){                                                                                                                                 │
│         address stash = poolInfo[_pid].stash;                                                                                                                                                                   │
│         require(msg.sender == stash,"!auth");                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         IStaker(staker).claimRewards(_gauge);                                                                                                                                                                   │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function claimRewards(                                                                                                                                                                                      │
│         address[] calldata rewardContracts,                                                                                                                                                                     │
│         address[] calldata extraRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardTokens,                                                                                                                                                                   │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 options                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(tokenRewardContracts.length == tokenRewardTokens.length, "!parity");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);                                                                                                                                                 │
│         uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //claim from main curve LP pools                                                                                                                                                                        │
│         for (uint256 i = 0; i < rewardContracts.length; i++) {                                                                                                                                                  │
│             IBasicRewards(rewardContracts).getReward(msg.sender, true);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         //claim from extra rewards                                                                                                                                                                              │
│         for (uint256 i = 0; i < extraRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(extraRewardContracts).getReward(msg.sender);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         //claim from multi reward token contract                                                                                                                                                                │
│         for (uint256 i = 0; i < tokenRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(tokenRewardContracts).getReward(msg.sender, tokenRewardTokens);                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // claim others/deposit/lock/stake                                                                                                                                                                      │
│         _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _claimExtras( // solhint-disable-line                                                                                                                                                              │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 removeCrvBalance,                                                                                                                                                                               │
│         uint256 removeCvxBalance,                                                                                                                                                                               │
│         uint256 options                                                                                                                                                                                         │
│     ) internal {                                                                                                                                                                                                │
│         //claim from cvxCrv rewards                                                                                                                                                                             │
│         if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {                                                                                                                                              │
│             IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //claim from locker                                                                                                                                                                                     │
│         if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {                                                                                                                                           │
│             IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //reset remove balances if we want to also stake/lock funds already in our wallet                                                                                                                       │
│         if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {                                                                                                                                        │
│             removeCrvBalance = 0;                                                                                                                                                                               │
│             removeCvxBalance = 0;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //lock upto given amount of crv and stake                                                                                                                                                               │
│         if (depositCrvMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);                                                                                                                       │
│             crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             if (crvBalance > 0) {                                                                                                                                                                               │
│                 //pull crv                                                                                                                                                                                      │
│                 IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);                                                                                                                            │
│                 //deposit                                                                                                                                                                                       │
│                 ICrvDepositorWrapper(crvDepositWrapper).deposit(                                                                                                                                                │
│                     crvBalance,                                                                                                                                                                                 │
│                     minAmountOut,                                                                                                                                                                               │
│                     _checkOption(options, uint256(Options.LockCrvDeposit)),                                                                                                                                     │
│                     address(0)                                                                                                                                                                                  │
│                 );                                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                │
│                 //stake for msg.sender                                                                                                                                                                          │
│                 IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //stake up to given amount of cvx                                                                                                                                                                       │
│         if (depositCvxMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);                                                                                                                       │
│             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);                                                                                                                                         │
│             if (cvxBalance > 0) {                                                                                                                                                                               │
│                 //pull cvx                                                                                                                                                                                      │
│                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                                                                                                                            │
│                 if (_checkOption(options, uint256(Options.LockCvx))) {                                                                                                                                          │
│                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                                                                                                                                           │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimRewards(                                                                                                                                                                                      │
│         address[] calldata rewardContracts,                                                                                                                                                                     │
│         address[] calldata extraRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardContracts,                                                                                                                                                                │
│         address[] calldata tokenRewardTokens,                                                                                                                                                                   │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 options                                                                                                                                                                                         │
│     ) external {                                                                                                                                                                                                │
│         require(tokenRewardContracts.length == tokenRewardTokens.length, "!parity");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);                                                                                                                                                 │
│         uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //claim from main curve LP pools                                                                                                                                                                        │
│         for (uint256 i = 0; i < rewardContracts.length; i++) {                                                                                                                                                  │
│             IBasicRewards(rewardContracts).getReward(msg.sender, true);                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         //claim from extra rewards                                                                                                                                                                              │
│         for (uint256 i = 0; i < extraRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(extraRewardContracts).getReward(msg.sender);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         //claim from multi reward token contract                                                                                                                                                                │
│         for (uint256 i = 0; i < tokenRewardContracts.length; i++) {                                                                                                                                             │
│             IBasicRewards(tokenRewardContracts).getReward(msg.sender, tokenRewardTokens);                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // claim others/deposit/lock/stake                                                                                                                                                                      │
│         _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);                                                                                                  │
│     }                                                                                                                                                                                                           │
│     function _claimExtras( // solhint-disable-line                                                                                                                                                              │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 removeCrvBalance,                                                                                                                                                                               │
│         uint256 removeCvxBalance,                                                                                                                                                                               │
│         uint256 options                                                                                                                                                                                         │
│     ) internal {                                                                                                                                                                                                │
│         //claim from cvxCrv rewards                                                                                                                                                                             │
│         if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {                                                                                                                                              │
│             IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //claim from locker                                                                                                                                                                                     │
│         if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {                                                                                                                                           │
│             IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //reset remove balances if we want to also stake/lock funds already in our wallet                                                                                                                       │
│         if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {                                                                                                                                        │
│             removeCrvBalance = 0;                                                                                                                                                                               │
│             removeCvxBalance = 0;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //lock upto given amount of crv and stake                                                                                                                                                               │
│         if (depositCrvMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);                                                                                                                       │
│             crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             if (crvBalance > 0) {                                                                                                                                                                               │
│                 //pull crv                                                                                                                                                                                      │
│                 IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);                                                                                                                            │
│                 //deposit                                                                                                                                                                                       │
│                 ICrvDepositorWrapper(crvDepositWrapper).deposit(                                                                                                                                                │
│                     crvBalance,                                                                                                                                                                                 │
│                     minAmountOut,                                                                                                                                                                               │
│                     _checkOption(options, uint256(Options.LockCrvDeposit)),                                                                                                                                     │
│                     address(0)                                                                                                                                                                                  │
│                 );                                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                │
│                 //stake for msg.sender                                                                                                                                                                          │
│                 IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //stake up to given amount of cvx                                                                                                                                                                       │
│         if (depositCvxMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);                                                                                                                       │
│             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);                                                                                                                                         │
│             if (cvxBalance > 0) {                                                                                                                                                                               │
│                 //pull cvx                                                                                                                                                                                      │
│                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                                                                                                                            │
│                 if (_checkOption(options, uint256(Options.LockCvx))) {                                                                                                                                          │
│                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                                                                                                                                           │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ have inside code statements that invoke user checkpoint,                                                                                                                                                        │
│ Code:                                                                                                                                                                                                           │
│     function _lock(address _account, uint256 _amount) internal {                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         uint112 lockAmount = _amount.to112();                                                                                                                                                                   │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(_amount);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                       │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));                                                                                                    │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address delegatee = delegates(_account);                                                                                                                                                                │
│         if (delegatee != address(0)) {                                                                                                                                                                          │
│             delegateeUnlocks += lockAmount;                                                                                                                                                                     │
│             _checkpointDelegate(delegatee, lockAmount, 0);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(lockAmount);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, lockAmount, lockAmount);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes",                                                                                                                                                                                                 │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _lock(address _account, uint256 _amount) internal {                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         uint112 lockAmount = _amount.to112();                                                                                                                                                                   │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(_amount);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                       │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));                                                                                                    │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address delegatee = delegates(_account);                                                                                                                                                                │
│         if (delegatee != address(0)) {                                                                                                                                                                          │
│             delegateeUnlocks += lockAmount;                                                                                                                                                                     │
│             _checkpointDelegate(delegatee, lockAmount, 0);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(lockAmount);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, lockAmount, lockAmount);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _processExpiredLocks(                                                                                                                                                                              │
│         address _account,                                                                                                                                                                                       │
│         bool _relock,                                                                                                                                                                                           │
│         address _rewardAddress,                                                                                                                                                                                 │
│         uint256 _checkDelay                                                                                                                                                                                     │
│     ) internal updateReward(_account) {                                                                                                                                                                         │
│         LockedBalance[] storage locks = userLocks[_account];                                                                                                                                                    │
│         Balances storage userBalance = balances[_account];                                                                                                                                                      │
│         uint112 locked;                                                                                                                                                                                         │
│         uint256 length = locks.length;                                                                                                                                                                          │
│         uint256 reward = 0;                                                                                                                                                                                     │
│         uint256 expiryTime = _checkDelay == 0 && _relock                                                                                                                                                        │
│             ? block.timestamp.add(rewardsDuration)                                                                                                                                                              │
│             : block.timestamp.sub(_checkDelay);                                                                                                                                                                 │
│         require(length > 0, "no locks");                                                                                                                                                                        │
│         // e.g. now = 16                                                                                                                                                                                        │
│         // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)                                                                                                                            │
│         // e.g. 17 <= (16 + 1)                                                                                                                                                                                  │
│         if (isShutdown || locks.unlockTime <= expiryTime) {                                                                                                                                                     │
│             //if time is beyond last lock, can just bundle everything together                                                                                                                                  │
│             locked = userBalance.locked;                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             //dont delete, just set next index                                                                                                                                                                  │
│             userBalance.nextUnlockIndex = length.to32();                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             //check for kick reward                                                                                                                                                                             │
│             //this wont have the exact reward rate that you would get if looped through                                                                                                                         │
│             //but this section is supposed to be for quick and easy low gas processing of all locks                                                                                                             │
│             //we'll assume that if the reward was good enough someone would have processed at an earlier epoch                                                                                                  │
│             if (_checkDelay > 0) {                                                                                                                                                                              │
│                 uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);                                                                                              │
│                 uint256 epochsover = currentEpoch.sub(uint256(locks.unlockTime)).div(rewardsDuration);                                                                                                          │
│                 uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);                                                                                                              │
│                 reward = uint256(locks.amount).mul(rRate).div(denominator);                                                                                                                                     │
│             }                                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             //use a processed index(nextUnlockIndex) to not loop as much                                                                                                                                        │
│             //deleting does not change array length                                                                                                                                                             │
│             uint32 nextUnlockIndex = userBalance.nextUnlockIndex;                                                                                                                                               │
│             for (uint256 i = nextUnlockIndex; i < length; i++) {                                                                                                                                                │
│                 //unlock time must be less or equal to time                                                                                                                                                     │
│                 if (locks.unlockTime > expiryTime) break;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                 //add to cumulative amounts                                                                                                                                                                     │
│                 locked = locked.add(locks.amount);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 //check for kick reward                                                                                                                                                                         │
│                 //each epoch over due increases reward                                                                                                                                                          │
│                 if (_checkDelay > 0) {                                                                                                                                                                          │
│                     uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);                                                                                          │
│                     uint256 epochsover = currentEpoch.sub(uint256(locks.unlockTime)).div(rewardsDuration);                                                                                                      │
│                     uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);                                                                                                          │
│                     reward = reward.add(uint256(locks.amount).mul(rRate).div(denominator));                                                                                                                     │
│                 }                                                                                                                                                                                               │
│                 //set next unlock index                                                                                                                                                                         │
│                 nextUnlockIndex++;                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             //update next unlock index                                                                                                                                                                          │
│             userBalance.nextUnlockIndex = nextUnlockIndex;                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│         require(locked > 0, "no exp locks");                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //update user balances and total supplies                                                                                                                                                               │
│         userBalance.locked = userBalance.locked.sub(locked);                                                                                                                                                    │
│         lockedSupply = lockedSupply.sub(locked);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //checkpoint the delegatee                                                                                                                                                                              │
│         _checkpointDelegate(delegates(_account), 0, 0);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_account, locked, _relock);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //send process incentive                                                                                                                                                                                │
│         if (reward > 0) {                                                                                                                                                                                       │
│             //reduce return amount by the kick reward                                                                                                                                                           │
│             locked = locked.sub(reward.to112());                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             //transfer reward                                                                                                                                                                                   │
│             stakingToken.safeTransfer(_rewardAddress, reward);                                                                                                                                                  │
│             emit KickReward(_rewardAddress, _account, reward);                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //relock or return to user                                                                                                                                                                              │
│         if (_relock) {                                                                                                                                                                                          │
│             _lock(_account, locked);                                                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             stakingToken.safeTransfer(_account, locked);                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _lock(address _account, uint256 _amount) internal {                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         uint112 lockAmount = _amount.to112();                                                                                                                                                                   │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(_amount);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                       │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));                                                                                                    │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address delegatee = delegates(_account);                                                                                                                                                                │
│         if (delegatee != address(0)) {                                                                                                                                                                          │
│             delegateeUnlocks += lockAmount;                                                                                                                                                                     │
│             _checkpointDelegate(delegatee, lockAmount, 0);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(lockAmount);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, lockAmount, lockAmount);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {                                                                                                             │
│         //pull tokens                                                                                                                                                                                           │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //lock                                                                                                                                                                                                  │
│         _lock(_account, _amount);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function _lock(address _account, uint256 _amount) internal {                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         uint112 lockAmount = _amount.to112();                                                                                                                                                                   │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(_amount);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                       │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));                                                                                                    │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address delegatee = delegates(_account);                                                                                                                                                                │
│         if (delegatee != address(0)) {                                                                                                                                                                          │
│             delegateeUnlocks += lockAmount;                                                                                                                                                                     │
│             _checkpointDelegate(delegatee, lockAmount, 0);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(lockAmount);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, lockAmount, lockAmount);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {                                                                                                             │
│         //pull tokens                                                                                                                                                                                           │
│         stakingToken.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //lock                                                                                                                                                                                                  │
│         _lock(_account, _amount);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function _lock(address _account, uint256 _amount) internal {                                                                                                                                                │
│         require(_amount > 0, "Cannot stake 0");                                                                                                                                                                 │
│         require(!isShutdown, "shutdown");                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         Balances storage bal = balances[_account];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //must try check pointing epoch first                                                                                                                                                                   │
│         _checkpointEpoch();                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         //add user balances                                                                                                                                                                                     │
│         uint112 lockAmount = _amount.to112();                                                                                                                                                                   │
│         bal.locked = bal.locked.add(lockAmount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //add to total supplies                                                                                                                                                                                 │
│         lockedSupply = lockedSupply.add(_amount);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //add user lock records or add to current                                                                                                                                                               │
│         uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                       │
│         uint256 unlockTime = currentEpoch.add(lockDuration);                                                                                                                                                    │
│         uint256 idx = userLocks[_account].length;                                                                                                                                                               │
│         if (idx == 0 || userLocks[_account].unlockTime < unlockTime) {                                                                                                                                          │
│             userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));                                                                                                    │
│         } else {                                                                                                                                                                                                │
│             LockedBalance storage userL = userLocks[_account];                                                                                                                                                  │
│             userL.amount = userL.amount.add(lockAmount);                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address delegatee = delegates(_account);                                                                                                                                                                │
│         if (delegatee != address(0)) {                                                                                                                                                                          │
│             delegateeUnlocks += lockAmount;                                                                                                                                                                     │
│             _checkpointDelegate(delegatee, lockAmount, 0);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //update epoch supply, epoch checkpointed above so safe to add to latest                                                                                                                                │
│         Epoch storage e = epochs;                                                                                                                                                                               │
│         e.supply = e.supply.add(lockAmount);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         emit Staked(_account, lockAmount, lockAmount);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _processExpiredLocks(                                                                                                                                                                              │
│         address _account,                                                                                                                                                                                       │
│         bool _relock,                                                                                                                                                                                           │
│         address _rewardAddress,                                                                                                                                                                                 │
│         uint256 _checkDelay                                                                                                                                                                                     │
│     ) internal updateReward(_account) {                                                                                                                                                                         │
│         LockedBalance[] storage locks = userLocks[_account];                                                                                                                                                    │
│         Balances storage userBalance = balances[_account];                                                                                                                                                      │
│         uint112 locked;                                                                                                                                                                                         │
│         uint256 length = locks.length;                                                                                                                                                                          │
│         uint256 reward = 0;                                                                                                                                                                                     │
│         uint256 expiryTime = _checkDelay == 0 && _relock                                                                                                                                                        │
│             ? block.timestamp.add(rewardsDuration)                                                                                                                                                              │
│             : block.timestamp.sub(_checkDelay);                                                                                                                                                                 │
│         require(length > 0, "no locks");                                                                                                                                                                        │
│         // e.g. now = 16                                                                                                                                                                                        │
│         // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)                                                                                                                            │
│         // e.g. 17 <= (16 + 1)                                                                                                                                                                                  │
│         if (isShutdown || locks.unlockTime <= expiryTime) {                                                                                                                                                     │
│             //if time is beyond last lock, can just bundle everything together                                                                                                                                  │
│             locked = userBalance.locked;                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             //dont delete, just set next index                                                                                                                                                                  │
│             userBalance.nextUnlockIndex = length.to32();                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│             //check for kick reward                                                                                                                                                                             │
│             //this wont have the exact reward rate that you would get if looped through                                                                                                                         │
│             //but this section is supposed to be for quick and easy low gas processing of all locks                                                                                                             │
│             //we'll assume that if the reward was good enough someone would have processed at an earlier epoch                                                                                                  │
│             if (_checkDelay > 0) {                                                                                                                                                                              │
│                 uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);                                                                                              │
│                 uint256 epochsover = currentEpoch.sub(uint256(locks.unlockTime)).div(rewardsDuration);                                                                                                          │
│                 uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);                                                                                                              │
│                 reward = uint256(locks.amount).mul(rRate).div(denominator);                                                                                                                                     │
│             }                                                                                                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             //use a processed index(nextUnlockIndex) to not loop as much                                                                                                                                        │
│             //deleting does not change array length                                                                                                                                                             │
│             uint32 nextUnlockIndex = userBalance.nextUnlockIndex;                                                                                                                                               │
│             for (uint256 i = nextUnlockIndex; i < length; i++) {                                                                                                                                                │
│                 //unlock time must be less or equal to time                                                                                                                                                     │
│                 if (locks.unlockTime > expiryTime) break;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                 //add to cumulative amounts                                                                                                                                                                     │
│                 locked = locked.add(locks.amount);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 //check for kick reward                                                                                                                                                                         │
│                 //each epoch over due increases reward                                                                                                                                                          │
│                 if (_checkDelay > 0) {                                                                                                                                                                          │
│                     uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);                                                                                          │
│                     uint256 epochsover = currentEpoch.sub(uint256(locks.unlockTime)).div(rewardsDuration);                                                                                                      │
│                     uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);                                                                                                          │
│                     reward = reward.add(uint256(locks.amount).mul(rRate).div(denominator));                                                                                                                     │
│                 }                                                                                                                                                                                               │
│                 //set next unlock index                                                                                                                                                                         │
│                 nextUnlockIndex++;                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             //update next unlock index                                                                                                                                                                          │
│             userBalance.nextUnlockIndex = nextUnlockIndex;                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│         require(locked > 0, "no exp locks");                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //update user balances and total supplies                                                                                                                                                               │
│         userBalance.locked = userBalance.locked.sub(locked);                                                                                                                                                    │
│         lockedSupply = lockedSupply.sub(locked);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //checkpoint the delegatee                                                                                                                                                                              │
│         _checkpointDelegate(delegates(_account), 0, 0);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_account, locked, _relock);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         //send process incentive                                                                                                                                                                                │
│         if (reward > 0) {                                                                                                                                                                                       │
│             //reduce return amount by the kick reward                                                                                                                                                           │
│             locked = locked.sub(reward.to112());                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             //transfer reward                                                                                                                                                                                   │
│             stakingToken.safeTransfer(_rewardAddress, reward);                                                                                                                                                  │
│             emit KickReward(_rewardAddress, _account, reward);                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //relock or return to user                                                                                                                                                                              │
│         if (_relock) {                                                                                                                                                                                          │
│             _lock(_account, locked);                                                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             stakingToken.safeTransfer(_account, locked);                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function delegate(address newDelegatee) external virtual nonReentrant {                                                                                                                                     │
│         // Step 1: Get lock data                                                                                                                                                                                │
│         LockedBalance[] storage locks = userLocks;                                                                                                                                                              │
│         uint256 len = locks.length;                                                                                                                                                                             │
│         require(len > 0, "Nothing to delegate");                                                                                                                                                                │
│         require(newDelegatee != address(0), "Must delegate to someone");                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Step 2: Update delegatee storage                                                                                                                                                                     │
│         address oldDelegatee = delegates(msg.sender);                                                                                                                                                           │
│         require(newDelegatee != oldDelegatee, "Must choose new delegatee");                                                                                                                                     │
│         _delegates = newDelegatee;                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         // Step 3: Move balances around                                                                                                                                                                         │
│         //         Delegate for the upcoming epoch                                                                                                                                                              │
│         uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);                                                                                                 │
│         uint256 i = len - 1;                                                                                                                                                                                    │
│         uint256 futureUnlocksSum = 0;                                                                                                                                                                           │
│         LockedBalance memory currentLock = locks;                                                                                                                                                               │
│         // Step 3.1: Add future unlocks and sum balances                                                                                                                                                        │
│         while (currentLock.unlockTime > upcomingEpoch) {                                                                                                                                                        │
│             futureUnlocksSum += currentLock.amount;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             if (oldDelegatee != address(0)) {                                                                                                                                                                   │
│                 delegateeUnlocks -= currentLock.amount;                                                                                                                                                         │
│             }                                                                                                                                                                                                   │
│             delegateeUnlocks += currentLock.amount;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             if (i > 0) {                                                                                                                                                                                        │
│                 i--;                                                                                                                                                                                            │
│                 currentLock = locks;                                                                                                                                                                            │
│             } else {                                                                                                                                                                                            │
│                 break;                                                                                                                                                                                          │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Step 3.2: Checkpoint old delegatee                                                                                                                                                                   │
│         _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Step 3.3: Checkpoint new delegatee                                                                                                                                                                   │
│         _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                   │
│ Code:                                                                                                                                                                                                           │
│     function delegate(address newDelegatee) external virtual nonReentrant {                                                                                                                                     │
│         // Step 1: Get lock data                                                                                                                                                                                │
│         LockedBalance[] storage locks = userLocks;                                                                                                                                                              │
│         uint256 len = locks.length;                                                                                                                                                                             │
│         require(len > 0, "Nothing to delegate");                                                                                                                                                                │
│         require(newDelegatee != address(0), "Must delegate to someone");                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Step 2: Update delegatee storage                                                                                                                                                                     │
│         address oldDelegatee = delegates(msg.sender);                                                                                                                                                           │
│         require(newDelegatee != oldDelegatee, "Must choose new delegatee");                                                                                                                                     │
│         _delegates = newDelegatee;                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         // Step 3: Move balances around                                                                                                                                                                         │
│         //         Delegate for the upcoming epoch                                                                                                                                                              │
│         uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);                                                                                                 │
│         uint256 i = len - 1;                                                                                                                                                                                    │
│         uint256 futureUnlocksSum = 0;                                                                                                                                                                           │
│         LockedBalance memory currentLock = locks;                                                                                                                                                               │
│         // Step 3.1: Add future unlocks and sum balances                                                                                                                                                        │
│         while (currentLock.unlockTime > upcomingEpoch) {                                                                                                                                                        │
│             futureUnlocksSum += currentLock.amount;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             if (oldDelegatee != address(0)) {                                                                                                                                                                   │
│                 delegateeUnlocks -= currentLock.amount;                                                                                                                                                         │
│             }                                                                                                                                                                                                   │
│             delegateeUnlocks += currentLock.amount;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             if (i > 0) {                                                                                                                                                                                        │
│                 i--;                                                                                                                                                                                            │
│                 currentLock = locks;                                                                                                                                                                            │
│             } else {                                                                                                                                                                                            │
│                 break;                                                                                                                                                                                          │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Step 3.2: Checkpoint old delegatee                                                                                                                                                                   │
│         _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Step 3.3: Checkpoint new delegatee                                                                                                                                                                   │
│         _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function _checkpointDelegate(                                                                                                                                                                               │
│         address _account,                                                                                                                                                                                       │
│         uint256 _upcomingAddition,                                                                                                                                                                              │
│         uint256 _upcomingDeduction                                                                                                                                                                              │
│     ) internal {                                                                                                                                                                                                │
│         // This would only skip on first checkpointing                                                                                                                                                          │
│         if (_account != address(0)) {                                                                                                                                                                           │
│             uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);                                                                                             │
│             DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];                                                                                                                                 │
│             if (ckpts.length > 0) {                                                                                                                                                                             │
│                 DelegateeCheckpoint memory prevCkpt = ckpts;                                                                                                                                                    │
│                 // If there has already been a record for the upcoming epoch, no need to deduct the unlocks                                                                                                     │
│                 if (prevCkpt.epochStart == upcomingEpoch) {                                                                                                                                                     │
│                     ckpts = DelegateeCheckpoint({                                                                                                                                                               │
│                         votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),                                                                                                               │
│                         epochStart: upcomingEpoch.to32()                                                                                                                                                        │
│                     });                                                                                                                                                                                         │
│                 }                                                                                                                                                                                               │
│                 // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired                                                                                                │
│                 // e.g. week 1 + 17 <= 18                                                                                                                                                                       │
│                 else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {                                                                                                                                 │
│                     ckpts.push(                                                                                                                                                                                 │
│                         DelegateeCheckpoint({                                                                                                                                                                   │
│                             votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                            │
│                             epochStart: upcomingEpoch.to32()                                                                                                                                                    │
│                         })                                                                                                                                                                                      │
│                     );                                                                                                                                                                                          │
│                 } else {                                                                                                                                                                                        │
│                     uint256 nextEpoch = upcomingEpoch;                                                                                                                                                          │
│                     uint256 unlocksSinceLatestCkpt = 0;                                                                                                                                                         │
│                     // Should be maximum 18 iterations                                                                                                                                                          │
│                     while (nextEpoch > prevCkpt.epochStart) {                                                                                                                                                   │
│                         unlocksSinceLatestCkpt += delegateeUnlocks[_account];                                                                                                                                   │
│                         nextEpoch -= rewardsDuration;                                                                                                                                                           │
│                     }                                                                                                                                                                                           │
│                     ckpts.push(                                                                                                                                                                                 │
│                         DelegateeCheckpoint({                                                                                                                                                                   │
│                             votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)                                                                                           │
│                                 .to224(),                                                                                                                                                                       │
│                             epochStart: upcomingEpoch.to32()                                                                                                                                                    │
│                         })                                                                                                                                                                                      │
│                     );                                                                                                                                                                                          │
│                 }                                                                                                                                                                                               │
│             } else {                                                                                                                                                                                            │
│                 ckpts.push(                                                                                                                                                                                     │
│                     DelegateeCheckpoint({                                                                                                                                                                       │
│                         votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                                │
│                         epochStart: upcomingEpoch.to32()                                                                                                                                                        │
│                     })                                                                                                                                                                                          │
│                 );                                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             emit DelegateCheckpointed(_account);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                   │
│ Code:                                                                                                                                                                                                           │
│     function _checkpointDelegate(                                                                                                                                                                               │
│         address _account,                                                                                                                                                                                       │
│         uint256 _upcomingAddition,                                                                                                                                                                              │
│         uint256 _upcomingDeduction                                                                                                                                                                              │
│     ) internal {                                                                                                                                                                                                │
│         // This would only skip on first checkpointing                                                                                                                                                          │
│         if (_account != address(0)) {                                                                                                                                                                           │
│             uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);                                                                                             │
│             DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];                                                                                                                                 │
│             if (ckpts.length > 0) {                                                                                                                                                                             │
│                 DelegateeCheckpoint memory prevCkpt = ckpts;                                                                                                                                                    │
│                 // If there has already been a record for the upcoming epoch, no need to deduct the unlocks                                                                                                     │
│                 if (prevCkpt.epochStart == upcomingEpoch) {                                                                                                                                                     │
│                     ckpts = DelegateeCheckpoint({                                                                                                                                                               │
│                         votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),                                                                                                               │
│                         epochStart: upcomingEpoch.to32()                                                                                                                                                        │
│                     });                                                                                                                                                                                         │
│                 }                                                                                                                                                                                               │
│                 // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired                                                                                                │
│                 // e.g. week 1 + 17 <= 18                                                                                                                                                                       │
│                 else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {                                                                                                                                 │
│                     ckpts.push(                                                                                                                                                                                 │
│                         DelegateeCheckpoint({                                                                                                                                                                   │
│                             votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                            │
│                             epochStart: upcomingEpoch.to32()                                                                                                                                                    │
│                         })                                                                                                                                                                                      │
│                     );                                                                                                                                                                                          │
│                 } else {                                                                                                                                                                                        │
│                     uint256 nextEpoch = upcomingEpoch;                                                                                                                                                          │
│                     uint256 unlocksSinceLatestCkpt = 0;                                                                                                                                                         │
│                     // Should be maximum 18 iterations                                                                                                                                                          │
│                     while (nextEpoch > prevCkpt.epochStart) {                                                                                                                                                   │
│                         unlocksSinceLatestCkpt += delegateeUnlocks[_account];                                                                                                                                   │
│                         nextEpoch -= rewardsDuration;                                                                                                                                                           │
│                     }                                                                                                                                                                                           │
│                     ckpts.push(                                                                                                                                                                                 │
│                         DelegateeCheckpoint({                                                                                                                                                                   │
│                             votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)                                                                                           │
│                                 .to224(),                                                                                                                                                                       │
│                             epochStart: upcomingEpoch.to32()                                                                                                                                                    │
│                         })                                                                                                                                                                                      │
│                     );                                                                                                                                                                                          │
│                 }                                                                                                                                                                                               │
│             } else {                                                                                                                                                                                            │
│                 ckpts.push(                                                                                                                                                                                     │
│                     DelegateeCheckpoint({                                                                                                                                                                       │
│                         votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                                │
│                         epochStart: upcomingEpoch.to32()                                                                                                                                                        │
│                     })                                                                                                                                                                                          │
│                 );                                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             emit DelegateCheckpointed(_account);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {                                                                                                             │
│         require(timestamp <= block.timestamp, "ERC20Votes: block not yet mined");                                                                                                                               │
│         uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);                                                                                                                                    │
│         DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes, epoch);                                                                                                                        │
│         votes = ckpt.votes;                                                                                                                                                                                     │
│         if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {                                                                                                                                            │
│             return 0;                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│         while (epoch > ckpt.epochStart) {                                                                                                                                                                       │
│             votes -= delegateeUnlocks;                                                                                                                                                                          │
│             epoch -= rewardsDuration;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)                                                                                                                        │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (DelegateeCheckpoint memory)                                                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         uint256 high = ckpts.length;                                                                                                                                                                            │
│         uint256 low = 0;                                                                                                                                                                                        │
│         while (low < high) {                                                                                                                                                                                    │
│             uint256 mid = AuraMath.average(low, high);                                                                                                                                                          │
│             if (ckpts.epochStart > epochStart) {                                                                                                                                                                │
│                 high = mid;                                                                                                                                                                                     │
│             } else {                                                                                                                                                                                            │
│                 low = mid + 1;                                                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts;                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external nonReentrant {                                                                                                                                          │
│         require(rewardDistributors, "!authorized");                                                                                                                                                             │
│         require(_rewards > 0, "No reward");                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         RewardData storage rdata = rewardData;                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedCvxCrvRewards);                                                                                                                                                           │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             _notifyReward(cvxCrv, _rewards);                                                                                                                                                                    │
│             queuedCvxCrvRewards = 0;                                                                                                                                                                            │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));                                                                                                              │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rdata.rewardRate * elapsedTime;                                                                                                                                                  │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│         if (queuedRatio < newRewardRatio) {                                                                                                                                                                     │
│             _notifyReward(cvxCrv, _rewards);                                                                                                                                                                    │
│             queuedCvxCrvRewards = 0;                                                                                                                                                                            │
│         } else {                                                                                                                                                                                                │
│             queuedCvxCrvRewards = _rewards;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {                                                                                                          │
│         RewardData storage rdata = rewardData[_rewardsToken];                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             rdata.rewardRate = _reward.div(rewardsDuration).to96();                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);                                                                                                                               │
│             uint256 leftover = remaining.mul(rdata.rewardRate);                                                                                                                                                 │
│             rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rdata.lastUpdateTime = block.timestamp.to32();                                                                                                                                                          │
│         rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardAdded(_rewardsToken, _reward);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {                                                                                                          │
│         RewardData storage rdata = rewardData[_rewardsToken];                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             rdata.rewardRate = _reward.div(rewardsDuration).to96();                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);                                                                                                                               │
│             uint256 leftover = remaining.mul(rdata.rewardRate);                                                                                                                                                 │
│             rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rdata.lastUpdateTime = block.timestamp.to32();                                                                                                                                                          │
│         rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardAdded(_rewardsToken, _reward);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {                                                                                                                 │
│         require(msg.sender == provider, "!auth");                                                                                                                                                               │
│         require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, "!valid");                                                                                                                    │
│         require(pairToken.balanceOf(address(this)) > minPairAmount, "!minLiq");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         for (uint256 i = 0; i < 2; i++) {                                                                                                                                                                       │
│             address asset = address(_request.assets);                                                                                                                                                           │
│             require(asset == address(startToken) || asset == address(pairToken), "!asset");                                                                                                                     │
│                                                                                                                                                                                                                 │
│             IERC20 tkn = IERC20(asset);                                                                                                                                                                         │
│             uint256 bal = tkn.balanceOf(address(this));                                                                                                                                                         │
│             require(bal > 0 && bal == _request.maxAmountsIn, "!bal");                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             tkn.safeApprove(address(bVault), 0);                                                                                                                                                                │
│             tkn.safeApprove(address(bVault), bal);                                                                                                                                                              │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (address pool, ) = bVault.getPool(_poolId);                                                                                                                                                             │
│         uint256 supplyBefore = IERC20(pool).totalSupply();                                                                                                                                                      │
│         require(supplyBefore == 0, "!init");                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         bVault.joinPool(_poolId, address(this), dao, _request);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256 balAfter = IERC20(pool).balanceOf(dao);                                                                                                                                                         │
│         require(balAfter > 0, "!mint");                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LiquidityProvided(_request.maxAmountsIn, balAfter);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {                                                                                                                 │
│         require(msg.sender == provider, "!auth");                                                                                                                                                               │
│         require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, "!valid");                                                                                                                    │
│         require(pairToken.balanceOf(address(this)) > minPairAmount, "!minLiq");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         for (uint256 i = 0; i < 2; i++) {                                                                                                                                                                       │
│             address asset = address(_request.assets);                                                                                                                                                           │
│             require(asset == address(startToken) || asset == address(pairToken), "!asset");                                                                                                                     │
│                                                                                                                                                                                                                 │
│             IERC20 tkn = IERC20(asset);                                                                                                                                                                         │
│             uint256 bal = tkn.balanceOf(address(this));                                                                                                                                                         │
│             require(bal > 0 && bal == _request.maxAmountsIn, "!bal");                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             tkn.safeApprove(address(bVault), 0);                                                                                                                                                                │
│             tkn.safeApprove(address(bVault), bal);                                                                                                                                                              │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (address pool, ) = bVault.getPool(_poolId);                                                                                                                                                             │
│         uint256 supplyBefore = IERC20(pool).totalSupply();                                                                                                                                                      │
│         require(supplyBefore == 0, "!init");                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         bVault.joinPool(_poolId, address(this), dao, _request);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256 balAfter = IERC20(pool).balanceOf(dao);                                                                                                                                                         │
│         require(balAfter > 0, "!mint");                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         emit LiquidityProvided(_request.maxAmountsIn, balAfter);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function rescueToken(address _erc20) external {                                                                                                                                                             │
│         require(msg.sender == provider || msg.sender == dao, "!auth");                                                                                                                                          │
│         IERC20 tkn = IERC20(_erc20);                                                                                                                                                                            │
│         tkn.safeTransfer(dao, tkn.balanceOf(address(this)));                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function addReward(address _token, uint256 _amount) external {                                                                                                                                              │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         _addReward(_token, _amount, latestEpoch);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                   │
│ Code:                                                                                                                                                                                                           │
│     function addReward(address _token, uint256 _amount) external {                                                                                                                                              │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         _addReward(_token, _amount, latestEpoch);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function addRewardToEpoch(                                                                                                                                                                                  │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) external {                                                                                                                                                                                                │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         require(_epoch <= latestEpoch, "Cannot assign to the future");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (_epoch == latestEpoch) {                                                                                                                                                                            │
│             _addReward(_token, _amount, latestEpoch);                                                                                                                                                           │
│         } else {                                                                                                                                                                                                │
│             uint256 len = rewardEpochs[_token].length;                                                                                                                                                          │
│             require(len == 0 || rewardEpochs[_token] < _epoch, "Cannot backdate to this epoch");                                                                                                                │
│                                                                                                                                                                                                                 │
│             _addReward(_token, _amount, _epoch);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                   │
│ Code:                                                                                                                                                                                                           │
│     function addRewardToEpoch(                                                                                                                                                                                  │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) external {                                                                                                                                                                                                │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         require(_epoch <= latestEpoch, "Cannot assign to the future");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (_epoch == latestEpoch) {                                                                                                                                                                            │
│             _addReward(_token, _amount, latestEpoch);                                                                                                                                                           │
│         } else {                                                                                                                                                                                                │
│             uint256 len = rewardEpochs[_token].length;                                                                                                                                                          │
│             require(len == 0 || rewardEpochs[_token] < _epoch, "Cannot backdate to this epoch");                                                                                                                │
│                                                                                                                                                                                                                 │
│             _addReward(_token, _amount, _epoch);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _addReward(                                                                                                                                                                                        │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) internal nonReentrant {                                                                                                                                                                                   │
│         // Pull before reward accrual                                                                                                                                                                           │
│         IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //convert to reward per token                                                                                                                                                                           │
│         uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);                                                                                                                                                 │
│         uint256 rPerT = (_amount * 1e20) / supply;                                                                                                                                                              │
│         rewardData[_token][_epoch] += rPerT;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //add epoch to list                                                                                                                                                                                     │
│         uint256 len = rewardEpochs[_token].length;                                                                                                                                                              │
│         if (len == 0 || rewardEpochs[_token] < _epoch) {                                                                                                                                                        │
│             rewardEpochs[_token].push(_epoch);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //event                                                                                                                                                                                                 │
│         emit RewardAdded(_token, _epoch, _amount);                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _addReward(                                                                                                                                                                                        │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) internal nonReentrant {                                                                                                                                                                                   │
│         // Pull before reward accrual                                                                                                                                                                           │
│         IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //convert to reward per token                                                                                                                                                                           │
│         uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);                                                                                                                                                 │
│         uint256 rPerT = (_amount * 1e20) / supply;                                                                                                                                                              │
│         rewardData[_token][_epoch] += rPerT;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //add epoch to list                                                                                                                                                                                     │
│         uint256 len = rewardEpochs[_token].length;                                                                                                                                                              │
│         if (len == 0 || rewardEpochs[_token] < _epoch) {                                                                                                                                                        │
│             rewardEpochs[_token].push(_epoch);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //event                                                                                                                                                                                                 │
│         emit RewardAdded(_token, _epoch, _amount);                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function addRewardToEpoch(                                                                                                                                                                                  │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) external {                                                                                                                                                                                                │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         require(_epoch <= latestEpoch, "Cannot assign to the future");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (_epoch == latestEpoch) {                                                                                                                                                                            │
│             _addReward(_token, _amount, latestEpoch);                                                                                                                                                           │
│         } else {                                                                                                                                                                                                │
│             uint256 len = rewardEpochs[_token].length;                                                                                                                                                          │
│             require(len == 0 || rewardEpochs[_token] < _epoch, "Cannot backdate to this epoch");                                                                                                                │
│                                                                                                                                                                                                                 │
│             _addReward(_token, _amount, _epoch);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _addReward(                                                                                                                                                                                        │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) internal nonReentrant {                                                                                                                                                                                   │
│         // Pull before reward accrual                                                                                                                                                                           │
│         IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //convert to reward per token                                                                                                                                                                           │
│         uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);                                                                                                                                                 │
│         uint256 rPerT = (_amount * 1e20) / supply;                                                                                                                                                              │
│         rewardData[_token][_epoch] += rPerT;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //add epoch to list                                                                                                                                                                                     │
│         uint256 len = rewardEpochs[_token].length;                                                                                                                                                              │
│         if (len == 0 || rewardEpochs[_token] < _epoch) {                                                                                                                                                        │
│             rewardEpochs[_token].push(_epoch);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //event                                                                                                                                                                                                 │
│         emit RewardAdded(_token, _epoch, _amount);                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function addRewardToEpoch(                                                                                                                                                                                  │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) external {                                                                                                                                                                                                │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         require(_epoch <= latestEpoch, "Cannot assign to the future");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (_epoch == latestEpoch) {                                                                                                                                                                            │
│             _addReward(_token, _amount, latestEpoch);                                                                                                                                                           │
│         } else {                                                                                                                                                                                                │
│             uint256 len = rewardEpochs[_token].length;                                                                                                                                                          │
│             require(len == 0 || rewardEpochs[_token] < _epoch, "Cannot backdate to this epoch");                                                                                                                │
│                                                                                                                                                                                                                 │
│             _addReward(_token, _amount, _epoch);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _addReward(                                                                                                                                                                                        │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) internal nonReentrant {                                                                                                                                                                                   │
│         // Pull before reward accrual                                                                                                                                                                           │
│         IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //convert to reward per token                                                                                                                                                                           │
│         uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);                                                                                                                                                 │
│         uint256 rPerT = (_amount * 1e20) / supply;                                                                                                                                                              │
│         rewardData[_token][_epoch] += rPerT;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //add epoch to list                                                                                                                                                                                     │
│         uint256 len = rewardEpochs[_token].length;                                                                                                                                                              │
│         if (len == 0 || rewardEpochs[_token] < _epoch) {                                                                                                                                                        │
│             rewardEpochs[_token].push(_epoch);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //event                                                                                                                                                                                                 │
│         emit RewardAdded(_token, _epoch, _amount);                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function addReward(address _token, uint256 _amount) external {                                                                                                                                              │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         _addReward(_token, _amount, latestEpoch);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function _addReward(                                                                                                                                                                                        │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) internal nonReentrant {                                                                                                                                                                                   │
│         // Pull before reward accrual                                                                                                                                                                           │
│         IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //convert to reward per token                                                                                                                                                                           │
│         uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);                                                                                                                                                 │
│         uint256 rPerT = (_amount * 1e20) / supply;                                                                                                                                                              │
│         rewardData[_token][_epoch] += rPerT;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //add epoch to list                                                                                                                                                                                     │
│         uint256 len = rewardEpochs[_token].length;                                                                                                                                                              │
│         if (len == 0 || rewardEpochs[_token] < _epoch) {                                                                                                                                                        │
│             rewardEpochs[_token].push(_epoch);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //event                                                                                                                                                                                                 │
│         emit RewardAdded(_token, _epoch, _amount);                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function addReward(address _token, uint256 _amount) external {                                                                                                                                              │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         _addReward(_token, _amount, latestEpoch);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function _addReward(                                                                                                                                                                                        │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) internal nonReentrant {                                                                                                                                                                                   │
│         // Pull before reward accrual                                                                                                                                                                           │
│         IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //convert to reward per token                                                                                                                                                                           │
│         uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);                                                                                                                                                 │
│         uint256 rPerT = (_amount * 1e20) / supply;                                                                                                                                                              │
│         rewardData[_token][_epoch] += rPerT;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         //add epoch to list                                                                                                                                                                                     │
│         uint256 len = rewardEpochs[_token].length;                                                                                                                                                              │
│         if (len == 0 || rewardEpochs[_token] < _epoch) {                                                                                                                                                        │
│             rewardEpochs[_token].push(_epoch);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //event                                                                                                                                                                                                 │
│         emit RewardAdded(_token, _epoch, _amount);                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function _getReward(                                                                                                                                                                                        │
│         address _account,                                                                                                                                                                                       │
│         address _token,                                                                                                                                                                                         │
│         uint256 _startIndex                                                                                                                                                                                     │
│     ) public {                                                                                                                                                                                                  │
│         //get claimable tokens                                                                                                                                                                                  │
│         (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (claimableTokens > 0) {                                                                                                                                                                              │
│             //set claim checkpoint                                                                                                                                                                              │
│             userClaims[_token][_account] = index;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send                                                                                                                                                                                              │
│             IERC20(_token).safeTransfer(_account, claimableTokens);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             //event                                                                                                                                                                                             │
│             emit RewardPaid(_account, _token, claimableTokens, index);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                   │
│ Code:                                                                                                                                                                                                           │
│     function _getReward(                                                                                                                                                                                        │
│         address _account,                                                                                                                                                                                       │
│         address _token,                                                                                                                                                                                         │
│         uint256 _startIndex                                                                                                                                                                                     │
│     ) public {                                                                                                                                                                                                  │
│         //get claimable tokens                                                                                                                                                                                  │
│         (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (claimableTokens > 0) {                                                                                                                                                                              │
│             //set claim checkpoint                                                                                                                                                                              │
│             userClaims[_token][_account] = index;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send                                                                                                                                                                                              │
│             IERC20(_token).safeTransfer(_account, claimableTokens);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             //event                                                                                                                                                                                             │
│             emit RewardPaid(_account, _token, claimableTokens, index);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function forfeitRewards(address _token, uint256 _index) external {                                                                                                                                          │
│         require(_index > 0 && _index < rewardEpochs[_token].length - 1, "!past");                                                                                                                               │
│         require(_index >= userClaims[_token], "already claimed");                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         //set claim checkpoint. next claim starts from index+1                                                                                                                                                  │
│         userClaims[_token] = _index + 1;                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit RewardForfeited(msg.sender, _token, _index);                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _minOut,                                                                                                                                                                                        │
│         bool _lock,                                                                                                                                                                                             │
│         address _stakeAddress                                                                                                                                                                                   │
│     ) external {                                                                                                                                                                                                │
│         _investBalToPool(_amount, _minOut);                                                                                                                                                                     │
│         uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));                                                                                                                              │
│         ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(address _token, address _gauge) external returns(bool){                                                                                                                                    │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         if(protectedTokens[_token] == false){                                                                                                                                                                   │
│             protectedTokens[_token] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         if(protectedTokens[_gauge] == false){                                                                                                                                                                   │
│             protectedTokens[_gauge] = true;                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│         uint256 balance = IERC20(_token).balanceOf(address(this));                                                                                                                                              │
│         if (balance > 0) {                                                                                                                                                                                      │
│             IERC20(_token).safeApprove(_gauge, 0);                                                                                                                                                              │
│             IERC20(_token).safeApprove(_gauge, balance);                                                                                                                                                        │
│             ICurveGauge(_gauge).deposit(balance);                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _minOut,                                                                                                                                                                                        │
│         bool _lock,                                                                                                                                                                                             │
│         address _stakeAddress                                                                                                                                                                                   │
│     ) external {                                                                                                                                                                                                │
│         _investBalToPool(_amount, _minOut);                                                                                                                                                                     │
│         uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));                                                                                                                              │
│         ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distribute() external {                                                                                                                                                                            │
│         // If keeper enabled, require                                                                                                                                                                           │
│         if (keeper != address(0)) {                                                                                                                                                                             │
│             require(msg.sender == keeper, "!auth");                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //convert crv to cvxCrv                                                                                                                                                                                 │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             uint256 minOut = ICrvDepositorWrapper(crvDepositorWrapper).getMinOut(crvBal, outputBps);                                                                                                            │
│             ICrvDepositorWrapper(crvDepositorWrapper).deposit(crvBal, minOut, true, address(0));                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //distribute cvxcrv                                                                                                                                                                                     │
│         uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBal > 0) {                                                                                                                                                                                    │
│             uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);                                                                                                                            │
│             cvxCrvBal = cvxCrvBal.sub(incentiveAmount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             IERC20(cvxCrv).safeTransfer(msg.sender, incentiveAmount);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             IAuraLocker(rewards).queueNewRewards(cvxCrvBal);                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(cvxCrv, cvxCrvBal);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _minOut,                                                                                                                                                                                        │
│         bool _lock,                                                                                                                                                                                             │
│         address _stakeAddress                                                                                                                                                                                   │
│     ) external {                                                                                                                                                                                                │
│         _investBalToPool(_amount, _minOut);                                                                                                                                                                     │
│         uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));                                                                                                                              │
│         ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {                                                                                                 │
│         // Transfer "asset" (crvLP) from sender                                                                                                                                                                 │
│         IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Convert crvLP to cvxLP through normal booster deposit process, but don't stake                                                                                                                       │
│         uint256 balBefore = stakingToken.balanceOf(address(this));                                                                                                                                              │
│         IDeposit(operator).deposit(pid, assets, false);                                                                                                                                                         │
│         uint256 balAfter = stakingToken.balanceOf(address(this));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         require(balAfter - balBefore >= assets, "!deposit");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // Perform stake manually, now that the funds have been received                                                                                                                                        │
│         _processStake(assets, receiver);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         emit Deposit(msg.sender, receiver, assets, assets);                                                                                                                                                     │
│         emit Staked(receiver, assets);                                                                                                                                                                          │
│         return assets;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _minOut,                                                                                                                                                                                        │
│         bool _lock,                                                                                                                                                                                             │
│         address _stakeAddress                                                                                                                                                                                   │
│     ) external {                                                                                                                                                                                                │
│         _investBalToPool(_amount, _minOut);                                                                                                                                                                     │
│         uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));                                                                                                                              │
│         ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){                                                                                                                          │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         require(pool.shutdown == false, "pool is closed");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //send to proxy to stake                                                                                                                                                                                │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         //stake                                                                                                                                                                                                 │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│         require(gauge != address(0),"!gauge setting");                                                                                                                                                          │
│         IStaker(staker).deposit(lptoken,gauge);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when depositing, stash them in a seperate contract until next claim                                                                                                         │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0)){                                                                                                                                                                                │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address token = pool.token;                                                                                                                                                                             │
│         if(_stake){                                                                                                                                                                                             │
│             //mint here and send to rewards on user behalf                                                                                                                                                      │
│             ITokenMinter(token).mint(address(this),_amount);                                                                                                                                                    │
│             address rewardContract = pool.crvRewards;                                                                                                                                                           │
│             IERC20(token).safeApprove(rewardContract,0);                                                                                                                                                        │
│             IERC20(token).safeApprove(rewardContract,_amount);                                                                                                                                                  │
│             IRewards(rewardContract).stakeFor(msg.sender,_amount);                                                                                                                                              │
│         }else{                                                                                                                                                                                                  │
│             //add user balance directly                                                                                                                                                                         │
│             ITokenMinter(token).mint(msg.sender,_amount);                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Deposited(msg.sender, _pid, _amount);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _minOut,                                                                                                                                                                                        │
│         bool _lock,                                                                                                                                                                                             │
│         address _stakeAddress                                                                                                                                                                                   │
│     ) external {                                                                                                                                                                                                │
│         _investBalToPool(_amount, _minOut);                                                                                                                                                                     │
│         uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));                                                                                                                              │
│         ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositAll(uint256 _pid, bool _stake) external returns(bool){                                                                                                                                      │
│         address lptoken = poolInfo[_pid].lptoken;                                                                                                                                                               │
│         uint256 balance = IERC20(lptoken).balanceOf(msg.sender);                                                                                                                                                │
│         deposit(_pid,balance,_stake);                                                                                                                                                                           │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _minOut,                                                                                                                                                                                        │
│         bool _lock,                                                                                                                                                                                             │
│         address _stakeAddress                                                                                                                                                                                   │
│     ) external {                                                                                                                                                                                                │
│         _investBalToPool(_amount, _minOut);                                                                                                                                                                     │
│         uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));                                                                                                                              │
│         ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _claimExtras( // solhint-disable-line                                                                                                                                                              │
│         uint256 depositCrvMaxAmount,                                                                                                                                                                            │
│         uint256 minAmountOut,                                                                                                                                                                                   │
│         uint256 depositCvxMaxAmount,                                                                                                                                                                            │
│         uint256 removeCrvBalance,                                                                                                                                                                               │
│         uint256 removeCvxBalance,                                                                                                                                                                               │
│         uint256 options                                                                                                                                                                                         │
│     ) internal {                                                                                                                                                                                                │
│         //claim from cvxCrv rewards                                                                                                                                                                             │
│         if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {                                                                                                                                              │
│             IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //claim from locker                                                                                                                                                                                     │
│         if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {                                                                                                                                           │
│             IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //reset remove balances if we want to also stake/lock funds already in our wallet                                                                                                                       │
│         if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {                                                                                                                                        │
│             removeCrvBalance = 0;                                                                                                                                                                               │
│             removeCvxBalance = 0;                                                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //lock upto given amount of crv and stake                                                                                                                                                               │
│         if (depositCrvMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);                                                                                                                       │
│             crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             if (crvBalance > 0) {                                                                                                                                                                               │
│                 //pull crv                                                                                                                                                                                      │
│                 IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);                                                                                                                            │
│                 //deposit                                                                                                                                                                                       │
│                 ICrvDepositorWrapper(crvDepositWrapper).deposit(                                                                                                                                                │
│                     crvBalance,                                                                                                                                                                                 │
│                     minAmountOut,                                                                                                                                                                               │
│                     _checkOption(options, uint256(Options.LockCrvDeposit)),                                                                                                                                     │
│                     address(0)                                                                                                                                                                                  │
│                 );                                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                │
│                 //stake for msg.sender                                                                                                                                                                          │
│                 IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //stake up to given amount of cvx                                                                                                                                                                       │
│         if (depositCvxMaxAmount > 0) {                                                                                                                                                                          │
│             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);                                                                                                                       │
│             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);                                                                                                                                         │
│             if (cvxBalance > 0) {                                                                                                                                                                               │
│                 //pull cvx                                                                                                                                                                                      │
│                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                                                                                                                            │
│                 if (_checkOption(options, uint256(Options.LockCvx))) {                                                                                                                                          │
│                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                                                                                                                                           │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function deposit(                                                                                                                                                                                           │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _minOut,                                                                                                                                                                                        │
│         bool _lock,                                                                                                                                                                                             │
│         address _stakeAddress                                                                                                                                                                                   │
│     ) external {                                                                                                                                                                                                │
│         _investBalToPool(_amount, _minOut);                                                                                                                                                                     │
│         uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));                                                                                                                              │
│         ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawExpired() external {                                                                                                                                                                       │
│         require(msg.sender == dao, "!auth");                                                                                                                                                                    │
│         require(block.timestamp > expiryTime, "!expired");                                                                                                                                                      │
│         uint256 amt = aura.balanceOf(address(this));                                                                                                                                                            │
│         aura.safeTransfer(dao, amt);                                                                                                                                                                            │
│         emit ExpiredWithdrawn(amt);                                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimFees(IERC20 _token) external {                                                                                                                                                                │
│         uint256 tokenTime = feeDistro.getTokenTimeCursor(_token);                                                                                                                                               │
│         require(tokenTime > lastTokenTimes, "not time yet");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         uint256 bal = IERC20(_token).balanceOf(voterProxy);                                                                                                                                                     │
│         feeDistro.claimToken(voterProxy, _token);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Loop through until something is transferred                                                                                                                                                          │
│         while (IERC20(_token).balanceOf(voterProxy) <= bal) {                                                                                                                                                   │
│             feeDistro.claimToken(voterProxy, _token);                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         booster.earmarkFees(address(_token));                                                                                                                                                                   │
│         lastTokenTimes = tokenTime;                                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function earmarkFees(address _feeToken) external returns(bool){                                                                                                                                             │
│         require(!isShutdown,"shutdown");                                                                                                                                                                        │
│         FeeDistro memory feeDistro = feeTokens[_feeToken];                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         require(feeDistro.active, "Inactive distro");                                                                                                                                                           │
│         require(!gaugeMap[_feeToken], "Invalid token");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         //claim fee rewards                                                                                                                                                                                     │
│         uint256 tokenBalanceBefore = IERC20(_feeToken).balanceOf(address(this));                                                                                                                                │
│         IStaker(staker).claimFees(feeDistro.distro, _feeToken);                                                                                                                                                 │
│         uint256 tokenBalanceAfter = IERC20(_feeToken).balanceOf(address(this));                                                                                                                                 │
│         uint256 feesClaimed = tokenBalanceAfter.sub(tokenBalanceBefore);                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         //send fee rewards to reward contract                                                                                                                                                                   │
│         IERC20(_feeToken).safeTransfer(feeDistro.rewards, feesClaimed);                                                                                                                                         │
│         IRewards(feeDistro.rewards).queueNewRewards(feesClaimed);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function claimFees(IERC20 _token) external {                                                                                                                                                                │
│         uint256 tokenTime = feeDistro.getTokenTimeCursor(_token);                                                                                                                                               │
│         require(tokenTime > lastTokenTimes, "not time yet");                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         uint256 bal = IERC20(_token).balanceOf(voterProxy);                                                                                                                                                     │
│         feeDistro.claimToken(voterProxy, _token);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Loop through until something is transferred                                                                                                                                                          │
│         while (IERC20(_token).balanceOf(voterProxy) <= bal) {                                                                                                                                                   │
│             feeDistro.claimToken(voterProxy, _token);                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         booster.earmarkFees(address(_token));                                                                                                                                                                   │
│         lastTokenTimes = tokenTime;                                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function rescueToken(address _token, address _to) external {                                                                                                                                                │
│         require(msg.sender == owner, "!auth");                                                                                                                                                                  │
│         require(_token != crv && _token != cvx && _token != cvxCrv, "not allowed");                                                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256 bal = IERC20(_token).balanceOf(address(this));                                                                                                                                                  │
│         IERC20(_token).safeTransfer(_to, bal);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distribute() external {                                                                                                                                                                            │
│         // If keeper enabled, require                                                                                                                                                                           │
│         if (keeper != address(0)) {                                                                                                                                                                             │
│             require(msg.sender == keeper, "!auth");                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //convert crv to cvxCrv                                                                                                                                                                                 │
│         uint256 crvBal = IERC20(crv).balanceOf(address(this));                                                                                                                                                  │
│         if (crvBal > 0) {                                                                                                                                                                                       │
│             uint256 minOut = ICrvDepositorWrapper(crvDepositorWrapper).getMinOut(crvBal, outputBps);                                                                                                            │
│             ICrvDepositorWrapper(crvDepositorWrapper).deposit(crvBal, minOut, true, address(0));                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //distribute cvxcrv                                                                                                                                                                                     │
│         uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         if (cvxCrvBal > 0) {                                                                                                                                                                                    │
│             uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);                                                                                                                            │
│             cvxCrvBal = cvxCrvBal.sub(incentiveAmount);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             IERC20(cvxCrv).safeTransfer(msg.sender, incentiveAmount);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             IAuraLocker(rewards).queueNewRewards(cvxCrvBal);                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(cvxCrv, cvxCrvBal);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function distributeOther(IERC20 _token) external {                                                                                                                                                          │
│         require(address(_token) != crv && address(_token) != cvxCrv, "not allowed");                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 bal = _token.balanceOf(address(this));                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (bal > 0) {                                                                                                                                                                                          │
│             uint256 incentiveAmount = bal.mul(callIncentive).div(denominator);                                                                                                                                  │
│             bal = bal.sub(incentiveAmount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             //send incentives                                                                                                                                                                                   │
│             _token.safeTransfer(msg.sender, incentiveAmount);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             //approve                                                                                                                                                                                           │
│             _token.safeApprove(rewards, 0);                                                                                                                                                                     │
│             _token.safeApprove(rewards, type(uint256).max);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             //update rewards                                                                                                                                                                                    │
│             IAuraLocker(rewards).notifyRewardAmount(address(_token), bal);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│             emit RewardsDistributed(address(_token), bal);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw() external {                                                                                                                                                                              │
│         require(lockTimes < block.timestamp, "!unlocked");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         lockAmounts = 0;                                                                                                                                                                                        │
│         lockTimes = 0;                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         IERC20(token).transfer(msg.sender, amount);                                                                                                                                                             │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {                                                                                                                    │
│         PoolInfo storage pool = poolInfo[_pid];                                                                                                                                                                 │
│         address lptoken = pool.lptoken;                                                                                                                                                                         │
│         address gauge = pool.gauge;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //remove lp balance                                                                                                                                                                                     │
│         address token = pool.token;                                                                                                                                                                             │
│         ITokenMinter(token).burn(_from,_amount);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         //pull from gauge if not shutdown                                                                                                                                                                       │
│         // if shutdown tokens will be in this contract                                                                                                                                                          │
│         if (!pool.shutdown) {                                                                                                                                                                                   │
│             IStaker(staker).withdraw(lptoken,gauge, _amount);                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim                                                                                                        │
│         //do not call if shutdown since stashes wont have access                                                                                                                                                │
│         address stash = pool.stash;                                                                                                                                                                             │
│         if(stash != address(0) && !isShutdown && !pool.shutdown){                                                                                                                                               │
│             IStash(stash).stashRewards();                                                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //return lp tokens                                                                                                                                                                                      │
│         IERC20(lptoken).safeTransfer(_to, _amount);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         emit Withdrawn(_to, _pid, _amount);                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│     function withdraw() external {                                                                                                                                                                              │
│         require(lockTimes < block.timestamp, "!unlocked");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         lockAmounts = 0;                                                                                                                                                                                        │
│         lockTimes = 0;                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         IERC20(token).transfer(msg.sender, amount);                                                                                                                                                             │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(address _token, address _gauge) external returns(bool){                                                                                                                                │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));                                                                                                                    │
│         withdraw(_token, _gauge, amount);                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw() external {                                                                                                                                                                              │
│         require(lockTimes < block.timestamp, "!unlocked");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         lockAmounts = 0;                                                                                                                                                                                        │
│         lockTimes = 0;                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         IERC20(token).transfer(msg.sender, amount);                                                                                                                                                             │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(uint256 amount, bool claim)                                                                                                                                                               │
│         public                                                                                                                                                                                                  │
│         updateReward(msg.sender)                                                                                                                                                                                │
│         returns(bool)                                                                                                                                                                                           │
│     {                                                                                                                                                                                                           │
│         require(amount > 0, 'RewardPool : Cannot withdraw 0');                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(msg.sender, amount);                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         stakingToken.safeTransfer(msg.sender, amount);                                                                                                                                                          │
│         emit Withdrawn(msg.sender, amount);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(claim){                                                                                                                                                                                              │
│             getReward(msg.sender,true);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw() external {                                                                                                                                                                              │
│         require(lockTimes < block.timestamp, "!unlocked");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         lockAmounts = 0;                                                                                                                                                                                        │
│         lockTimes = 0;                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         IERC20(token).transfer(msg.sender, amount);                                                                                                                                                             │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){                                                                                    │
│         //also withdraw from linked rewards                                                                                                                                                                     │
│         for(uint i=0; i < extraRewards.length; i++){                                                                                                                                                            │
│             IRewards(extraRewards).withdraw(from, amount);                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply.sub(amount);                                                                                                                                                                │
│         _balances = _balances.sub(amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         //tell operator to withdraw from here directly to user                                                                                                                                                  │
│         IDeposit(operator).withdrawTo(pid,amount,receiver);                                                                                                                                                     │
│         emit Withdrawn(from, amount);                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw() external {                                                                                                                                                                              │
│         require(lockTimes < block.timestamp, "!unlocked");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         lockAmounts = 0;                                                                                                                                                                                        │
│         lockTimes = 0;                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         IERC20(token).transfer(msg.sender, amount);                                                                                                                                                             │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawAll(uint256 _pid) public returns(bool){                                                                                                                                                    │
│         address token = poolInfo[_pid].token;                                                                                                                                                                   │
│         uint256 userBal = IERC20(token).balanceOf(msg.sender);                                                                                                                                                  │
│         withdraw(_pid, userBal);                                                                                                                                                                                │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw() external {                                                                                                                                                                              │
│         require(lockTimes < block.timestamp, "!unlocked");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         lockAmounts = 0;                                                                                                                                                                                        │
│         lockTimes = 0;                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         IERC20(token).transfer(msg.sender, amount);                                                                                                                                                             │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function release() external returns(bool){                                                                                                                                                                  │
│         require(msg.sender == depositor, "!auth");                                                                                                                                                              │
│         ICurveVoteEscrow(escrow).withdraw();                                                                                                                                                                    │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function withdraw() external {                                                                                                                                                                              │
│         require(lockTimes < block.timestamp, "!unlocked");                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         lockAmounts = 0;                                                                                                                                                                                        │
│         lockTimes = 0;                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         IERC20(token).transfer(msg.sender, amount);                                                                                                                                                             │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claim_rewards() external {                                                                                                                                                                         │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         for (uint256 i = 0; i < reward_tokens.length; i++) {                                                                                                                                                    │
│             IERC20(reward_tokens).transfer(msg.sender, amount);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function claimRewards(address _gauge) external returns(bool){                                                                                                                                               │
│         require(msg.sender == operator, "!auth");                                                                                                                                                               │
│         ICurveGauge(_gauge).claim_rewards();                                                                                                                                                                    │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function claim_rewards() external {                                                                                                                                                                         │
│         uint256 amount = balanceOf(msg.sender);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         for (uint256 i = 0; i < reward_tokens.length; i++) {                                                                                                                                                    │
│             IERC20(reward_tokens).transfer(msg.sender, amount);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _claimToken(address user, IERC20 token) internal returns (uint256) {                                                                                                                               │
│         uint256 rate = tokenRates;                                                                                                                                                                              │
│         if (rate > 0) {                                                                                                                                                                                         │
│             token.transfer(user, rate);                                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         return rate;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function claimTokens(address user, IERC20[] calldata tokens) external returns (uint256[] memory) {                                                                                                          │
│         uint256[] memory rates = new uint256[](tokens.length);                                                                                                                                                  │
│         for (uint256 i = 0; i < tokens.length; i++) {                                                                                                                                                           │
│             rates = _claimToken(user, tokens);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external{                                                                                                                                                        │
│         require(msg.sender == operator, "!authorized");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedRewards);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));                                                                                                                                  │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rewardRate * elapsedTime;                                                                                                                                                        │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│         if(queuedRatio < newRewardRatio){                                                                                                                                                                       │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│         }else{                                                                                                                                                                                                  │
│             queuedRewards = _rewards;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));`.                                                                        │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external{                                                                                                                                                        │
│         require(msg.sender == operator, "!authorized");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedRewards);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│             return;                                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));                                                                                                                                  │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rewardRate * elapsedTime;                                                                                                                                                        │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│         if(queuedRatio < newRewardRatio){                                                                                                                                                                       │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│         }else{                                                                                                                                                                                                  │
│             queuedRewards = _rewards;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward is `uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));`.                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                                     order_first_b                                     
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                                                    ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                                                                       │
│ arg[1]   │ [uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));] │
└──────────┴──────────────────────────────────────────────────────────────────────────┘
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(uint256 reward)                                                                                                                                                                 │
│         internal                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         historicalRewards = historicalRewards.add(reward);                                                                                                                                                      │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = periodFinish.sub(block.timestamp);                                                                                                                                              │
│             uint256 leftover = remaining.mul(rewardRate);                                                                                                                                                       │
│             reward = reward.add(leftover);                                                                                                                                                                      │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         currentRewards = reward;                                                                                                                                                                                │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│         emit RewardAdded(reward);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `updateReward(address(0))`.                                                                                                                      │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(uint256 reward)                                                                                                                                                                 │
│         internal                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         historicalRewards = historicalRewards.add(reward);                                                                                                                                                      │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = periodFinish.sub(block.timestamp);                                                                                                                                              │
│             uint256 leftover = remaining.mul(rewardRate);                                                                                                                                                       │
│             reward = reward.add(leftover);                                                                                                                                                                      │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         currentRewards = reward;                                                                                                                                                                                │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│         emit RewardAdded(reward);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `currentRewards = reward;`                                                                                                                                                                                      │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
              order_first_b              
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                      ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ [currentRewards = reward;] │
│ arg[1]   │ [updateReward(address(0))] │
└──────────┴────────────────────────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "cvxReward": "Holds the value of total minted share or amount"                                                                                                                                          │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "lpSupply": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "cvxReward": "Holds the value of the deposit/mint/add amount"                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:07] INFO     static_check: first_deposit_check: VariableA: cvxReward; VariableB: lpSupply; VariableC: cvxReward                                                                 static_check.py:128
  first_deposit_check   
┏━━━━━━━━━━┳━━━━━━━━━━━┓
┃ Argument ┃ Value     ┃
┡━━━━━━━━━━╇━━━━━━━━━━━┩
│ arg[0]   │ lpSupply  │
│ arg[1]   │ cvxReward │
│ arg[2]   │ cvxReward │
└──────────┴───────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "pending": "Value of total minted share or amount"                                                                                                                                                      │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "pool.accCvxPerShare": "Total supply/liquidity used in conditional branch to determine if supply/liquidity is 0"                                                                                        │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_amount": "Value of the deposit/mint/add amount"                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:08] INFO     static_check: first_deposit_check: VariableA: pending; VariableB: pool.accCvxPerShare; VariableC: _amount                                                          static_check.py:128
       first_deposit_check        
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value               ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ pool.accCvxPerShare │
│ arg[1]   │ _amount             │
│ arg[2]   │ pending             │
└──────────┴─────────────────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of total minted share or amount"                                                                                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_totalSupply": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                         │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:09] INFO     static_check: first_deposit_check: VariableA: _amount; VariableB: _totalSupply; VariableC: _amount                                                                 static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ _totalSupply │
│ arg[1]   │ _amount      │
│ arg[2]   │ _amount      │
└──────────┴──────────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of total minted share or amount"                                                                                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "stakingToken": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                         │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:10] INFO     static_check: first_deposit_check: VariableA: _amount; VariableB: stakingToken; VariableC: _amount                                                                 static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ stakingToken │
│ arg[1]   │ _amount      │
│ arg[2]   │ _amount      │
└──────────┴──────────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "assets": "Holds the value of total minted share or amount"                                                                                                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "stakingToken": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                         │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "assets": "Holds the value of the deposit/mint/add amount"                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:11] INFO     static_check: first_deposit_check: VariableA: assets; VariableB: stakingToken; VariableC: assets                                                                   static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ stakingToken │
│ arg[1]   │ assets       │
│ arg[2]   │ assets       │
└──────────┴──────────────┘
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external returns(bool){                                                                                                                                          │
│         require(msg.sender == operator, "!authorized");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedRewards);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│             return true;                                                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));                                                                                                                                  │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rewardRate * elapsedTime;                                                                                                                                                        │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);                                                                                                                                         │
│         if(queuedRatio < newRewardRatio){                                                                                                                                                                       │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│         }else{                                                                                                                                                                                                  │
│             queuedRewards = _rewards;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));`.                                                                        │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function queueNewRewards(uint256 _rewards) external returns(bool){                                                                                                                                          │
│         require(msg.sender == operator, "!authorized");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         _rewards = _rewards.add(queuedRewards);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│             return true;                                                                                                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         //et = now - (finish-duration)                                                                                                                                                                          │
│         uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));                                                                                                                                  │
│         //current at now: rewardRate * elapsedTime                                                                                                                                                              │
│         uint256 currentAtNow = rewardRate * elapsedTime;                                                                                                                                                        │
│         uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);                                                                                                                                         │
│         if(queuedRatio < newRewardRatio){                                                                                                                                                                       │
│             notifyRewardAmount(_rewards);                                                                                                                                                                       │
│             queuedRewards = 0;                                                                                                                                                                                  │
│         }else{                                                                                                                                                                                                  │
│             queuedRewards = _rewards;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward is `uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));`.                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                                     order_first_b                                     
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                                                    ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                                                                       │
│ arg[1]   │ [uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));] │
└──────────┴──────────────────────────────────────────────────────────────────────────┘
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(uint256 reward)                                                                                                                                                                 │
│         internal                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         historicalRewards = historicalRewards.add(reward);                                                                                                                                                      │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = periodFinish.sub(block.timestamp);                                                                                                                                              │
│             uint256 leftover = remaining.mul(rewardRate);                                                                                                                                                       │
│             reward = reward.add(leftover);                                                                                                                                                                      │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         currentRewards = reward;                                                                                                                                                                                │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│         emit RewardAdded(reward);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `updateReward(address(0))`                                                                                                                                                                                      │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function notifyRewardAmount(uint256 reward)                                                                                                                                                                 │
│         internal                                                                                                                                                                                                │
│         updateReward(address(0))                                                                                                                                                                                │
│     {                                                                                                                                                                                                           │
│         historicalRewards = historicalRewards.add(reward);                                                                                                                                                      │
│         if (block.timestamp >= periodFinish) {                                                                                                                                                                  │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = periodFinish.sub(block.timestamp);                                                                                                                                              │
│             uint256 leftover = remaining.mul(rewardRate);                                                                                                                                                       │
│             reward = reward.add(leftover);                                                                                                                                                                      │
│             rewardRate = reward.div(duration);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         currentRewards = reward;                                                                                                                                                                                │
│         lastUpdateTime = block.timestamp;                                                                                                                                                                       │
│         periodFinish = block.timestamp.add(duration);                                                                                                                                                           │
│         emit RewardAdded(reward);                                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward is `currentRewards = reward;`.                                                                                       │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
              order_first_b              
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                      ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ [currentRewards = reward;] │
│ arg[1]   │ [updateReward(address(0))] │
└──────────┴────────────────────────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_totalSupply": "Holds the value of total minted share or amount"                                                                                                                                       │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_totalSupply": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                         │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:16] INFO     static_check: first_deposit_check: VariableA: _totalSupply; VariableB: _totalSupply; VariableC: _amount                                                            static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ _totalSupply │
│ arg[1]   │ _amount      │
│ arg[2]   │ _totalSupply │
└──────────┴──────────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balance": "Holds the value of total minted share or amount"                                                                                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "balance": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                              │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "balance": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:17] INFO     static_check: first_deposit_check: VariableA: balance; VariableB: balance; VariableC: balance                                                                      static_check.py:128
 first_deposit_check  
┏━━━━━━━━━━┳━━━━━━━━━┓
┃ Argument ┃ Value   ┃
┡━━━━━━━━━━╇━━━━━━━━━┩
│ arg[0]   │ balance │
│ arg[1]   │ balance │
│ arg[2]   │ balance │
└──────────┴─────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balance": "Holds the value of total minted share or amount"                                                                                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "stakingToken": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                         │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "balance": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:18] INFO     static_check: first_deposit_check: VariableA: balance; VariableB: stakingToken; VariableC: balance                                                                 static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ stakingToken │
│ arg[1]   │ balance      │
│ arg[2]   │ balance      │
└──────────┴──────────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of total minted share or amount"                                                                                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_totalSupply": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                         │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:19] INFO     static_check: first_deposit_check: VariableA: _amount; VariableB: _totalSupply; VariableC: _amount                                                                 static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ _totalSupply │
│ arg[1]   │ _amount      │
│ arg[2]   │ _amount      │
└──────────┴──────────────┘
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of total minted share or amount"                                                                                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_totalSupply": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                         │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:20] INFO     static_check: first_deposit_check: VariableA: _amount; VariableB: _totalSupply; VariableC: _amount                                                                 static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ _totalSupply │
│ arg[1]   │ _amount      │
│ arg[2]   │ _amount      │
└──────────┴──────────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────── Response ─────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                                         │
│     "VariableA": {                                                                                                                                                                                                        │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                                       │
│     },                                                                                                                                                                                                                    │
│     "VariableB": {                                                                                                                                                                                                        │
│         "pool.shutdown": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                                  │
│     },                                                                                                                                                                                                                    │
│     "VariableC": {                                                                                                                                                                                                        │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                                       │
│     }                                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                                         │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:21] INFO     static_check: first_deposit_check: VariableA: _amount; VariableB: pool.shutdown; VariableC: _amount                                                                          static_check.py:128
    first_deposit_check     
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value         ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━┩
│ arg[0]   │ pool.shutdown │
│ arg[1]   │ _amount       │
│ arg[2]   │ _amount       │
└──────────┴───────────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────── Response ─────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                                         │
│     "VariableA": {                                                                                                                                                                                                        │
│         "_amount": "Holds the value of total minted share or amount"                                                                                                                                                      │
│     },                                                                                                                                                                                                                    │
│     "VariableB": {                                                                                                                                                                                                        │
│         "totalSupply()": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                                  │
│     },                                                                                                                                                                                                                    │
│     "VariableC": {                                                                                                                                                                                                        │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                                       │
│     }                                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                                         │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:22] INFO     static_check: first_deposit_check: VariableA: _amount; VariableB: totalSupply(); VariableC: _amount                                                                          static_check.py:128
    first_deposit_check     
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value         ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━┩
│ arg[0]   │ totalSupply() │
│ arg[1]   │ _amount       │
│ arg[2]   │ _amount       │
└──────────┴───────────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────── Response ─────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                                         │
│     "VariableA": {                                                                                                                                                                                                        │
│         "emissionsMinted": "Holds the value of total minted share or amount"                                                                                                                                              │
│     },                                                                                                                                                                                                                    │
│     "VariableB": {                                                                                                                                                                                                        │
│         "totalSupply()": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                                  │
│     },                                                                                                                                                                                                                    │
│     "VariableC": {                                                                                                                                                                                                        │
│         "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                                        │
│     }                                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                                         │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:24] INFO     static_check: first_deposit_check: VariableA: emissionsMinted; VariableB: totalSupply(); VariableC: amount                                                                   static_check.py:128
     first_deposit_check      
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value           ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ totalSupply()   │
│ arg[1]   │ amount          │
│ arg[2]   │ emissionsMinted │
└──────────┴─────────────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────── Response ─────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                                         │
│     "VariableA": {                                                                                                                                                                                                        │
│         "_amount": "Value of the deposit/mint/add amount"                                                                                                                                                                 │
│     },                                                                                                                                                                                                                    │
│     "VariableB": {                                                                                                                                                                                                        │
│         "pool.lptoken": "Holds the total supply/liquidity and used to determine if supply/liquidity is 0"                                                                                                                 │
│     },                                                                                                                                                                                                                    │
│     "VariableC": {                                                                                                                                                                                                        │
│         "_amount": "Value of the deposit/mint/add amount"                                                                                                                                                                 │
│     }                                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                                         │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:25] INFO     static_check: first_deposit_check: VariableA: _amount; VariableB: pool.lptoken; VariableC: _amount                                                                           static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ pool.lptoken │
│ arg[1]   │ _amount      │
│ arg[2]   │ _amount      │
└──────────┴──────────────┘
╭──────────────────────────────────────────────────────────────────────────────────────────────────────── Response ─────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                                         │
│     "VariableA": {                                                                                                                                                                                                        │
│         "_amount": "Holds the value of total minted share or amount"                                                                                                                                                      │
│     },                                                                                                                                                                                                                    │
│     "VariableB": {                                                                                                                                                                                                        │
│         "incentiveCrv": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                                   │
│     },                                                                                                                                                                                                                    │
│     "VariableC": {                                                                                                                                                                                                        │
│         "_amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                                       │
│     }                                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                                         │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 20:00:26] INFO     static_check: first_deposit_check: VariableA: _amount; VariableB: incentiveCrv; VariableC: _amount                                                                           static_check.py:128
    first_deposit_check    
┏━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ Argument ┃ Value        ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━┩
│ arg[0]   │ incentiveCrv │
│ arg[1]   │ _amount      │
│ arg[2]   │ _amount      │
└──────────┴──────────────┘
╭────────────────────────────────────────────────────────────────────────────────────────────────────── Current Step ───────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                            │
│ Code:                                                                                                                                                                                                                     │
│     function delegate(address newDelegatee) external virtual nonReentrant {                                                                                                                                               │
│         // Step 1: Get lock data                                                                                                                                                                                          │
│         LockedBalance[] storage locks = userLocks;                                                                                                                                                                        │
│         uint256 len = locks.length;                                                                                                                                                                                       │
│         require(len > 0, "Nothing to delegate");                                                                                                                                                                          │
│         require(newDelegatee != address(0), "Must delegate to someone");                                                                                                                                                  │
│                                                                                                                                                                                                                           │
│         // Step 2: Update delegatee storage                                                                                                                                                                               │
│         address oldDelegatee = delegates(msg.sender);                                                                                                                                                                     │
│         require(newDelegatee != oldDelegatee, "Must choose new delegatee");                                                                                                                                               │
│         _delegates = newDelegatee;                                                                                                                                                                                        │
│                                                                                                                                                                                                                           │
│         emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);                                                                                                                                                     │
│                                                                                                                                                                                                                           │
│         // Step 3: Move balances around                                                                                                                                                                                   │
│         //         Delegate for the upcoming epoch                                                                                                                                                                        │
│         uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);                                                                                                           │
│         uint256 i = len - 1;                                                                                                                                                                                              │
│         uint256 futureUnlocksSum = 0;                                                                                                                                                                                     │
│         LockedBalance memory currentLock = locks;                                                                                                                                                                         │
│         // Step 3.1: Add future unlocks and sum balances                                                                                                                                                                  │
│         while (currentLock.unlockTime > upcomingEpoch) {                                                                                                                                                                  │
│             futureUnlocksSum += currentLock.amount;                                                                                                                                                                       │
│                                                                                                                                                                                                                           │
│             if (oldDelegatee != address(0)) {                                                                                                                                                                             │
│                 delegateeUnlocks -= currentLock.amount;                                                                                                                                                                   │
│             }                                                                                                                                                                                                             │
│             delegateeUnlocks += currentLock.amount;                                                                                                                                                                       │
│                                                                                                                                                                                                                           │
│             if (i > 0) {                                                                                                                                                                                                  │
│                 i--;                                                                                                                                                                                                      │
│                 currentLock = locks;                                                                                                                                                                                      │
│             } else {                                                                                                                                                                                                      │
│                 break;                                                                                                                                                                                                    │
│             }                                                                                                                                                                                                             │
│         }                                                                                                                                                                                                                 │
│                                                                                                                                                                                                                           │
│         // Step 3.2: Checkpoint old delegatee                                                                                                                                                                             │
│         _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);                                                                                                                                                           │
│                                                                                                                                                                                                                           │
│         // Step 3.3: Checkpoint new delegatee                                                                                                                                                                             │
│         _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);                                                                                                                                                           │
│     }                                                                                                                                                                                                                     │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);`                                                                                                                                                       │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function delegate(address newDelegatee) external virtual nonReentrant {                                                                                                                                     │
│         // Step 1: Get lock data                                                                                                                                                                                │
│         LockedBalance[] storage locks = userLocks;                                                                                                                                                              │
│         uint256 len = locks.length;                                                                                                                                                                             │
│         require(len > 0, "Nothing to delegate");                                                                                                                                                                │
│         require(newDelegatee != address(0), "Must delegate to someone");                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // Step 2: Update delegatee storage                                                                                                                                                                     │
│         address oldDelegatee = delegates(msg.sender);                                                                                                                                                           │
│         require(newDelegatee != oldDelegatee, "Must choose new delegatee");                                                                                                                                     │
│         _delegates = newDelegatee;                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         // Step 3: Move balances around                                                                                                                                                                         │
│         //         Delegate for the upcoming epoch                                                                                                                                                              │
│         uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);                                                                                                 │
│         uint256 i = len - 1;                                                                                                                                                                                    │
│         uint256 futureUnlocksSum = 0;                                                                                                                                                                           │
│         LockedBalance memory currentLock = locks;                                                                                                                                                               │
│         // Step 3.1: Add future unlocks and sum balances                                                                                                                                                        │
│         while (currentLock.unlockTime > upcomingEpoch) {                                                                                                                                                        │
│             futureUnlocksSum += currentLock.amount;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             if (oldDelegatee != address(0)) {                                                                                                                                                                   │
│                 delegateeUnlocks -= currentLock.amount;                                                                                                                                                         │
│             }                                                                                                                                                                                                   │
│             delegateeUnlocks += currentLock.amount;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             if (i > 0) {                                                                                                                                                                                        │
│                 i--;                                                                                                                                                                                            │
│                 currentLock = locks;                                                                                                                                                                            │
│             } else {                                                                                                                                                                                            │
│                 break;                                                                                                                                                                                          │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Step 3.2: Checkpoint old delegatee                                                                                                                                                                   │
│         _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Step 3.3: Checkpoint new delegatee                                                                                                                                                                   │
│         _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `delegateeUnlocks += currentLock.amount;`                                                                                                                                                                       │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                             order_first_b                              
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                                     ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                                                        │
│ arg[1]   │ [_checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);] │
└──────────┴───────────────────────────────────────────────────────────┘
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                  │
│ Code:                                                                                                                                                                                                           │
│     function _checkpointDelegate(                                                                                                                                                                               │
│         address _account,                                                                                                                                                                                       │
│         uint256 _upcomingAddition,                                                                                                                                                                              │
│         uint256 _upcomingDeduction                                                                                                                                                                              │
│     ) internal {                                                                                                                                                                                                │
│         // This would only skip on first checkpointing                                                                                                                                                          │
│         if (_account != address(0)) {                                                                                                                                                                           │
│             uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);                                                                                             │
│             DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];                                                                                                                                 │
│             if (ckpts.length > 0) {                                                                                                                                                                             │
│                 DelegateeCheckpoint memory prevCkpt = ckpts;                                                                                                                                                    │
│                 // If there has already been a record for the upcoming epoch, no need to deduct the unlocks                                                                                                     │
│                 if (prevCkpt.epochStart == upcomingEpoch) {                                                                                                                                                     │
│                     ckpts = DelegateeCheckpoint({                                                                                                                                                               │
│                         votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),                                                                                                               │
│                         epochStart: upcomingEpoch.to32()                                                                                                                                                        │
│                     });                                                                                                                                                                                         │
│                 }                                                                                                                                                                                               │
│                 // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired                                                                                                │
│                 // e.g. week 1 + 17 <= 18                                                                                                                                                                       │
│                 else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {                                                                                                                                 │
│                     ckpts.push(                                                                                                                                                                                 │
│                         DelegateeCheckpoint({                                                                                                                                                                   │
│                             votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                            │
│                             epochStart: upcomingEpoch.to32()                                                                                                                                                    │
│                         })                                                                                                                                                                                      │
│                     );                                                                                                                                                                                          │
│                 } else {                                                                                                                                                                                        │
│                     uint256 nextEpoch = upcomingEpoch;                                                                                                                                                          │
│                     uint256 unlocksSinceLatestCkpt = 0;                                                                                                                                                         │
│                     // Should be maximum 18 iterations                                                                                                                                                          │
│                     while (nextEpoch > prevCkpt.epochStart) {                                                                                                                                                   │
│                         unlocksSinceLatestCkpt += delegateeUnlocks[_account];                                                                                                                                   │
│                         nextEpoch -= rewardsDuration;                                                                                                                                                           │
│                     }                                                                                                                                                                                           │
│                     ckpts.push(                                                                                                                                                                                 │
│                         DelegateeCheckpoint({                                                                                                                                                                   │
│                             votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)                                                                                           │
│                                 .to224(),                                                                                                                                                                       │
│                             epochStart: upcomingEpoch.to32()                                                                                                                                                    │
│                         })                                                                                                                                                                                      │
│                     );                                                                                                                                                                                          │
│                 }                                                                                                                                                                                               │
│             } else {                                                                                                                                                                                            │
│                 ckpts.push(                                                                                                                                                                                     │
│                     DelegateeCheckpoint({                                                                                                                                                                       │
│                         votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                                │
│                         epochStart: upcomingEpoch.to32()                                                                                                                                                        │
│                     })                                                                                                                                                                                          │
│                 );                                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             emit DelegateCheckpointed(_account);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `ckpts.push(                                                                                                                                                                                                    │
│     DelegateeCheckpoint({                                                                                                                                                                                       │
│         votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                                                │
│         epochStart: upcomingEpoch.to32()                                                                                                                                                                        │
│     })                                                                                                                                                                                                          │
│ );`                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _checkpointDelegate(                                                                                                                                                                               │
│         address _account,                                                                                                                                                                                       │
│         uint256 _upcomingAddition,                                                                                                                                                                              │
│         uint256 _upcomingDeduction                                                                                                                                                                              │
│     ) internal {                                                                                                                                                                                                │
│         // This would only skip on first checkpointing                                                                                                                                                          │
│         if (_account != address(0)) {                                                                                                                                                                           │
│             uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);                                                                                             │
│             DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];                                                                                                                                 │
│             if (ckpts.length > 0) {                                                                                                                                                                             │
│                 DelegateeCheckpoint memory prevCkpt = ckpts;                                                                                                                                                    │
│                 // If there has already been a record for the upcoming epoch, no need to deduct the unlocks                                                                                                     │
│                 if (prevCkpt.epochStart == upcomingEpoch) {                                                                                                                                                     │
│                     ckpts = DelegateeCheckpoint({                                                                                                                                                               │
│                         votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),                                                                                                               │
│                         epochStart: upcomingEpoch.to32()                                                                                                                                                        │
│                     });                                                                                                                                                                                         │
│                 }                                                                                                                                                                                               │
│                 // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired                                                                                                │
│                 // e.g. week 1 + 17 <= 18                                                                                                                                                                       │
│                 else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {                                                                                                                                 │
│                     ckpts.push(                                                                                                                                                                                 │
│                         DelegateeCheckpoint({                                                                                                                                                                   │
│                             votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                            │
│                             epochStart: upcomingEpoch.to32()                                                                                                                                                    │
│                         })                                                                                                                                                                                      │
│                     );                                                                                                                                                                                          │
│                 } else {                                                                                                                                                                                        │
│                     uint256 nextEpoch = upcomingEpoch;                                                                                                                                                          │
│                     uint256 unlocksSinceLatestCkpt = 0;                                                                                                                                                         │
│                     // Should be maximum 18 iterations                                                                                                                                                          │
│                     while (nextEpoch > prevCkpt.epochStart) {                                                                                                                                                   │
│                         unlocksSinceLatestCkpt += delegateeUnlocks[_account];                                                                                                                                   │
│                         nextEpoch -= rewardsDuration;                                                                                                                                                           │
│                     }                                                                                                                                                                                           │
│                     ckpts.push(                                                                                                                                                                                 │
│                         DelegateeCheckpoint({                                                                                                                                                                   │
│                             votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)                                                                                           │
│                                 .to224(),                                                                                                                                                                       │
│                             epochStart: upcomingEpoch.to32()                                                                                                                                                    │
│                         })                                                                                                                                                                                      │
│                     );                                                                                                                                                                                          │
│                 }                                                                                                                                                                                               │
│             } else {                                                                                                                                                                                            │
│                 ckpts.push(                                                                                                                                                                                     │
│                     DelegateeCheckpoint({                                                                                                                                                                       │
│                         votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                                │
│                         epochStart: upcomingEpoch.to32()                                                                                                                                                        │
│                     })                                                                                                                                                                                          │
│                 );                                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             emit DelegateCheckpointed(_account);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `ckpts.push(                                                                                                                                                                                                    │
│     DelegateeCheckpoint({                                                                                                                                                                                       │
│         votes: (_upcomingAddition - _upcomingDeduction).to224(),                                                                                                                                                │
│         epochStart: upcomingEpoch.to32()                                                                                                                                                                        │
│     })                                                                                                                                                                                                          │
│ );`                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                                                                           order_first_b                                                                           
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                                                                                                                                ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                                                                                                                                                   │
│ arg[1]   │ [ckpts.push(,     DelegateeCheckpoint({,         votes: (_upcomingAddition - _upcomingDeduction).to224(),,         epochStart: upcomingEpoch.to32()] │
└──────────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {                                                                                                          │
│         RewardData storage rdata = rewardData[_rewardsToken];                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             rdata.rewardRate = _reward.div(rewardsDuration).to96();                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);                                                                                                                               │
│             uint256 leftover = remaining.mul(rdata.rewardRate);                                                                                                                                                 │
│             rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rdata.lastUpdateTime = block.timestamp.to32();                                                                                                                                                          │
│         rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardAdded(_rewardsToken, _reward);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `rdata.rewardRate = _reward.div(rewardsDuration).to96();`.                                                                                       │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {                                                                                                          │
│         RewardData storage rdata = rewardData[_rewardsToken];                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         if (block.timestamp >= rdata.periodFinish) {                                                                                                                                                            │
│             rdata.rewardRate = _reward.div(rewardsDuration).to96();                                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);                                                                                                                               │
│             uint256 leftover = remaining.mul(rdata.rewardRate);                                                                                                                                                 │
│             rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         rdata.lastUpdateTime = block.timestamp.to32();                                                                                                                                                          │
│         rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         emit RewardAdded(_rewardsToken, _reward);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `rdata.rewardRate = _reward.div(rewardsDuration).to96();`                                                                                                                                                       │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                             order_first_b                              
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                                     ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ [rdata.rewardRate = _reward.div(rewardsDuration).to96();] │
│ arg[1]   │ [rdata.rewardRate = _reward.div(rewardsDuration).to96();] │
└──────────┴───────────────────────────────────────────────────────────┘
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                  │
│ Code:                                                                                                                                                                                                           │
│     function addReward(address _token, uint256 _amount) external {                                                                                                                                              │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         _addReward(_token, _amount, latestEpoch);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `auraLocker.checkpointEpoch();`                                                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function addReward(address _token, uint256 _amount) external {                                                                                                                                              │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         _addReward(_token, _amount, latestEpoch);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_addReward(_token, _amount, latestEpoch);`                                                                                                                                                                     │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                      order_first_b                       
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                       ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ [_addReward(_token, _amount, latestEpoch);] │
│ arg[1]   │ [auraLocker.checkpointEpoch();]             │
└──────────┴─────────────────────────────────────────────┘
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                  │
│ Code:                                                                                                                                                                                                           │
│     function addRewardToEpoch(                                                                                                                                                                                  │
│         address _token,                                                                                                                                                                                         │
│         uint256 _amount,                                                                                                                                                                                        │
│         uint256 _epoch                                                                                                                                                                                          │
│     ) external {                                                                                                                                                                                                │
│         auraLocker.checkpointEpoch();                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         uint256 latestEpoch = auraLocker.epochCount() - 1;                                                                                                                                                      │
│         require(_epoch <= latestEpoch, "Cannot assign to the future");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (_epoch == latestEpoch) {                                                                                                                                                                            │
│             _addReward(_token, _amount, latestEpoch);                                                                                                                                                           │
│         } else {                                                                                                                                                                                                │
│             uint256 len = rewardEpochs[_token].length;                                                                                                                                                          │
│             require(len == 0 || rewardEpochs[_token] < _epoch, "Cannot backdate to this epoch");                                                                                                                │
│                                                                                                                                                                                                                 │
│             _addReward(_token, _amount, _epoch);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `ZERO`                                                                                                                                                                                                          │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   order_first_b    
┏━━━━━━━━━━┳━━━━━━━┓
┃ Argument ┃ Value ┃
┡━━━━━━━━━━╇━━━━━━━┩
│ arg[0]   │ []    │
│ arg[1]   │ []    │
└──────────┴───────┘
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                  │
│ Code:                                                                                                                                                                                                           │
│     function _getReward(                                                                                                                                                                                        │
│         address _account,                                                                                                                                                                                       │
│         address _token,                                                                                                                                                                                         │
│         uint256 _startIndex                                                                                                                                                                                     │
│     ) public {                                                                                                                                                                                                  │
│         //get claimable tokens                                                                                                                                                                                  │
│         (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (claimableTokens > 0) {                                                                                                                                                                              │
│             //set claim checkpoint                                                                                                                                                                              │
│             userClaims[_token][_account] = index;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send                                                                                                                                                                                              │
│             IERC20(_token).safeTransfer(_account, claimableTokens);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             //event                                                                                                                                                                                             │
│             emit RewardPaid(_account, _token, claimableTokens, index);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to invoke user checkpoint is `userClaims[_token][_account] = index;`.                                                                                                                       │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _getReward(                                                                                                                                                                                        │
│         address _account,                                                                                                                                                                                       │
│         address _token,                                                                                                                                                                                         │
│         uint256 _startIndex                                                                                                                                                                                     │
│     ) public {                                                                                                                                                                                                  │
│         //get claimable tokens                                                                                                                                                                                  │
│         (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);                                                                                                         │
│                                                                                                                                                                                                                 │
│         if (claimableTokens > 0) {                                                                                                                                                                              │
│             //set claim checkpoint                                                                                                                                                                              │
│             userClaims[_token][_account] = index;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             //send                                                                                                                                                                                              │
│             IERC20(_token).safeTransfer(_account, claimableTokens);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│             //event                                                                                                                                                                                             │
│             emit RewardPaid(_account, _token, claimableTokens, index);                                                                                                                                          │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward is `userClaims[_token][_account] = index;`.                                                                          │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    order_first_b                     
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Argument ┃ Value                                   ┃
┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ arg[0]   │ []                                      │
│ arg[1]   │ [userClaims[_token][_account] = index;] │
└──────────┴─────────────────────────────────────────┘
                                                                                                   Scan Results                                                                                                    
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Type                 ┃ Description                                                 ┃ Affected Files                                               ┃ Analysis Report                                             ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
│ Unsafe First Deposit │ First depositor can break minting of shares or drain the    │ ┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┓ │ ┏━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━┓ │
│                      │ liquidity of all users.                                     │ ┃ File Path            ┃ Line Range ┃ Code                 ┃ │ ┃ Secure    ┃           ┃          ┃          ┃           ┃ │
│                      │                                                             │ ┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━┩ │ ┃ Code      ┃ Best      ┃ CVSS     ┃          ┃           ┃ │
│                      │                                                             │ │ /home/owen/Document… │ 61 - 77    │     function init(   │ │ ┃ Examples  ┃ Practices ┃ Score    ┃ Severity ┃ Recommen… ┃ │
│                      │                                                             │ │                      │            │                      │ │ ┡━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━┩ │
│                      │                                                             │ │                      │            │         address _to, │ │ │ To make   │ To        │ 5.9      │ Medium   │ Ensure    │ │
│                      │                                                             │ │                      │            │                      │ │ │ the code  │ mitigate  │          │          │ proper    │ │
│                      │                                                             │ │                      │            │         uint256      │ │ │ more      │ vulnerab… │          │          │ access    │ │
│                      │                                                             │ │                      │            │ _amount,             │ │ │ secure,   │ in the    │          │          │ controls  │ │
│                      │                                                             │ │                      │            │                      │ │ │ you can   │ provided  │          │          │ are in    │ │
│                      │                                                             │ │                      │            │         address      │ │ │ consider  │ code      │          │          │ place to  │ │
│                      │                                                             │ │                      │            │ _minter              │ │ │ the       │ snippet,  │          │          │ prevent   │ │
│                      │                                                             │ │                      │            │                      │ │ │ following │ you can   │          │          │ unauthor… │ │
│                      │                                                             │ │                      │            │     ) external {     │ │ │ improvem… │ consider  │          │          │ access to │ │
│                      │                                                             │ │                      │            │                      │ │ │           │ implemen… │          │          │ the       │ │
│                      │                                                             │ │                      │            │         require(msg… │ │ │ 1. Use    │ the       │          │          │ function. │ │
│                      │                                                             │ │                      │            │ == operator, "Only   │ │ │ access    │ following │          │          │ Consider  │ │
│                      │                                                             │ │                      │            │ operator");          │ │ │ control:  │ best      │          │          │ implemen… │ │
│                      │                                                             │ │                      │            │                      │ │ │ Implement │ practice… │          │          │ role-bas… │ │
│                      │                                                             │ │                      │            │         require(tot… │ │ │ an access │           │          │          │ access    │ │
│                      │                                                             │ │                      │            │ == 0, "Only once");  │ │ │ control   │ 1.        │          │          │ control   │ │
│                      │                                                             │ │                      │            │                      │ │ │ mechanism │ **Access  │          │          │ and limit │ │
│                      │                                                             │ │                      │            │         require(_am… │ │ │ using     │ Control:… │          │          │ the       │ │
│                      │                                                             │ │                      │            │ > 0, "Must mint      │ │ │ OpenZepp… │    - Use  │          │          │ permissi… │ │
│                      │                                                             │ │                      │            │ something");         │ │ │ Access    │ a         │          │          │ of the    │ │
│                      │                                                             │ │                      │            │                      │ │ │ Control   │ role-bas… │          │          │ operator  │ │
│                      │                                                             │ │                      │            │         require(_mi… │ │ │ library   │ access    │          │          │ role.     │ │
│                      │                                                             │ │                      │            │ != address(0),       │ │ │ to manage │ control   │          │          │           │ │
│                      │                                                             │ │                      │            │ "Invalid minter");   │ │ │ roles and │ mechanism │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ permissi… │ to limit  │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ This will │ who can   │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ allow you │ call the  │          │          │           │ │
│                      │                                                             │ │                      │            │         _mint(_to,   │ │ │ to define │ `init`    │          │          │           │ │
│                      │                                                             │ │                      │            │ _amount);            │ │ │ different │ function. │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ roles     │ This can  │          │          │           │ │
│                      │                                                             │ │                      │            │         updateOpera… │ │ │ such as   │ be        │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ operator, │ achieved  │          │          │           │ │
│                      │                                                             │ │                      │            │         minter =     │ │ │ minter,   │ by        │          │          │           │ │
│                      │                                                             │ │                      │            │ _minter;             │ │ │ etc., and │ implemen… │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ restrict  │ a         │          │          │           │ │
│                      │                                                             │ │                      │            │         minterMinted │ │ │ access    │ modifier  │          │          │           │ │
│                      │                                                             │ │                      │            │ = 0;                 │ │ │ based on  │ or using  │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ these     │ a role    │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ roles.    │ manageme… │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │           │ library.  │          │          │           │ │
│                      │                                                             │ │                      │            │         emit         │ │ │ 2. Use    │    -      │          │          │           │ │
│                      │                                                             │ │                      │            │ Initialised();       │ │ │ the       │ Consider  │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ "onlyOnc… │ using     │          │          │           │ │
│                      │                                                             │ │                      │            │     }                │ │ │ modifier: │ OpenZepp… │          │          │           │ │
│                      │                                                             │ │                      │            │                      │ │ │ Create a  │ Access    │          │          │           │ │
│                      │                                                             │ └──────────────────────┴────────────┴──────────────────────┘ │ │ modifier  │ Control   │          │          │           │ │
│                      │                                                             │                                                              │ │ that      │ library   │          │          │           │ │
│                      │                                                             │                                                              │ │ checks if │ to manage │          │          │           │ │
│                      │                                                             │                                                              │ │ the       │ roles and │          │          │           │ │
│                      │                                                             │                                                              │ │ function  │ permissi… │          │          │           │ │
│                      │                                                             │                                                              │ │ has been  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ called    │ 2.        │          │          │           │ │
│                      │                                                             │                                                              │ │ only      │ **Reentr… │          │          │           │ │
│                      │                                                             │                                                              │ │ once.     │ Guard:**  │          │          │           │ │
│                      │                                                             │                                                              │ │ This can  │    -      │          │          │           │ │
│                      │                                                             │                                                              │ │ be done   │ Implement │          │          │           │ │
│                      │                                                             │                                                              │ │ by adding │ a         │          │          │           │ │
│                      │                                                             │                                                              │ │ a boolean │ reentran… │          │          │           │ │
│                      │                                                             │                                                              │ │ variable  │ guard to  │          │          │           │ │
│                      │                                                             │                                                              │ │ to track  │ prevent   │          │          │           │ │
│                      │                                                             │                                                              │ │ if the    │ reentran… │          │          │           │ │
│                      │                                                             │                                                              │ │ initiali… │ attacks.  │          │          │           │ │
│                      │                                                             │                                                              │ │ has       │ You can   │          │          │           │ │
│                      │                                                             │                                                              │ │ already   │ achieve   │          │          │           │ │
│                      │                                                             │                                                              │ │ occurred. │ this by   │          │          │           │ │
│                      │                                                             │                                                              │ │           │ using the │          │          │           │ │
│                      │                                                             │                                                              │ │ 3. Use    │ OpenZepp… │          │          │           │ │
│                      │                                                             │                                                              │ │ the       │ Reentran… │          │          │           │ │
│                      │                                                             │                                                              │ │ "nonReen… │ library   │          │          │           │ │
│                      │                                                             │                                                              │ │ modifier: │ or        │          │          │           │ │
│                      │                                                             │                                                              │ │ Implement │ implemen… │          │          │           │ │
│                      │                                                             │                                                              │ │ a         │ a custom  │          │          │           │ │
│                      │                                                             │                                                              │ │ non-reen… │ solution. │          │          │           │ │
│                      │                                                             │                                                              │ │ modifier  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ to        │ 3.        │          │          │           │ │
│                      │                                                             │                                                              │ │ prevent   │ **Input   │          │          │           │ │
│                      │                                                             │                                                              │ │ reentran… │ Validati… │          │          │           │ │
│                      │                                                             │                                                              │ │ attacks   │    -      │          │          │           │ │
│                      │                                                             │                                                              │ │ by        │ Validate  │          │          │           │ │
│                      │                                                             │                                                              │ │ ensuring  │ input     │          │          │           │ │
│                      │                                                             │                                                              │ │ that the  │ paramete… │          │          │           │ │
│                      │                                                             │                                                              │ │ function  │ to ensure │          │          │           │ │
│                      │                                                             │                                                              │ │ cannot be │ they meet │          │          │           │ │
│                      │                                                             │                                                              │ │ called    │ the       │          │          │           │ │
│                      │                                                             │                                                              │ │ recursiv… │ required  │          │          │           │ │
│                      │                                                             │                                                              │ │           │ conditio… │          │          │           │ │
│                      │                                                             │                                                              │ │ Here's an │ For       │          │          │           │ │
│                      │                                                             │                                                              │ │ example   │ example,  │          │          │           │ │
│                      │                                                             │                                                              │ │ of how    │ check     │          │          │           │ │
│                      │                                                             │                                                              │ │ you can   │ that      │          │          │           │ │
│                      │                                                             │                                                              │ │ refactor  │ `_amount` │          │          │           │ │
│                      │                                                             │                                                              │ │ the code  │ is        │          │          │           │ │
│                      │                                                             │                                                              │ │ using the │ greater   │          │          │           │ │
│                      │                                                             │                                                              │ │ above     │ than zero │          │          │           │ │
│                      │                                                             │                                                              │ │ suggesti… │ and       │          │          │           │ │
│                      │                                                             │                                                              │ │           │ `_minter` │          │          │           │ │
│                      │                                                             │                                                              │ │ ```solid… │ is not    │          │          │           │ │
│                      │                                                             │                                                              │ │ import    │ the zero  │          │          │           │ │
│                      │                                                             │                                                              │ │ "@openze… │ address.  │          │          │           │ │
│                      │                                                             │                                                              │ │           │    -      │          │          │           │ │
│                      │                                                             │                                                              │ │ contract  │ Consider  │          │          │           │ │
│                      │                                                             │                                                              │ │ YourCont… │ adding    │          │          │           │ │
│                      │                                                             │                                                              │ │ is        │ addition… │          │          │           │ │
│                      │                                                             │                                                              │ │ AccessCo… │ input     │          │          │           │ │
│                      │                                                             │                                                              │ │ {         │ validati… │          │          │           │ │
│                      │                                                             │                                                              │ │     bool  │ based on  │          │          │           │ │
│                      │                                                             │                                                              │ │ public    │ the       │          │          │           │ │
│                      │                                                             │                                                              │ │ initiali… │ specific  │          │          │           │ │
│                      │                                                             │                                                              │ │     addr… │ requirem… │          │          │           │ │
│                      │                                                             │                                                              │ │ public    │ of your   │          │          │           │ │
│                      │                                                             │                                                              │ │ operator; │ contract. │          │          │           │ │
│                      │                                                             │                                                              │ │     addr… │           │          │          │           │ │
│                      │                                                             │                                                              │ │ public    │ 4.        │          │          │           │ │
│                      │                                                             │                                                              │ │ minter;   │ **State   │          │          │           │ │
│                      │                                                             │                                                              │ │     uint… │ Changes:… │          │          │           │ │
│                      │                                                             │                                                              │ │ public    │    -      │          │          │           │ │
│                      │                                                             │                                                              │ │ minterMi… │ Ensure    │          │          │           │ │
│                      │                                                             │                                                              │ │           │ that      │          │          │           │ │
│                      │                                                             │                                                              │ │     event │ state     │          │          │           │ │
│                      │                                                             │                                                              │ │ Initiali… │ changes   │          │          │           │ │
│                      │                                                             │                                                              │ │           │ are       │          │          │           │ │
│                      │                                                             │                                                              │ │     modi… │ performed │          │          │           │ │
│                      │                                                             │                                                              │ │ onlyOper… │ in a      │          │          │           │ │
│                      │                                                             │                                                              │ │ {         │ consiste… │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ and       │          │          │           │ │
│                      │                                                             │                                                              │ │ msg.send… │ secure    │          │          │           │ │
│                      │                                                             │                                                              │ │ ||        │ manner.   │          │          │           │ │
│                      │                                                             │                                                              │ │ hasRole(… │ Make sure │          │          │           │ │
│                      │                                                             │                                                              │ │ msg.send… │ to update │          │          │           │ │
│                      │                                                             │                                                              │ │ "Only     │ state     │          │          │           │ │
│                      │                                                             │                                                              │ │ operator… │ variables │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ atomical… │          │          │           │ │
│                      │                                                             │                                                              │ │     }     │ to avoid  │          │          │           │ │
│                      │                                                             │                                                              │ │           │ race      │          │          │           │ │
│                      │                                                             │                                                              │ │     modi… │ conditio… │          │          │           │ │
│                      │                                                             │                                                              │ │ onlyOnce… │    -      │          │          │           │ │
│                      │                                                             │                                                              │ │ {         │ Consider  │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ using the │          │          │           │ │
│                      │                                                             │                                                              │ │ "Initial… │ OpenZepp… │          │          │           │ │
│                      │                                                             │                                                              │ │ can only  │ SafeMath  │          │          │           │ │
│                      │                                                             │                                                              │ │ happen    │ library   │          │          │           │ │
│                      │                                                             │                                                              │ │ once");   │ to        │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ perform   │          │          │           │ │
│                      │                                                             │                                                              │ │     }     │ arithmet… │          │          │           │ │
│                      │                                                             │                                                              │ │           │ operatio… │          │          │           │ │
│                      │                                                             │                                                              │ │     func… │ securely. │          │          │           │ │
│                      │                                                             │                                                              │ │ init(add… │           │          │          │           │ │
│                      │                                                             │                                                              │ │ _to,      │ 5.        │          │          │           │ │
│                      │                                                             │                                                              │ │ uint256   │ **Event   │          │          │           │ │
│                      │                                                             │                                                              │ │ _amount,  │ Logging:… │          │          │           │ │
│                      │                                                             │                                                              │ │ address   │    - Emit │          │          │           │ │
│                      │                                                             │                                                              │ │ _minter)  │ informat… │          │          │           │ │
│                      │                                                             │                                                              │ │ external  │ events to │          │          │           │ │
│                      │                                                             │                                                              │ │ onlyOper… │ log       │          │          │           │ │
│                      │                                                             │                                                              │ │ onlyOnce  │ important │          │          │           │ │
│                      │                                                             │                                                              │ │ {         │ state     │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ changes   │          │          │           │ │
│                      │                                                             │                                                              │ │ > 0,      │ and       │          │          │           │ │
│                      │                                                             │                                                              │ │ "Must     │ actions   │          │          │           │ │
│                      │                                                             │                                                              │ │ mint      │ taken by  │          │          │           │ │
│                      │                                                             │                                                              │ │ somethin… │ the       │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ contract. │          │          │           │ │
│                      │                                                             │                                                              │ │ !=        │ This can  │          │          │           │ │
│                      │                                                             │                                                              │ │ address(… │ help with │          │          │           │ │
│                      │                                                             │                                                              │ │ "Invalid  │ transpar… │          │          │           │ │
│                      │                                                             │                                                              │ │ minter"); │ and       │          │          │           │ │
│                      │                                                             │                                                              │ │           │ debuggin… │          │          │           │ │
│                      │                                                             │                                                              │ │         … │    -      │          │          │           │ │
│                      │                                                             │                                                              │ │ _amount); │ Include   │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ relevant  │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ informat… │          │          │           │ │
│                      │                                                             │                                                              │ │ =         │ in the    │          │          │           │ │
│                      │                                                             │                                                              │ │ _minter;  │ emitted   │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ events to │          │          │           │ │
│                      │                                                             │                                                              │ │ = 0;      │ provide   │          │          │           │ │
│                      │                                                             │                                                              │ │           │ more      │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ context   │          │          │           │ │
│                      │                                                             │                                                              │ │ = true;   │ about the │          │          │           │ │
│                      │                                                             │                                                              │ │           │ operation │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ that was  │          │          │           │ │
│                      │                                                             │                                                              │ │ Initiali… │ performe… │          │          │           │ │
│                      │                                                             │                                                              │ │     }     │           │          │          │           │ │
│                      │                                                             │                                                              │ │           │ 6.        │          │          │           │ │
│                      │                                                             │                                                              │ │     func… │ **Docume… │          │          │           │ │
│                      │                                                             │                                                              │ │ updateOp… │    - Add  │          │          │           │ │
│                      │                                                             │                                                              │ │ private { │ inline    │          │          │           │ │
│                      │                                                             │                                                              │ │         … │ comments  │          │          │           │ │
│                      │                                                             │                                                              │ │ Implement │ to        │          │          │           │ │
│                      │                                                             │                                                              │ │ your      │ explain   │          │          │           │ │
│                      │                                                             │                                                              │ │ logic for │ the       │          │          │           │ │
│                      │                                                             │                                                              │ │ updating  │ purpose   │          │          │           │ │
│                      │                                                             │                                                              │ │ the       │ of the    │          │          │           │ │
│                      │                                                             │                                                              │ │ operator  │ function  │          │          │           │ │
│                      │                                                             │                                                              │ │ here      │ and any   │          │          │           │ │
│                      │                                                             │                                                              │ │     }     │ critical  │          │          │           │ │
│                      │                                                             │                                                              │ │ }         │ operatio… │          │          │           │ │
│                      │                                                             │                                                              │ │ ```       │ within    │          │          │           │ │
│                      │                                                             │                                                              │ │           │ the code. │          │          │           │ │
│                      │                                                             │                                                              │ │ In the    │ This can  │          │          │           │ │
│                      │                                                             │                                                              │ │ refactor… │ help      │          │          │           │ │
│                      │                                                             │                                                              │ │ code:     │ other     │          │          │           │ │
│                      │                                                             │                                                              │ │           │ develope… │          │          │           │ │
│                      │                                                             │                                                              │ │ - The     │ understa… │          │          │           │ │
│                      │                                                             │                                                              │ │ Access    │ the code  │          │          │           │ │
│                      │                                                             │                                                              │ │ Control   │ and its   │          │          │           │ │
│                      │                                                             │                                                              │ │ library   │ intended  │          │          │           │ │
│                      │                                                             │                                                              │ │ is used   │ behavior. │          │          │           │ │
│                      │                                                             │                                                              │ │ to manage │           │          │          │           │ │
│                      │                                                             │                                                              │ │ roles and │ By        │          │          │           │ │
│                      │                                                             │                                                              │ │ permissi… │ following │          │          │           │ │
│                      │                                                             │                                                              │ │ -         │ these     │          │          │           │ │
│                      │                                                             │                                                              │ │ Modifiers │ best      │          │          │           │ │
│                      │                                                             │                                                              │ │ are used  │ practices │          │          │           │ │
│                      │                                                             │                                                              │ │ to        │ and       │          │          │           │ │
│                      │                                                             │                                                              │ │ enforce   │ ensuring  │          │          │           │ │
│                      │                                                             │                                                              │ │ access    │ proper    │          │          │           │ │
│                      │                                                             │                                                              │ │ control   │ testing,  │          │          │           │ │
│                      │                                                             │                                                              │ │ and       │ you can   │          │          │           │ │
│                      │                                                             │                                                              │ │ ensure    │ enhance   │          │          │           │ │
│                      │                                                             │                                                              │ │ that the  │ the       │          │          │           │ │
│                      │                                                             │                                                              │ │ `init`    │ security  │          │          │           │ │
│                      │                                                             │                                                              │ │ function  │ and       │          │          │           │ │
│                      │                                                             │                                                              │ │ can only  │ reliabil… │          │          │           │ │
│                      │                                                             │                                                              │ │ be called │ of the    │          │          │           │ │
│                      │                                                             │                                                              │ │ once.     │ `init`    │          │          │           │ │
│                      │                                                             │                                                              │ │ - The     │ function  │          │          │           │ │
│                      │                                                             │                                                              │ │ `initial… │ in your   │          │          │           │ │
│                      │                                                             │                                                              │ │ variable  │ smart     │          │          │           │ │
│                      │                                                             │                                                              │ │ is used   │ contract. │          │          │           │ │
│                      │                                                             │                                                              │ │ to track  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ if the    │           │          │          │           │ │
│                      │                                                             │                                                              │ │ initiali… │           │          │          │           │ │
│                      │                                                             │                                                              │ │ has       │           │          │          │           │ │
│                      │                                                             │                                                              │ │ already   │           │          │          │           │ │
│                      │                                                             │                                                              │ │ occurred. │           │          │          │           │ │
│                      │                                                             │                                                              │ │ - The     │           │          │          │           │ │
│                      │                                                             │                                                              │ │ `onlyOpe… │           │          │          │           │ │
│                      │                                                             │                                                              │ │ modifier  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ restricts │           │          │          │           │ │
│                      │                                                             │                                                              │ │ access to │           │          │          │           │ │
│                      │                                                             │                                                              │ │ authoriz… │           │          │          │           │ │
│                      │                                                             │                                                              │ │ operator… │           │          │          │           │ │
│                      │                                                             │                                                              │ │ - The     │           │          │          │           │ │
│                      │                                                             │                                                              │ │ `onlyOnc… │           │          │          │           │ │
│                      │                                                             │                                                              │ │ modifier  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ ensures   │           │          │          │           │ │
│                      │                                                             │                                                              │ │ that the  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ `init`    │           │          │          │           │ │
│                      │                                                             │                                                              │ │ function  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ can only  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ be called │           │          │          │           │ │
│                      │                                                             │                                                              │ │ once.     │           │          │          │           │ │
│                      │                                                             │                                                              │ │           │           │          │          │           │ │
│                      │                                                             │                                                              │ │ By        │           │          │          │           │ │
│                      │                                                             │                                                              │ │ implemen… │           │          │          │           │ │
│                      │                                                             │                                                              │ │ these     │           │          │          │           │ │
│                      │                                                             │                                                              │ │ changes,  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ you can   │           │          │          │           │ │
│                      │                                                             │                                                              │ │ enhance   │           │          │          │           │ │
│                      │                                                             │                                                              │ │ the       │           │          │          │           │ │
│                      │                                                             │                                                              │ │ security  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ of your   │           │          │          │           │ │
│                      │                                                             │                                                              │ │ smart     │           │          │          │           │ │
│                      │                                                             │                                                              │ │ contract  │           │          │          │           │ │
│                      │                                                             │                                                              │ │ and       │           │          │          │           │ │
│                      │                                                             │                                                              │ │ prevent   │           │          │          │           │ │
│                      │                                                             │                                                              │ │ potential │           │          │          │           │ │
│                      │                                                             │                                                              │ │ vulnerab… │           │          │          │           │ │
│                      │                                                             │                                                              │ └───────────┴───────────┴──────────┴──────────┴───────────┘ │
└──────────────────────┴─────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────┘
                   Summary                   
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value              ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 57                 │
│ Contracts            │ 99                 │
│ Functions            │ 180                │
│ Lines of Code        │ 7599               │
│ Used Time            │ 156.62159514427185 │
│ Estimated Cost (USD) │ 0.152776           │
└──────────────────────┴────────────────────┘
