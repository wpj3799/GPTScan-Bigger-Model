

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[19:11:47] Loaded 10 rules                                                                                                                                                                             tasks.py:119
[12/08/24 19:11:47] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main)               subprocess.py:41
[12/08/24 19:14:39] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_11_47_229Z-debug-0.log                                                              
                    INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main)      subprocess.py:41
[12/08/24 19:14:44] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_14_40_071Z-debug-0.log                                                              
[12/08/24 19:14:45] INFO     CryticCompile: Problem executing hardhat: npm warn exec The following package was not found and will be installed: hardhat@2.22.17                                      hardhat.py:327
                             npm error Invalid Version:                                                                                                                                                            
                             npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_14_44_675Z-debug-0.log                                                                      
                                                                                                                                                                                                                   
                    INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main)     subprocess.py:41
[12/08/24 19:14:52] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_14_46_024Z-debug-0.log                                                              
[19:14:52] Traceback (most recent call last):                                                                                                                                                          tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                     
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                    
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                    
               self._compile(**kwargs)                                                                                                                                                                             
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                    
               self._platform.compile(self, **kwargs)                                                                                                                                                              
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 183, in compile                                                   
               hardhat_like_parsing(crytic_compile, self._target, build_directory, hardhat_working_dir)                                                                                                            
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 52, in hardhat_like_parsing                                       
               raise InvalidCompilation(txt)                                                                                                                                                                       
           crytic_compile.platform.exceptions.InvalidCompilation: Compilation failed. Can you run build command?                                                                                                   
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/artifacts/build-info is not a directory.                                                         
                                                                                                                                                                                                                   
           During handling of the above exception, another exception occurred:                                                                                                                                     
                                                                                                                                                                                                                   
           Traceback (most recent call last):                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                         
               falcon_instance = compile_project(source_dir)                                                                                                                                                       
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                    
               return falcon.Falcon(abs_path)                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                     
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                               
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                     
           Compilation failed. Can you run build command?                                                                                                                                                          
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/artifacts/build-info is not a directory.                                                         
                                                                                                                                                                                                                   
           Compile failed.                                                                                                                                                                             tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                  tasks.py:128
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _provideLiquidity(                                                                                                                                                                                 │
│         address sender,                                                                                                                                                                                         │
│         IVault vault,                                                                                                                                                                                           │
│         bytes32 poolId,                                                                                                                                                                                         │
│         IERC20[] memory ammTokens,                                                                                                                                                                              │
│         uint256[] memory ammBalances,                                                                                                                                                                           │
│         uint256 sharesAmount,                                                                                                                                                                                   │
│         address recipient                                                                                                                                                                                       │
│     ) private returns (uint256[] memory) {                                                                                                                                                                      │
│         uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);                                                                                           │
│                                                                                                                                                                                                                 │
│         if (sender != address(this)) {                                                                                                                                                                          │
│             ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);                                                                                                              │
│             ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);                                                                                                              │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);                                                                                                                    │
│         ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);                                                                                                                    │
│                                                                                                                                                                                                                 │
│         IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({                                                                                                                                        │
│             assets: ammTokens,                                                                                                                                                                                  │
│             maxAmountsIn: ammLiquidityProvisionAmounts,                                                                                                                                                         │
│             userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),                                                                                         │
│             fromInternalBalance: false                                                                                                                                                                          │
│         });                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Provide TPS/TYS liquidity to TempusAMM                                                                                                                                                               │
│         vault.joinPool(poolId, address(this), recipient, request);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         return ammLiquidityProvisionAmounts;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _depositAndProvideLiquidity(                                                                                                                                                                       │
│         ITempusAMM tempusAMM,                                                                                                                                                                                   │
│         uint256 tokenAmount,                                                                                                                                                                                    │
│         bool isBackingToken                                                                                                                                                                                     │
│     ) private {                                                                                                                                                                                                 │
│         (                                                                                                                                                                                                       │
│             IVault vault,                                                                                                                                                                                       │
│             bytes32 poolId,                                                                                                                                                                                     │
│             IERC20[] memory ammTokens,                                                                                                                                                                          │
│             uint256[] memory ammBalances                                                                                                                                                                        │
│         ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 mintedShares = _deposit(tempusAMM.tempusPool(), tokenAmount, isBackingToken);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256[] memory sharesUsed = _provideLiquidity(                                                                                                                                                        │
│             address(this),                                                                                                                                                                                      │
│             vault,                                                                                                                                                                                              │
│             poolId,                                                                                                                                                                                             │
│             ammTokens,                                                                                                                                                                                          │
│             ammBalances,                                                                                                                                                                                        │
│             mintedShares,                                                                                                                                                                                       │
│             msg.sender                                                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Send remaining Shares to user                                                                                                                                                                        │
│         if (sharesUsed[0] < mintedShares) {                                                                                                                                                                     │
│             ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         if (sharesUsed[1] < mintedShares) {                                                                                                                                                                     │
│             ammTokens[1].safeTransfer(msg.sender, mintedShares - sharesUsed[1]);                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _provideLiquidity(                                                                                                                                                                                 │
│         address sender,                                                                                                                                                                                         │
│         IVault vault,                                                                                                                                                                                           │
│         bytes32 poolId,                                                                                                                                                                                         │
│         IERC20[] memory ammTokens,                                                                                                                                                                              │
│         uint256[] memory ammBalances,                                                                                                                                                                           │
│         uint256 sharesAmount,                                                                                                                                                                                   │
│         address recipient                                                                                                                                                                                       │
│     ) private returns (uint256[] memory) {                                                                                                                                                                      │
│         uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);                                                                                           │
│                                                                                                                                                                                                                 │
│         if (sender != address(this)) {                                                                                                                                                                          │
│             ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);                                                                                                              │
│             ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);                                                                                                              │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);                                                                                                                    │
│         ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);                                                                                                                    │
│                                                                                                                                                                                                                 │
│         IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({                                                                                                                                        │
│             assets: ammTokens,                                                                                                                                                                                  │
│             maxAmountsIn: ammLiquidityProvisionAmounts,                                                                                                                                                         │
│             userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),                                                                                         │
│             fromInternalBalance: false                                                                                                                                                                          │
│         });                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Provide TPS/TYS liquidity to TempusAMM                                                                                                                                                               │
│         vault.joinPool(poolId, address(this), recipient, request);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         return ammLiquidityProvisionAmounts;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _depositAndProvideLiquidity(                                                                                                                                                                       │
│         ITempusAMM tempusAMM,                                                                                                                                                                                   │
│         uint256 tokenAmount,                                                                                                                                                                                    │
│         bool isBackingToken                                                                                                                                                                                     │
│     ) private {                                                                                                                                                                                                 │
│         (                                                                                                                                                                                                       │
│             IVault vault,                                                                                                                                                                                       │
│             bytes32 poolId,                                                                                                                                                                                     │
│             IERC20[] memory ammTokens,                                                                                                                                                                          │
│             uint256[] memory ammBalances                                                                                                                                                                        │
│         ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 mintedShares = _deposit(tempusAMM.tempusPool(), tokenAmount, isBackingToken);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256[] memory sharesUsed = _provideLiquidity(                                                                                                                                                        │
│             address(this),                                                                                                                                                                                      │
│             vault,                                                                                                                                                                                              │
│             poolId,                                                                                                                                                                                             │
│             ammTokens,                                                                                                                                                                                          │
│             ammBalances,                                                                                                                                                                                        │
│             mintedShares,                                                                                                                                                                                       │
│             msg.sender                                                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Send remaining Shares to user                                                                                                                                                                        │
│         if (sharesUsed[0] < mintedShares) {                                                                                                                                                                     │
│             ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         if (sharesUsed[1] < mintedShares) {                                                                                                                                                                     │
│             ammTokens[1].safeTransfer(msg.sender, mintedShares - sharesUsed[1]);                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _provideLiquidity(                                                                                                                                                                                 │
│         address sender,                                                                                                                                                                                         │
│         IVault vault,                                                                                                                                                                                           │
│         bytes32 poolId,                                                                                                                                                                                         │
│         IERC20[] memory ammTokens,                                                                                                                                                                              │
│         uint256[] memory ammBalances,                                                                                                                                                                           │
│         uint256 sharesAmount,                                                                                                                                                                                   │
│         address recipient                                                                                                                                                                                       │
│     ) private returns (uint256[] memory) {                                                                                                                                                                      │
│         uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);                                                                                           │
│                                                                                                                                                                                                                 │
│         if (sender != address(this)) {                                                                                                                                                                          │
│             ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);                                                                                                              │
│             ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);                                                                                                              │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);                                                                                                                    │
│         ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);                                                                                                                    │
│                                                                                                                                                                                                                 │
│         IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({                                                                                                                                        │
│             assets: ammTokens,                                                                                                                                                                                  │
│             maxAmountsIn: ammLiquidityProvisionAmounts,                                                                                                                                                         │
│             userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),                                                                                         │
│             fromInternalBalance: false                                                                                                                                                                          │
│         });                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Provide TPS/TYS liquidity to TempusAMM                                                                                                                                                               │
│         vault.joinPool(poolId, address(this), recipient, request);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         return ammLiquidityProvisionAmounts;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function provideLiquidity(ITempusAMM tempusAMM, uint256 sharesAmount) external nonReentrant {                                                                                                               │
│         (                                                                                                                                                                                                       │
│             IVault vault,                                                                                                                                                                                       │
│             bytes32 poolId,                                                                                                                                                                                     │
│             IERC20[] memory ammTokens,                                                                                                                                                                          │
│             uint256[] memory ammBalances                                                                                                                                                                        │
│         ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _provideLiquidity(msg.sender, vault, poolId, ammTokens, ammBalances, sharesAmount, msg.sender);                                                                                                         │
│     }                                                                                                                                                                                                           │
│     function _provideLiquidity(                                                                                                                                                                                 │
│         address sender,                                                                                                                                                                                         │
│         IVault vault,                                                                                                                                                                                           │
│         bytes32 poolId,                                                                                                                                                                                         │
│         IERC20[] memory ammTokens,                                                                                                                                                                              │
│         uint256[] memory ammBalances,                                                                                                                                                                           │
│         uint256 sharesAmount,                                                                                                                                                                                   │
│         address recipient                                                                                                                                                                                       │
│     ) private returns (uint256[] memory) {                                                                                                                                                                      │
│         uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);                                                                                           │
│                                                                                                                                                                                                                 │
│         if (sender != address(this)) {                                                                                                                                                                          │
│             ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);                                                                                                              │
│             ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);                                                                                                              │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);                                                                                                                    │
│         ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);                                                                                                                    │
│                                                                                                                                                                                                                 │
│         IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({                                                                                                                                        │
│             assets: ammTokens,                                                                                                                                                                                  │
│             maxAmountsIn: ammLiquidityProvisionAmounts,                                                                                                                                                         │
│             userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),                                                                                         │
│             fromInternalBalance: false                                                                                                                                                                          │
│         });                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Provide TPS/TYS liquidity to TempusAMM                                                                                                                                                               │
│         vault.joinPool(poolId, address(this), recipient, request);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         return ammLiquidityProvisionAmounts;                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _depositAndFix(                                                                                                                                                                                    │
│         ITempusAMM tempusAMM,                                                                                                                                                                                   │
│         uint256 tokenAmount,                                                                                                                                                                                    │
│         bool isBackingToken,                                                                                                                                                                                    │
│         uint256 minTYSRate                                                                                                                                                                                      │
│     ) private {                                                                                                                                                                                                 │
│         ITempusPool targetPool = tempusAMM.tempusPool();                                                                                                                                                        │
│         IERC20 principalShares = IERC20(address(targetPool.principalShare()));                                                                                                                                  │
│         IERC20 yieldShares = IERC20(address(targetPool.yieldShare()));                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 swapAmount = _deposit(targetPool, tokenAmount, isBackingToken);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         yieldShares.safeIncreaseAllowance(address(tempusAMM.getVault()), swapAmount);                                                                                                                           │
│         uint256 minReturn = swapAmount.mulfV(minTYSRate, targetPool.backingTokenONE());                                                                                                                         │
│         swap(tempusAMM, swapAmount, yieldShares, principalShares, minReturn);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // At this point all TYS must be swapped for TPS                                                                                                                                                        │
│         uint256 principalsBalance = principalShares.balanceOf(address(this));                                                                                                                                   │
│         assert(principalsBalance > 0);                                                                                                                                                                          │
│         assert(yieldShares.balanceOf(address(this)) == 0);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         principalShares.safeTransfer(msg.sender, principalsBalance);                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _exitTempusAMM(                                                                                                                                                                                    │
│         ITempusAMM tempusAMM,                                                                                                                                                                                   │
│         uint256 lpTokensAmount,                                                                                                                                                                                 │
│         uint256 principalAmountOutMin,                                                                                                                                                                          │
│         uint256 yieldAmountOutMin,                                                                                                                                                                              │
│         bool toInternalBalances                                                                                                                                                                                 │
│     ) private {                                                                                                                                                                                                 │
│         require(tempusAMM.transferFrom(msg.sender, address(this), lpTokensAmount), "LP token transfer failed");                                                                                                 │
│                                                                                                                                                                                                                 │
│         ITempusPool tempusPool = tempusAMM.tempusPool();                                                                                                                                                        │
│         uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalAmountOutMin, yieldAmountOutMin);                                                                                                  │
│         _exitTempusAMMGivenLP(tempusAMM, address(this), msg.sender, lpTokensAmount, amounts, toInternalBalances);                                                                                               │
│                                                                                                                                                                                                                 │
│         assert(tempusAMM.balanceOf(address(this)) == 0);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _exitTempusAMMAndRedeem(                                                                                                                                                                           │
│         ITempusAMM tempusAMM,                                                                                                                                                                                   │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         uint256 principalsStaked,                                                                                                                                                                               │
│         uint256 yieldsStaked,                                                                                                                                                                                   │
│         uint256 maxLpTokensToRedeem,                                                                                                                                                                            │
│         bool toBackingToken                                                                                                                                                                                     │
│     ) private {                                                                                                                                                                                                 │
│         ITempusPool tempusPool = tempusAMM.tempusPool();                                                                                                                                                        │
│         require(!tempusPool.matured(), "Pool already finalized");                                                                                                                                               │
│         principals += principalsStaked;                                                                                                                                                                         │
│         yields += yieldsStaked;                                                                                                                                                                                 │
│         require(principals == yields, "Needs equal amounts of shares before maturity");                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // transfer LP tokens to controller                                                                                                                                                                     │
│         require(tempusAMM.transferFrom(msg.sender, address(this), maxLpTokensToRedeem), "LP token transfer failed");                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalsStaked, yieldsStaked);                                                                                                            │
│         _exitTempusAMMGivenAmountsOut(tempusAMM, address(this), msg.sender, amounts, maxLpTokensToRedeem, false);                                                                                               │
│                                                                                                                                                                                                                 │
│         // transfer remainder of LP tokens back to user                                                                                                                                                         │
│         uint256 lpTokenBalance = tempusAMM.balanceOf(address(this));                                                                                                                                            │
│         require(tempusAMM.transferFrom(address(this), msg.sender, lpTokenBalance), "LP token transfer failed");                                                                                                 │
│                                                                                                                                                                                                                 │
│         if (toBackingToken) {                                                                                                                                                                                   │
│             _redeemToBacking(tempusPool, msg.sender, principals, yields, msg.sender);                                                                                                                           │
│         } else {                                                                                                                                                                                                │
│             _redeemToYieldBearing(tempusPool, msg.sender, principals, yields, msg.sender);                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _exitTempusAmmAndRedeem(                                                                                                                                                                           │
│         ITempusAMM tempusAMM,                                                                                                                                                                                   │
│         uint256 lpTokens,                                                                                                                                                                                       │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         uint256[] memory minLpAmountsOut,                                                                                                                                                                       │
│         uint256 maxLeftoverShares,                                                                                                                                                                              │
│         bool toBackingToken                                                                                                                                                                                     │
│     ) private {                                                                                                                                                                                                 │
│         ITempusPool tempusPool = tempusAMM.tempusPool();                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         IERC20 principalShare = IERC20(address(tempusPool.principalShare()));                                                                                                                                   │
│         IERC20 yieldShare = IERC20(address(tempusPool.yieldShare()));                                                                                                                                           │
│         require(principalShare.transferFrom(msg.sender, address(this), principals), "Principals transfer failed");                                                                                              │
│         require(yieldShare.transferFrom(msg.sender, address(this), yields), "Yields transfer failed");                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (lpTokens > 0) {                                                                                                                                                                                     │
│             // if there is LP balance, transfer to controller                                                                                                                                                   │
│             require(tempusAMM.transferFrom(msg.sender, address(this), lpTokens), "LP token transfer failed");                                                                                                   │
│                                                                                                                                                                                                                 │
│             // exit amm and sent shares to controller                                                                                                                                                           │
│             _exitTempusAMMGivenLP(tempusAMM, address(this), address(this), lpTokens, minLpAmountsOut, false);                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         principals = principalShare.balanceOf(address(this));                                                                                                                                                   │
│         yields = yieldShare.balanceOf(address(this));                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         if (!tempusPool.matured()) {                                                                                                                                                                            │
│             bool yieldsIn = yields > principals;                                                                                                                                                                │
│             uint256 difference = yieldsIn ? (yields - principals) : (principals - yields);                                                                                                                      │
│                                                                                                                                                                                                                 │
│             if (difference >= maxLeftoverShares) {                                                                                                                                                              │
│                 (IERC20 tokenIn, IERC20 tokenOut) = yieldsIn                                                                                                                                                    │
│                     ? (yieldShare, principalShare)                                                                                                                                                              │
│                     : (principalShare, yieldShare);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 swap(                                                                                                                                                                                           │
│                     tempusAMM,                                                                                                                                                                                  │
│                     tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),                                                                                                         │
│                     tokenIn,                                                                                                                                                                                    │
│                     tokenOut,                                                                                                                                                                                   │
│                     0                                                                                                                                                                                           │
│                 );                                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                 principals = principalShare.balanceOf(address(this));                                                                                                                                           │
│                 yields = yieldShare.balanceOf(address(this));                                                                                                                                                   │
│             }                                                                                                                                                                                                   │
│             (yields, principals) = (principals <= yields) ? (principals, principals) : (yields, yields);                                                                                                        │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         if (toBackingToken) {                                                                                                                                                                                   │
│             _redeemToBacking(tempusPool, address(this), principals, yields, msg.sender);                                                                                                                        │
│         } else {                                                                                                                                                                                                │
│             _redeemToYieldBearing(tempusPool, address(this), principals, yields, msg.sender);                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function finalize() external override onlyController {                                                                                                                                                      │
│         if (!matured) {                                                                                                                                                                                         │
│             require(block.timestamp >= maturityTime, "Maturity not been reached yet.");                                                                                                                         │
│             maturityInterestRate = currentInterestRate();                                                                                                                                                       │
│             matured = true;                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             assert(IERC20(address(principalShare)).totalSupply() == IERC20(address(yieldShare)).totalSupply());                                                                                                 │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No",                                                                                                                                                                                                  │
│     "3": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function depositBacking(uint256 backingTokenAmount, address recipient)                                                                                                                                      │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedYBT,                                                                                                                                                                               │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(backingTokenAmount > 0, "backingTokenAmount must be greater than 0");                                                                                                                           │
│                                                                                                                                                                                                                 │
│         depositedYBT = depositToUnderlying(backingTokenAmount);                                                                                                                                                 │
│         assert(depositedYBT > 0);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (mintedShares, , fee, rate) = _deposit(depositedYBT, recipient);                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                               │
│         external                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedBT,                                                                                                                                                                                │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(yieldTokenAmount > 0, "yieldTokenAmount must be greater than 0");                                                                                                                               │
│         // Collect the deposit                                                                                                                                                                                  │
│         yieldTokenAmount = IERC20(yieldBearingToken).untrustedTransferFrom(msg.sender, address(this), yieldTokenAmount);                                                                                        │
│                                                                                                                                                                                                                 │
│         (mintedShares, depositedBT, fee, rate) = _deposit(yieldTokenAmount, recipient);                                                                                                                         │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                              │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedBT,                                                                                                                                                                                │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(!matured, "Maturity reached.");                                                                                                                                                                 │
│         rate = updateInterestRate();                                                                                                                                                                            │
│         require(rate >= initialInterestRate, "Negative yield!");                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Collect fees if they are set, reducing the number of tokens for the sender                                                                                                                           │
│         // thus leaving more YBT in the TempusPool than there are minted TPS/TYS                                                                                                                                │
│         uint256 tokenAmount = yieldTokenAmount;                                                                                                                                                                 │
│         uint256 depositFees = feesConfig.depositPercent;                                                                                                                                                        │
│         if (depositFees != 0) {                                                                                                                                                                                 │
│             fee = tokenAmount.mulfV(depositFees, yieldBearingONE);                                                                                                                                              │
│             tokenAmount -= fee;                                                                                                                                                                                 │
│             totalFees += fee;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Issue appropriate shares                                                                                                                                                                             │
│         depositedBT = numAssetsPerYieldToken(tokenAmount, rate);                                                                                                                                                │
│         mintedShares = numSharesToMint(depositedBT, rate);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         PrincipalShare(address(principalShare)).mint(recipient, mintedShares);                                                                                                                                  │
│         YieldShare(address(yieldShare)).mint(recipient, mintedShares);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function _deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                              │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedBT,                                                                                                                                                                                │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(!matured, "Maturity reached.");                                                                                                                                                                 │
│         rate = updateInterestRate();                                                                                                                                                                            │
│         require(rate >= initialInterestRate, "Negative yield!");                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Collect fees if they are set, reducing the number of tokens for the sender                                                                                                                           │
│         // thus leaving more YBT in the TempusPool than there are minted TPS/TYS                                                                                                                                │
│         uint256 tokenAmount = yieldTokenAmount;                                                                                                                                                                 │
│         uint256 depositFees = feesConfig.depositPercent;                                                                                                                                                        │
│         if (depositFees != 0) {                                                                                                                                                                                 │
│             fee = tokenAmount.mulfV(depositFees, yieldBearingONE);                                                                                                                                              │
│             tokenAmount -= fee;                                                                                                                                                                                 │
│             totalFees += fee;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Issue appropriate shares                                                                                                                                                                             │
│         depositedBT = numAssetsPerYieldToken(tokenAmount, rate);                                                                                                                                                │
│         mintedShares = numSharesToMint(depositedBT, rate);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         PrincipalShare(address(principalShare)).mint(recipient, mintedShares);                                                                                                                                  │
│         YieldShare(address(yieldShare)).mint(recipient, mintedShares);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function redeemToBacking(                                                                                                                                                                                   │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         address recipient                                                                                                                                                                                       │
│     )                                                                                                                                                                                                           │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 redeemedBackingTokens,                                                                                                                                                                      │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                      │
│                                                                                                                                                                                                                 │
│         redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);                                                                                                                 │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function redeem(                                                                                                                                                                                            │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         address recipient                                                                                                                                                                                       │
│     )                                                                                                                                                                                                           │
│         external                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                      │
│                                                                                                                                                                                                                 │
│         redeemedYieldTokens = IERC20(yieldBearingToken).untrustedTransfer(recipient, redeemedYieldTokens);                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function redeem(                                                                                                                                                                                            │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         address recipient                                                                                                                                                                                       │
│     )                                                                                                                                                                                                           │
│         external                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                      │
│                                                                                                                                                                                                                 │
│         redeemedYieldTokens = IERC20(yieldBearingToken).untrustedTransfer(recipient, redeemedYieldTokens);                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function redeemToBacking(                                                                                                                                                                                   │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         address recipient                                                                                                                                                                                       │
│     )                                                                                                                                                                                                           │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 redeemedBackingTokens,                                                                                                                                                                      │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                      │
│                                                                                                                                                                                                                 │
│         redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function redeemToBacking(                                                                                                                                                                                   │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         address recipient                                                                                                                                                                                       │
│     )                                                                                                                                                                                                           │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 redeemedBackingTokens,                                                                                                                                                                      │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                      │
│                                                                                                                                                                                                                 │
│         redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function getRedemptionAmounts(                                                                                                                                                                              │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         uint256 currentRate                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemableYieldTokens,                                                                                                                                                                      │
│             uint256 redeemableBackingTokens,                                                                                                                                                                    │
│             uint256 redeemFeeAmount,                                                                                                                                                                            │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (interestRate < initialInterestRate) {                                                                                                                                                               │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                              │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                         │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                        │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                               │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                            │
│                                                                                                                                                                                                                 │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                   │
│             if (matured && currentRate > interestRate) {                                                                                                                                                        │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                       │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                   │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                            │
│                     exchangeRateONE                                                                                                                                                                             │
│                 );                                                                                                                                                                                              │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                        │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                    │
│         if (redeemFeePercent != 0) {                                                                                                                                                                            │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                          │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                          │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                               │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function getRedemptionAmounts(                                                                                                                                                                              │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         uint256 currentRate                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemableYieldTokens,                                                                                                                                                                      │
│             uint256 redeemableBackingTokens,                                                                                                                                                                    │
│             uint256 redeemFeeAmount,                                                                                                                                                                            │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (interestRate < initialInterestRate) {                                                                                                                                                               │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                              │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                         │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                        │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                               │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                            │
│                                                                                                                                                                                                                 │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                   │
│             if (matured && currentRate > interestRate) {                                                                                                                                                        │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                       │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                   │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                            │
│                     exchangeRateONE                                                                                                                                                                             │
│                 );                                                                                                                                                                                              │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                        │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                    │
│         if (redeemFeePercent != 0) {                                                                                                                                                                            │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                          │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                          │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                               │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function getRedemptionAmounts(                                                                                                                                                                              │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         uint256 currentRate                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemableYieldTokens,                                                                                                                                                                      │
│             uint256 redeemableBackingTokens,                                                                                                                                                                    │
│             uint256 redeemFeeAmount,                                                                                                                                                                            │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (interestRate < initialInterestRate) {                                                                                                                                                               │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                              │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                         │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                        │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                               │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                            │
│                                                                                                                                                                                                                 │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                   │
│             if (matured && currentRate > interestRate) {                                                                                                                                                        │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                       │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                   │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                            │
│                     exchangeRateONE                                                                                                                                                                             │
│                 );                                                                                                                                                                                              │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                        │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                    │
│         if (redeemFeePercent != 0) {                                                                                                                                                                            │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                          │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                          │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                               │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function getRedemptionAmounts(                                                                                                                                                                              │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         uint256 currentRate                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemableYieldTokens,                                                                                                                                                                      │
│             uint256 redeemableBackingTokens,                                                                                                                                                                    │
│             uint256 redeemFeeAmount,                                                                                                                                                                            │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (interestRate < initialInterestRate) {                                                                                                                                                               │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                              │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                         │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                        │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                               │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                            │
│                                                                                                                                                                                                                 │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                   │
│             if (matured && currentRate > interestRate) {                                                                                                                                                        │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                       │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                   │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                            │
│                     exchangeRateONE                                                                                                                                                                             │
│                 );                                                                                                                                                                                              │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                        │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                    │
│         if (redeemFeePercent != 0) {                                                                                                                                                                            │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                          │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                          │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                               │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function estimatedRedeem(                                                                                                                                                                                   │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         bool toBackingToken                                                                                                                                                                                     │
│     ) public view override returns (uint256) {                                                                                                                                                                  │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                            │
│         (uint256 yieldTokens, uint256 backingTokens, , ) = getRedemptionAmounts(principals, yields, currentRate);                                                                                               │
│         return toBackingToken ? backingTokens : yieldTokens;                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function getRedemptionAmounts(                                                                                                                                                                              │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         uint256 currentRate                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemableYieldTokens,                                                                                                                                                                      │
│             uint256 redeemableBackingTokens,                                                                                                                                                                    │
│             uint256 redeemFeeAmount,                                                                                                                                                                            │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (interestRate < initialInterestRate) {                                                                                                                                                               │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                              │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                         │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                        │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                               │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                            │
│                                                                                                                                                                                                                 │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                   │
│             if (matured && currentRate > interestRate) {                                                                                                                                                        │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                       │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                   │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                            │
│                     exchangeRateONE                                                                                                                                                                             │
│                 );                                                                                                                                                                                              │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                        │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                    │
│         if (redeemFeePercent != 0) {                                                                                                                                                                            │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                          │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                          │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                               │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function estimatedRedeem(                                                                                                                                                                                   │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         bool toBackingToken                                                                                                                                                                                     │
│     ) public view override returns (uint256) {                                                                                                                                                                  │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                            │
│         (uint256 yieldTokens, uint256 backingTokens, , ) = getRedemptionAmounts(principals, yields, currentRate);                                                                                               │
│         return toBackingToken ? backingTokens : yieldTokens;                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function getRedemptionAmounts(                                                                                                                                                                              │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         uint256 currentRate                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemableYieldTokens,                                                                                                                                                                      │
│             uint256 redeemableBackingTokens,                                                                                                                                                                    │
│             uint256 redeemFeeAmount,                                                                                                                                                                            │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (interestRate < initialInterestRate) {                                                                                                                                                               │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                              │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                         │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                        │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                               │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                            │
│                                                                                                                                                                                                                 │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                   │
│             if (matured && currentRate > interestRate) {                                                                                                                                                        │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                       │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                   │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                            │
│                     exchangeRateONE                                                                                                                                                                             │
│                 );                                                                                                                                                                                              │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                        │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                    │
│         if (redeemFeePercent != 0) {                                                                                                                                                                            │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                          │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                          │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                               │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                              │
│         if (matured) {                                                                                                                                                                                          │
│             return yieldCurrent;                                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                  │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                               │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                        │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                              │
│         if (matured) {                                                                                                                                                                                          │
│             return yieldCurrent;                                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                  │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                               │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                        │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                       │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                       │
│             return interestRateToSharePrice(currYield);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                    │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                              │
│         if (matured) {                                                                                                                                                                                          │
│             return yieldCurrent;                                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                  │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                               │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                        │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                       │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                       │
│             return interestRateToSharePrice(currYield);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                    │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                              │
│         if (matured) {                                                                                                                                                                                          │
│             return yieldCurrent;                                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                  │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                               │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                        │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                           │
│         uint one = exchangeRateONE;                                                                                                                                                                             │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < one) {                                                                                                                                                                                   │
│             return uint256(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                       │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                              │
│         if (matured) {                                                                                                                                                                                          │
│             return yieldCurrent;                                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                  │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                               │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                        │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                           │
│         uint one = exchangeRateONE;                                                                                                                                                                             │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < one) {                                                                                                                                                                                   │
│             return uint256(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                       │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {                                                                                                                              │
│         if (matured) {                                                                                                                                                                                          │
│             return yieldCurrent;                                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│         uint256 currentTime = block.timestamp;                                                                                                                                                                  │
│         uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;                                                                                                               │
│         uint256 poolDuration = maturityTime - startTime;                                                                                                                                                        │
│         uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                           │
│         uint one = exchangeRateONE;                                                                                                                                                                             │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < one) {                                                                                                                                                                                   │
│             return uint256(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                       │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                           │
│         uint one = exchangeRateONE;                                                                                                                                                                             │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < one) {                                                                                                                                                                                   │
│             return uint256(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                       │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes.                                                                                                                                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                           │
│         uint one = exchangeRateONE;                                                                                                                                                                             │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < one) {                                                                                                                                                                                   │
│             return uint256(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                       │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                           │
│         uint one = exchangeRateONE;                                                                                                                                                                             │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < one) {                                                                                                                                                                                   │
│             return uint256(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                       │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                           │
│         uint one = exchangeRateONE;                                                                                                                                                                             │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < one) {                                                                                                                                                                                   │
│             return uint256(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                       │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                           │
│         uint one = exchangeRateONE;                                                                                                                                                                             │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < one) {                                                                                                                                                                                   │
│             return uint256(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);                                                                                                                       │
│         return interestRateToSharePrice(yieldPrice);                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                       │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                       │
│             return interestRateToSharePrice(currYield);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                    │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                       │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                       │
│             return interestRateToSharePrice(currYield);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                    │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                       │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                       │
│             return interestRateToSharePrice(currYield);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                    │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                       │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                       │
│             return interestRateToSharePrice(currYield);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                    │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                       │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                       │
│             return interestRateToSharePrice(currYield);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                    │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {                                                                                                       │
│         // in case we have estimate for negative yield                                                                                                                                                          │
│         if (estYield < exchangeRateONE) {                                                                                                                                                                       │
│             return interestRateToSharePrice(currYield);                                                                                                                                                         │
│         }                                                                                                                                                                                                       │
│         uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);                                                                                                                                    │
│         return interestRateToSharePrice(principalPrice);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function estimatedMintedShares(uint256 amount, bool isBackingToken) public view override returns (uint256) {                                                                                                │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                            │
│         uint256 depositedBT = isBackingToken ? amount : numAssetsPerYieldToken(amount, currentRate);                                                                                                            │
│         return numSharesToMint(depositedBT, currentRate);                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function estimatedMintedShares(uint256 amount, bool isBackingToken) public view override returns (uint256) {                                                                                                │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                            │
│         uint256 depositedBT = isBackingToken ? amount : numAssetsPerYieldToken(amount, currentRate);                                                                                                            │
│         return numSharesToMint(depositedBT, currentRate);                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function estimatedRedeem(                                                                                                                                                                                   │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         bool toBackingToken                                                                                                                                                                                     │
│     ) public view override returns (uint256) {                                                                                                                                                                  │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                            │
│         (uint256 yieldTokens, uint256 backingTokens, , ) = getRedemptionAmounts(principals, yields, currentRate);                                                                                               │
│         return toBackingToken ? backingTokens : yieldTokens;                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function estimatedRedeem(                                                                                                                                                                                   │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         bool toBackingToken                                                                                                                                                                                     │
│     ) public view override returns (uint256) {                                                                                                                                                                  │
│         uint256 currentRate = currentInterestRate();                                                                                                                                                            │
│         (uint256 yieldTokens, uint256 backingTokens, , ) = getRedemptionAmounts(principals, yields, currentRate);                                                                                               │
│         return toBackingToken ? backingTokens : yieldTokens;                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                 │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                     │
│         totalShares = newTotalShares;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                             │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                               │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                           │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                            │
│         // number of events.                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                 │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                     │
│         totalShares = newTotalShares;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                             │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                               │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                           │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                            │
│         // number of events.                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _submit(                                                                                                                                                                                           │
│         address /*_referral*/                                                                                                                                                                                   │
│     ) internal returns (uint256) {                                                                                                                                                                              │
│         if (mockFailNextDepositOrRedeem) {                                                                                                                                                                      │
│             setFailNextDepositOrRedeem(false);                                                                                                                                                                  │
│             revert("random mock failure from lido");                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address sender = msg.sender;                                                                                                                                                                            │
│         uint256 deposit = msg.value;                                                                                                                                                                            │
│         require(deposit != 0, "ZERO_DEPOSIT");                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint256 sharesAmount = StETH.getSharesByPooledEth(deposit);                                                                                                                                             │
│         if (sharesAmount == 0) {                                                                                                                                                                                │
│             // totalControlledEther is 0: either the first-ever deposit or complete slashing                                                                                                                    │
│             // assume that shares correspond to Ether 1-to-1                                                                                                                                                    │
│             sharesAmount = deposit;                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _mintShares(sender, sharesAmount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Store for submission                                                                                                                                                                                 │
│         bufferedEther += deposit;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return sharesAmount;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                 │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                     │
│         totalShares = newTotalShares;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                             │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                               │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                           │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                            │
│         // number of events.                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _submit(                                                                                                                                                                                           │
│         address /*_referral*/                                                                                                                                                                                   │
│     ) internal returns (uint256) {                                                                                                                                                                              │
│         if (mockFailNextDepositOrRedeem) {                                                                                                                                                                      │
│             setFailNextDepositOrRedeem(false);                                                                                                                                                                  │
│             revert("random mock failure from lido");                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         address sender = msg.sender;                                                                                                                                                                            │
│         uint256 deposit = msg.value;                                                                                                                                                                            │
│         require(deposit != 0, "ZERO_DEPOSIT");                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint256 sharesAmount = StETH.getSharesByPooledEth(deposit);                                                                                                                                             │
│         if (sharesAmount == 0) {                                                                                                                                                                                │
│             // totalControlledEther is 0: either the first-ever deposit or complete slashing                                                                                                                    │
│             // assume that shares correspond to Ether 1-to-1                                                                                                                                                    │
│             sharesAmount = deposit;                                                                                                                                                                             │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _mintShares(sender, sharesAmount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Store for submission                                                                                                                                                                                 │
│         bufferedEther += deposit;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return sharesAmount;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                 │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                     │
│         totalShares = newTotalShares;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                             │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                               │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                           │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                            │
│         // number of events.                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function distributeRewards(uint256 _totalRewards) internal {                                                                                                                                                │
│         uint256 fees = _totalRewards * feeBasis;                                                                                                                                                                │
│         uint256 sharesToMint = (fees * _getTotalShares()) / ((_getTotalPooledEther() * 1000) - fees);                                                                                                           │
│         _mintShares(address(this), sharesToMint);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Transfer to insurance fund                                                                                                                                                                           │
│         // Transfer to treasury                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                 │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                     │
│         totalShares = newTotalShares;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                             │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                               │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                           │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                            │
│         // number of events.                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function distributeRewards(uint256 _totalRewards) internal {                                                                                                                                                │
│         uint256 fees = _totalRewards * feeBasis;                                                                                                                                                                │
│         uint256 sharesToMint = (fees * _getTotalShares()) / ((_getTotalPooledEther() * 1000) - fees);                                                                                                           │
│         _mintShares(address(this), sharesToMint);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Transfer to insurance fund                                                                                                                                                                           │
│         // Transfer to treasury                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                 │
│         require(_recipient != address(0), "MINT_TO_THE_ZERO_ADDRESS");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         newTotalShares = _getTotalShares() + _sharesAmount;                                                                                                                                                     │
│         totalShares = newTotalShares;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         shares[_recipient] = shares[_recipient] + _sharesAmount;                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Notice: we're not emitting a Transfer event from the zero address here since shares mint                                                                                                             │
│         // works by taking the amount of tokens corresponding to the minted shares from all other                                                                                                               │
│         // token holders, proportionally to their share. The total supply of the token doesn't change                                                                                                           │
│         // as the result. This is equivalent to performing a send from each other token holder's                                                                                                                │
│         // address to `address`, but we cannot reflect this as it would require sending an unbounded                                                                                                            │
│         // number of events.                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                   │
│         require(_account != address(0), "BURN_FROM_THE_ZERO_ADDRESS");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 accountShares = shares[_account];                                                                                                                                                               │
│         require(_sharesAmount <= accountShares, "BURN_AMOUNT_EXCEEDS_BALANCE");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         newTotalShares = _getTotalShares() - _sharesAmount;                                                                                                                                                     │
│         totalShares = newTotalShares;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         shares[_account] = accountShares - _sharesAmount;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Notice: we're not emitting a Transfer event to the zero address here since shares burn                                                                                                               │
│         // works by redistributing the amount of tokens corresponding to the burned shares between                                                                                                              │
│         // all other token holders. The total supply of the token doesn't change as the result.                                                                                                                 │
│         // This is equivalent to performing a send from `address` to each other token holder address,                                                                                                           │
│         // but we cannot reflect this as it would require sending an unbounded number of events.                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function withdraw(                                                                                                                                                                                          │
│         uint256 _amount,                                                                                                                                                                                        │
│         bytes32 /*_pubkeyHash*/                                                                                                                                                                                 │
│     ) external {                                                                                                                                                                                                │
│         if (mockFailNextDepositOrRedeem) {                                                                                                                                                                      │
│             setFailNextDepositOrRedeem(false);                                                                                                                                                                  │
│             revert("random mock failure from lido");                                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 redeemable = StETH.getPooledEthByShares(_amount);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Simplification: only allow withdrawing buffered ether.                                                                                                                                               │
│         require(redeemable <= bufferedEther, "Can only withdraw up to the buffered ether.");                                                                                                                    │
│                                                                                                                                                                                                                 │
│         // This validates that enough shares are owned by the account.                                                                                                                                          │
│         _burnShares(msg.sender, _amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         payable(msg.sender).transfer(redeemable);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {                                                                                                   │
│         require(_account != address(0), "BURN_FROM_THE_ZERO_ADDRESS");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         uint256 accountShares = shares[_account];                                                                                                                                                               │
│         require(_sharesAmount <= accountShares, "BURN_AMOUNT_EXCEEDS_BALANCE");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         newTotalShares = _getTotalShares() - _sharesAmount;                                                                                                                                                     │
│         totalShares = newTotalShares;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│         shares[_account] = accountShares - _sharesAmount;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Notice: we're not emitting a Transfer event to the zero address here since shares burn                                                                                                               │
│         // works by redistributing the amount of tokens corresponding to the burned shares between                                                                                                              │
│         // all other token holders. The total supply of the token doesn't change as the result.                                                                                                                 │
│         // This is equivalent to performing a send from `address` to each other token holder address,                                                                                                           │
│         // but we cannot reflect this as it would require sending an unbounded number of events.                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function mintFresh(address minter, uint mintAmount) internal returns (uint errorCode, uint actualMintAmount) {                                                                                              │
│         uint err = comptroller.mintAllowed(address(this), minter, mintAmount);                                                                                                                                  │
│         require(err == 0, "mint is not allowed");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint exchangeRate = exchangeRateStored(); // exchangeRate has variable decimal precision                                                                                                                │
│                                                                                                                                                                                                                 │
│         /*                                                                                                                                                                                                      │
│          *  We call `doTransferIn` for the minter and the mintAmount.                                                                                                                                           │
│          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.                                                                                                                          │
│          *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if                                                                                                                            │
│          *  side-effects occurred. The function returns the amount actually transferred,                                                                                                                        │
│          *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`                                                                                                                     │
│          *  of cash.                                                                                                                                                                                            │
│          */                                                                                                                                                                                                     │
│         actualMintAmount = doTransferIn(minter, mintAmount); // 18 decimal precision                                                                                                                            │
│                                                                                                                                                                                                                 │
│         // exchange rate precision: 18 - 8 + Underlying Token Decimals                                                                                                                                          │
│         uint mintTokens = (actualMintAmount * 1e18) / exchangeRate; // (18 + 18) - 28 = 8 decimal precision                                                                                                     │
│         _mint(minter, mintTokens);                                                                                                                                                                              │
│         errorCode = 0;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function mintFresh(address minter, uint mintAmount) internal returns (uint errorCode, uint actualMintAmount) {                                                                                              │
│         uint err = comptroller.mintAllowed(address(this), minter, mintAmount);                                                                                                                                  │
│         require(err == 0, "mint is not allowed");                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint exchangeRate = exchangeRateStored(); // exchangeRate has variable decimal precision                                                                                                                │
│                                                                                                                                                                                                                 │
│         /*                                                                                                                                                                                                      │
│          *  We call `doTransferIn` for the minter and the mintAmount.                                                                                                                                           │
│          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.                                                                                                                          │
│          *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if                                                                                                                            │
│          *  side-effects occurred. The function returns the amount actually transferred,                                                                                                                        │
│          *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`                                                                                                                     │
│          *  of cash.                                                                                                                                                                                            │
│          */                                                                                                                                                                                                     │
│         actualMintAmount = doTransferIn(minter, mintAmount); // 18 decimal precision                                                                                                                            │
│                                                                                                                                                                                                                 │
│         // exchange rate precision: 18 - 8 + Underlying Token Decimals                                                                                                                                          │
│         uint mintTokens = (actualMintAmount * 1e18) / exchangeRate; // (18 + 18) - 28 = 8 decimal precision                                                                                                     │
│         _mint(minter, mintTokens);                                                                                                                                                                              │
│         errorCode = 0;                                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function redeem(uint redeemTokens) external override returns (uint) {                                                                                                                                       │
│         ComptrollerMock mock = ComptrollerMock(address(comptroller));                                                                                                                                           │
│         if (mock.mockFailNextDepositOrRedeem()) {                                                                                                                                                               │
│             mock.setFailNextDepositOrRedeem(false);                                                                                                                                                             │
│             return 1;                                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Amount of underlying asset to be redeemed:                                                                                                                                                           │
│         //  redeemAmount = redeemTokens x exchangeRate                                                                                                                                                          │
│         uint256 exchangeRate = exchangeRateStored();                                                                                                                                                            │
│         uint256 redeemAmount = (redeemTokens * exchangeRate) / 1e18;                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         // burn the yield tokens                                                                                                                                                                                │
│         _burn(msg.sender, redeemTokens);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         // transfer backing tokens to redeemer                                                                                                                                                                  │
│         IERC20(underlying).safeTransfer(msg.sender, redeemAmount);                                                                                                                                              │
│         return 0; // success                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositToUnderlying(uint256 backingAmount) internal override returns (uint256) {                                                                                                                   │
│         require(msg.value == 0, "ETH deposits not supported");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Pull user's Backing Tokens                                                                                                                                                                           │
│         backingAmount = IERC20(backingToken).untrustedTransferFrom(msg.sender, address(this), backingAmount);                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Deposit to Compound                                                                                                                                                                                  │
│         IERC20(backingToken).safeIncreaseAllowance(address(cToken), backingAmount);                                                                                                                             │
│         require(cToken.mint(backingAmount) == 0, "CErc20 mint failed");                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositBacking(uint256 backingTokenAmount, address recipient)                                                                                                                                      │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedYBT,                                                                                                                                                                               │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(backingTokenAmount > 0, "backingTokenAmount must be greater than 0");                                                                                                                           │
│                                                                                                                                                                                                                 │
│         depositedYBT = depositToUnderlying(backingTokenAmount);                                                                                                                                                 │
│         assert(depositedYBT > 0);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (mintedShares, , fee, rate) = _deposit(depositedYBT, recipient);                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function depositToUnderlying(uint256 backingAmount) internal override returns (uint256) {                                                                                                                   │
│         require(msg.value == 0, "ETH deposits not supported");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Pull user's Backing Tokens                                                                                                                                                                           │
│         backingAmount = IERC20(backingToken).untrustedTransferFrom(msg.sender, address(this), backingAmount);                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Deposit to Compound                                                                                                                                                                                  │
│         IERC20(backingToken).safeIncreaseAllowance(address(cToken), backingAmount);                                                                                                                             │
│         require(cToken.mint(backingAmount) == 0, "CErc20 mint failed");                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function depositBacking(uint256 backingTokenAmount, address recipient)                                                                                                                                      │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedYBT,                                                                                                                                                                               │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(backingTokenAmount > 0, "backingTokenAmount must be greater than 0");                                                                                                                           │
│                                                                                                                                                                                                                 │
│         depositedYBT = depositToUnderlying(backingTokenAmount);                                                                                                                                                 │
│         assert(depositedYBT > 0);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (mintedShares, , fee, rate) = _deposit(depositedYBT, recipient);                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function depositToUnderlying(uint256 backingAmount) internal override returns (uint256) {                                                                                                                   │
│         require(msg.value == 0, "ETH deposits not supported");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Pull user's Backing Tokens                                                                                                                                                                           │
│         backingAmount = IERC20(backingToken).untrustedTransferFrom(msg.sender, address(this), backingAmount);                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Deposit to Compound                                                                                                                                                                                  │
│         IERC20(backingToken).safeIncreaseAllowance(address(cToken), backingAmount);                                                                                                                             │
│         require(cToken.mint(backingAmount) == 0, "CErc20 mint failed");                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         // tempus pool owns YBT                                                                                                                                                                                 │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                    │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                           │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                               │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         // tempus pool owns YBT                                                                                                                                                                                 │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                    │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                           │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                               │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function redeemToBacking(                                                                                                                                                                                   │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         address recipient                                                                                                                                                                                       │
│     )                                                                                                                                                                                                           │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 redeemedBackingTokens,                                                                                                                                                                      │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                      │
│                                                                                                                                                                                                                 │
│         redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         // tempus pool owns YBT                                                                                                                                                                                 │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                    │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                           │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                               │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function redeemToBacking(                                                                                                                                                                                   │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         address recipient                                                                                                                                                                                       │
│     )                                                                                                                                                                                                           │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 redeemedBackingTokens,                                                                                                                                                                      │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);                                                                                                                      │
│                                                                                                                                                                                                                 │
│         redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         // tempus pool owns YBT                                                                                                                                                                                 │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                    │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                           │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                               │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositToUnderlying(uint256 amount) internal override returns (uint256) {                                                                                                                          │
│         require(msg.value == amount, "ETH value does not match provided amount");                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                         │
│         lido.submit{value: msg.value}(referrer);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         /// TODO: figure out why lido.submit returns a different value than this                                                                                                                                │
│         uint256 mintedTokens = IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                          │
│                                                                                                                                                                                                                 │
│         return mintedTokens;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function depositBacking(uint256 backingTokenAmount, address recipient)                                                                                                                                      │
│         external                                                                                                                                                                                                │
│         payable                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         onlyController                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedYBT,                                                                                                                                                                               │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(backingTokenAmount > 0, "backingTokenAmount must be greater than 0");                                                                                                                           │
│                                                                                                                                                                                                                 │
│         depositedYBT = depositToUnderlying(backingTokenAmount);                                                                                                                                                 │
│         assert(depositedYBT > 0);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (mintedShares, , fee, rate) = _deposit(depositedYBT, recipient);                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function depositToUnderlying(uint256 amount) internal override returns (uint256) {                                                                                                                          │
│         require(msg.value == amount, "ETH value does not match provided amount");                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));                                                                                                                         │
│         lido.submit{value: msg.value}(referrer);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         /// TODO: figure out why lido.submit returns a different value than this                                                                                                                                │
│         uint256 mintedTokens = IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;                                                                                                          │
│                                                                                                                                                                                                                 │
│         return mintedTokens;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                        │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                            │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                           │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                           │
│                                                                                                                                                                                                                 │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                          │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                        │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                              │
│                                                                                                                                                                                                                 │
│         return amountOut;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function getSwapAmountToEndWithEqualShares(                                                                                                                                                                 │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         uint256 threshold                                                                                                                                                                                       │
│     ) public view returns (uint256 amountIn) {                                                                                                                                                                  │
│         (uint256 difference, bool yieldsIn) = (principals > yields)                                                                                                                                             │
│             ? (principals - yields, false)                                                                                                                                                                      │
│             : (yields - principals, true);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (difference > threshold) {                                                                                                                                                                           │
│             uint256 principalsRate = tempusPool.principalShare().getPricePerFullShareStored();                                                                                                                  │
│             uint256 yieldsRate = tempusPool.yieldShare().getPricePerFullShareStored();                                                                                                                          │
│                                                                                                                                                                                                                 │
│             uint256 rate = yieldsIn                                                                                                                                                                             │
│                 ? (principalsRate * _TEMPUS_SHARE_PRECISION) / yieldsRate                                                                                                                                       │
│                 : (yieldsRate * _TEMPUS_SHARE_PRECISION) / principalsRate;                                                                                                                                      │
│             for (uint8 i = 0; i < 32; i++) {                                                                                                                                                                    │
│                 // if we have accurate rate this should hold                                                                                                                                                    │
│                 amountIn = (difference * _TEMPUS_SHARE_PRECISION) / (rate + _TEMPUS_SHARE_PRECISION);                                                                                                           │
│                 uint256 amountOut = getExpectedReturnGivenIn(amountIn, yieldsIn);                                                                                                                               │
│                 uint256 newPrincipals = yieldsIn ? (principals + amountOut) : (principals - amountIn);                                                                                                          │
│                 uint256 newYields = yieldsIn ? (yields - amountIn) : (yields + amountOut);                                                                                                                      │
│                 uint256 newDifference = (newPrincipals > newYields)                                                                                                                                             │
│                     ? (newPrincipals - newYields)                                                                                                                                                               │
│                     : (newYields - newPrincipals);                                                                                                                                                              │
│                 if (newDifference < threshold) {                                                                                                                                                                │
│                     return amountIn;                                                                                                                                                                            │
│                 } else {                                                                                                                                                                                        │
│                     rate = (amountOut * _TEMPUS_SHARE_PRECISION) / amountIn;                                                                                                                                    │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│             revert("getSwapAmountToEndWithEqualShares did not converge.");                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                        │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                            │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                           │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                           │
│                                                                                                                                                                                                                 │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                          │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                        │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                              │
│                                                                                                                                                                                                                 │
│         return amountOut;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function getSwapAmountToEndWithEqualShares(                                                                                                                                                                 │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         uint256 threshold                                                                                                                                                                                       │
│     ) public view returns (uint256 amountIn) {                                                                                                                                                                  │
│         (uint256 difference, bool yieldsIn) = (principals > yields)                                                                                                                                             │
│             ? (principals - yields, false)                                                                                                                                                                      │
│             : (yields - principals, true);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (difference > threshold) {                                                                                                                                                                           │
│             uint256 principalsRate = tempusPool.principalShare().getPricePerFullShareStored();                                                                                                                  │
│             uint256 yieldsRate = tempusPool.yieldShare().getPricePerFullShareStored();                                                                                                                          │
│                                                                                                                                                                                                                 │
│             uint256 rate = yieldsIn                                                                                                                                                                             │
│                 ? (principalsRate * _TEMPUS_SHARE_PRECISION) / yieldsRate                                                                                                                                       │
│                 : (yieldsRate * _TEMPUS_SHARE_PRECISION) / principalsRate;                                                                                                                                      │
│             for (uint8 i = 0; i < 32; i++) {                                                                                                                                                                    │
│                 // if we have accurate rate this should hold                                                                                                                                                    │
│                 amountIn = (difference * _TEMPUS_SHARE_PRECISION) / (rate + _TEMPUS_SHARE_PRECISION);                                                                                                           │
│                 uint256 amountOut = getExpectedReturnGivenIn(amountIn, yieldsIn);                                                                                                                               │
│                 uint256 newPrincipals = yieldsIn ? (principals + amountOut) : (principals - amountIn);                                                                                                          │
│                 uint256 newYields = yieldsIn ? (yields - amountIn) : (yields + amountOut);                                                                                                                      │
│                 uint256 newDifference = (newPrincipals > newYields)                                                                                                                                             │
│                     ? (newPrincipals - newYields)                                                                                                                                                               │
│                     : (newYields - newPrincipals);                                                                                                                                                              │
│                 if (newDifference < threshold) {                                                                                                                                                                │
│                     return amountIn;                                                                                                                                                                            │
│                 } else {                                                                                                                                                                                        │
│                     rate = (amountOut * _TEMPUS_SHARE_PRECISION) / amountIn;                                                                                                                                    │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│             revert("getSwapAmountToEndWithEqualShares did not converge.");                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                        │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                            │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                           │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                           │
│                                                                                                                                                                                                                 │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                          │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                        │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                              │
│                                                                                                                                                                                                                 │
│         return amountOut;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function getSwapAmountToEndWithEqualShares(                                                                                                                                                                 │
│         uint256 principals,                                                                                                                                                                                     │
│         uint256 yields,                                                                                                                                                                                         │
│         uint256 threshold                                                                                                                                                                                       │
│     ) public view returns (uint256 amountIn) {                                                                                                                                                                  │
│         (uint256 difference, bool yieldsIn) = (principals > yields)                                                                                                                                             │
│             ? (principals - yields, false)                                                                                                                                                                      │
│             : (yields - principals, true);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         if (difference > threshold) {                                                                                                                                                                           │
│             uint256 principalsRate = tempusPool.principalShare().getPricePerFullShareStored();                                                                                                                  │
│             uint256 yieldsRate = tempusPool.yieldShare().getPricePerFullShareStored();                                                                                                                          │
│                                                                                                                                                                                                                 │
│             uint256 rate = yieldsIn                                                                                                                                                                             │
│                 ? (principalsRate * _TEMPUS_SHARE_PRECISION) / yieldsRate                                                                                                                                       │
│                 : (yieldsRate * _TEMPUS_SHARE_PRECISION) / principalsRate;                                                                                                                                      │
│             for (uint8 i = 0; i < 32; i++) {                                                                                                                                                                    │
│                 // if we have accurate rate this should hold                                                                                                                                                    │
│                 amountIn = (difference * _TEMPUS_SHARE_PRECISION) / (rate + _TEMPUS_SHARE_PRECISION);                                                                                                           │
│                 uint256 amountOut = getExpectedReturnGivenIn(amountIn, yieldsIn);                                                                                                                               │
│                 uint256 newPrincipals = yieldsIn ? (principals + amountOut) : (principals - amountIn);                                                                                                          │
│                 uint256 newYields = yieldsIn ? (yields - amountIn) : (yields + amountOut);                                                                                                                      │
│                 uint256 newDifference = (newPrincipals > newYields)                                                                                                                                             │
│                     ? (newPrincipals - newYields)                                                                                                                                                               │
│                     : (newYields - newPrincipals);                                                                                                                                                              │
│                 if (newDifference < threshold) {                                                                                                                                                                │
│                     return amountIn;                                                                                                                                                                            │
│                 } else {                                                                                                                                                                                        │
│                     rate = (amountOut * _TEMPUS_SHARE_PRECISION) / amountIn;                                                                                                                                    │
│                 }                                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│             revert("getSwapAmountToEndWithEqualShares did not converge.");                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                     │
│         external                                                                                                                                                                                                │
│         view                                                                                                                                                                                                    │
│         returns (uint256 lpTokens)                                                                                                                                                                              │
│     {                                                                                                                                                                                                           │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                       │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                         │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                        │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                  │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                    │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                    │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                             │
│         if (_isNotPaused()) {                                                                                                                                                                                   │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                  │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                    │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             protocolSwapFeePercentage                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes",                                                                                                                                                                                                 │
│     "3": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                     │
│         external                                                                                                                                                                                                │
│         view                                                                                                                                                                                                    │
│         returns (uint256 lpTokens)                                                                                                                                                                              │
│     {                                                                                                                                                                                                           │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                       │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                         │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                        │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                  │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                    │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                    │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                             │
│         if (_isNotPaused()) {                                                                                                                                                                                   │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                  │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                    │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             protocolSwapFeePercentage                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedTokensOutGivenBPTIn(uint256 bptAmountIn)                                                                                                                                                │
│         external                                                                                                                                                                                                │
│         view                                                                                                                                                                                                    │
│         returns (uint256 principals, uint256 yields)                                                                                                                                                            │
│     {                                                                                                                                                                                                           │
│         // We don't need to scale balances down here                                                                                                                                                            │
│         // as calculation for amounts out is based on btpAmountIn / totalSupply() ratio                                                                                                                         │
│         // Adjusting balances with rate, and then undoing it would just cause additional calculations                                                                                                           │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                           │
│         (principals, yields) = (address(_token0) == address(tempusPool.principalShare()))                                                                                                                       │
│             ? (amountsOut[0], amountsOut[1])                                                                                                                                                                    │
│             : (amountsOut[1], amountsOut[0]);                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No",                                                                                                                                                                                                  │
│     "3": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedLPTokensForTokensIn(uint256[] memory amountsIn) external view returns (uint256) {                                                                                                       │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         return                                                                                                                                                                                                  │
│             (balances[0] == 0)                                                                                                                                                                                  │
│                 ? StableMath._calculateInvariant(currentAmp, amountsIn, true)                                                                                                                                   │
│                 : StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                     │
│                     currentAmp,                                                                                                                                                                                 │
│                     balances,                                                                                                                                                                                   │
│                     amountsIn,                                                                                                                                                                                  │
│                     totalSupply(),                                                                                                                                                                              │
│                     getSwapFeePercentage()                                                                                                                                                                      │
│                 );                                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No",                                                                                                                                                                                                  │
│     "3": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                               │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                        │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsIn,                                                                                                                                                                                          │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _doJoin(                                                                                                                                                                                           │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256 bptAmountOut, uint256[] memory amountsIn) {                                                                                                                                      │
│         JoinKind kind = userData.joinKind();                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         if (kind == JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {                                                                                                                                                     │
│             return _joinExactTokensInForBPTOut(balances, scalingFactors, userData);                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             _revert(Errors.UNHANDLED_JOIN_KIND);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                               │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                        │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsIn,                                                                                                                                                                                          │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _doJoin(                                                                                                                                                                                           │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256 bptAmountOut, uint256[] memory amountsIn) {                                                                                                                                      │
│         JoinKind kind = userData.joinKind();                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         if (kind == JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {                                                                                                                                                     │
│             return _joinExactTokensInForBPTOut(balances, scalingFactors, userData);                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             _revert(Errors.UNHANDLED_JOIN_KIND);                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                               │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                        │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsIn,                                                                                                                                                                                          │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)                                                                                                                      │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (uint256, uint256[] memory)                                                                                                                                                                     │
│     {                                                                                                                                                                                                           │
│         // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted                                                                                           │
│         // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.                                                                                                    │
│         // This particular exit function is the only one that remains available because it is the simplest one, and                                                                                             │
│         // therefore the one with the lowest likelihood of errors.                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         uint256 bptAmountIn = userData.exactBptInForTokensOut();                                                                                                                                                │
│         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.                                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                           │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _doExit(                                                                                                                                                                                           │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         ExitKind kind = userData.exitKind();                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {                                                                                                                                                     │
│             return _exitExactBPTInForTokensOut(balances, userData);                                                                                                                                             │
│         } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {                                                                                                                                              │
│             return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             revert("Unhandled exit kind.");                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)                                                                                                                      │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (uint256, uint256[] memory)                                                                                                                                                                     │
│     {                                                                                                                                                                                                           │
│         // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted                                                                                           │
│         // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.                                                                                                    │
│         // This particular exit function is the only one that remains available because it is the simplest one, and                                                                                             │
│         // therefore the one with the lowest likelihood of errors.                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         uint256 bptAmountIn = userData.exactBptInForTokensOut();                                                                                                                                                │
│         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.                                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                           │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _doExit(                                                                                                                                                                                           │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         ExitKind kind = userData.exitKind();                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {                                                                                                                                                     │
│             return _exitExactBPTInForTokensOut(balances, userData);                                                                                                                                             │
│         } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {                                                                                                                                              │
│             return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             revert("Unhandled exit kind.");                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)                                                                                                                      │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (uint256, uint256[] memory)                                                                                                                                                                     │
│     {                                                                                                                                                                                                           │
│         // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted                                                                                           │
│         // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.                                                                                                    │
│         // This particular exit function is the only one that remains available because it is the simplest one, and                                                                                             │
│         // therefore the one with the lowest likelihood of errors.                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         uint256 bptAmountIn = userData.exactBptInForTokensOut();                                                                                                                                                │
│         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.                                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());                                                                                           │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                │
│         // This exit function is disabled if the contract is paused.                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                  │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                         │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _doExit(                                                                                                                                                                                           │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         ExitKind kind = userData.exitKind();                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {                                                                                                                                                     │
│             return _exitExactBPTInForTokensOut(balances, userData);                                                                                                                                             │
│         } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {                                                                                                                                              │
│             return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             revert("Unhandled exit kind.");                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                │
│         // This exit function is disabled if the contract is paused.                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                  │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                         │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _doExit(                                                                                                                                                                                           │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         ExitKind kind = userData.exitKind();                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│         if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {                                                                                                                                                     │
│             return _exitExactBPTInForTokensOut(balances, userData);                                                                                                                                             │
│         } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {                                                                                                                                              │
│             return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);                                                                                                                             │
│         } else {                                                                                                                                                                                                │
│             revert("Unhandled exit kind.");                                                                                                                                                                     │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                │
│         // This exit function is disabled if the contract is paused.                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                  │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                         │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No.                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _onJoinPool(                                                                                                                                                                                       │
│         bytes32,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256,                                                                                                                                                                                                │
│         uint256 protocolSwapFeePercentage,                                                                                                                                                                      │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         virtual                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         whenNotPaused                                                                                                                                                                                           │
│         beforeMaturity                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256,                                                                                                                                                                                            │
│             uint256[] memory,                                                                                                                                                                                   │
│             uint256[] memory                                                                                                                                                                                    │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                         │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous join                                                                                        │
│         // or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids spending gas to                                                                                          │
│         // calculate the fee amounts during each individual swap.                                                                                                                                               │
│         uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);                                                                                                │
│                                                                                                                                                                                                                 │
│         // Update current balances by subtracting the protocol fee amounts                                                                                                                                      │
│         balances.sub(dueProtocolFeeAmounts);                                                                                                                                                                    │
│         (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(balances, scalingFactors, userData);                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Update the invariant with the balances the Pool will have after the join, in order to compute the                                                                                                    │
│         // protocol swap fee amounts due in future joins and exits.                                                                                                                                             │
│         _updateInvariantAfterJoin(balances, amountsIn);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         amountsIn.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│         dueProtocolFeeAmounts.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _onJoinPool(                                                                                                                                                                                       │
│         bytes32,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256,                                                                                                                                                                                                │
│         uint256 protocolSwapFeePercentage,                                                                                                                                                                      │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         virtual                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         whenNotPaused                                                                                                                                                                                           │
│         beforeMaturity                                                                                                                                                                                          │
│         returns (                                                                                                                                                                                               │
│             uint256,                                                                                                                                                                                            │
│             uint256[] memory,                                                                                                                                                                                   │
│             uint256[] memory                                                                                                                                                                                    │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                         │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous join                                                                                        │
│         // or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids spending gas to                                                                                          │
│         // calculate the fee amounts during each individual swap.                                                                                                                                               │
│         uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);                                                                                                │
│                                                                                                                                                                                                                 │
│         // Update current balances by subtracting the protocol fee amounts                                                                                                                                      │
│         balances.sub(dueProtocolFeeAmounts);                                                                                                                                                                    │
│         (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(balances, scalingFactors, userData);                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Update the invariant with the balances the Pool will have after the join, in order to compute the                                                                                                    │
│         // protocol swap fee amounts due in future joins and exits.                                                                                                                                             │
│         _updateInvariantAfterJoin(balances, amountsIn);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         amountsIn.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│         dueProtocolFeeAmounts.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                               │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                        │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsIn,                                                                                                                                                                                          │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _joinExactTokensInForBPTOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private returns (uint256, uint256[] memory) {                                                                                                                                                             │
│         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(_TOTAL_TOKENS, amountsIn.length);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                               │
│         amountsIn.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                        │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsIn,                                                                                                                                                                                          │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                │
│         // This exit function is disabled if the contract is paused.                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                  │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                         │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _exitBPTInForExactTokensOut(                                                                                                                                                                       │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) private whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                                                │
│         // This exit function is disabled if the contract is paused.                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();                                                                                                              │
│         InputHelpers.ensureInputLengthMatch(amountsOut.length, _TOTAL_TOKENS);                                                                                                                                  │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         amountsOut.mul(_getTokenRates(), _TEMPUS_SHARE_PRECISION);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                         │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             getSwapFeePercentage()                                                                                                                                                                              │
│         );                                                                                                                                                                                                      │
│         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         return (bptAmountIn, amountsOut);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _onInitializePool(                                                                                                                                                                                 │
│         bytes32,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) internal virtual override whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                              │
│         // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent                                                                                               │
│         // initialization in this case.                                                                                                                                                                         │
│         TempusAMM.JoinKind kind = userData.joinKind();                                                                                                                                                          │
│         _require(kind == TempusAMM.JoinKind.INIT, Errors.UNINITIALIZED);                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         uint256[] memory amountsIn = userData.initialAmountsIn();                                                                                                                                               │
│         InputHelpers.ensureInputLengthMatch(amountsIn.length, _TOTAL_TOKENS);                                                                                                                                   │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                         │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         uint256 invariantAfterJoin = StableMath._calculateInvariant(currentAmp, amountsIn, true);                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Set the initial BPT to the value of the invariant.                                                                                                                                                   │
│         uint256 bptAmountOut = invariantAfterJoin;                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         _updateLastInvariant(invariantAfterJoin, currentAmp);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         amountsIn.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _onInitializePool(                                                                                                                                                                                 │
│         bytes32,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     ) internal virtual override whenNotPaused beforeMaturity returns (uint256, uint256[] memory) {                                                                                                              │
│         // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent                                                                                               │
│         // initialization in this case.                                                                                                                                                                         │
│         TempusAMM.JoinKind kind = userData.joinKind();                                                                                                                                                          │
│         _require(kind == TempusAMM.JoinKind.INIT, Errors.UNINITIALIZED);                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         uint256[] memory amountsIn = userData.initialAmountsIn();                                                                                                                                               │
│         InputHelpers.ensureInputLengthMatch(amountsIn.length, _TOTAL_TOKENS);                                                                                                                                   │
│         _upscaleArray(amountsIn, scalingFactors);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                         │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         uint256 invariantAfterJoin = StableMath._calculateInvariant(currentAmp, amountsIn, true);                                                                                                               │
│                                                                                                                                                                                                                 │
│         // Set the initial BPT to the value of the invariant.                                                                                                                                                   │
│         uint256 bptAmountOut = invariantAfterJoin;                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         _updateLastInvariant(invariantAfterJoin, currentAmp);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         amountsIn.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         return (bptAmountOut, amountsIn);                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _onExitPool(                                                                                                                                                                                       │
│         bytes32,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256,                                                                                                                                                                                                │
│         uint256 protocolSwapFeePercentage,                                                                                                                                                                      │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         virtual                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 bptAmountIn,                                                                                                                                                                                │
│             uint256[] memory amountsOut,                                                                                                                                                                        │
│             uint256[] memory dueProtocolFeeAmounts                                                                                                                                                              │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                         │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens                                                                                          │
│         // out) remain functional.                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (_isNotPaused()) {                                                                                                                                                                                   │
│             // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous                                                                                         │
│             // join or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids                                                                                                 │
│             // spending gas calculating fee amounts during each individual swap                                                                                                                                 │
│             dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                  │
│             balances.sub(dueProtocolFeeAmounts);                                                                                                                                                                │
│         } else {                                                                                                                                                                                                │
│             // If the contract is paused, swap protocol fee amounts are not charged to avoid extra calculations and                                                                                             │
│             // reduce the potential for errors.                                                                                                                                                                 │
│             dueProtocolFeeAmounts = new uint256[](_TOTAL_TOKENS);                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (bptAmountIn, amountsOut) = _doExit(balances, scalingFactors, userData);                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Update the invariant with the balances the Pool will have after the exit, in order to compute the                                                                                                    │
│         // protocol swap fee amounts due in future joins and exits.                                                                                                                                             │
│         _updateInvariantAfterExit(balances, amountsOut);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         amountsOut.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                    │
│         dueProtocolFeeAmounts.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _onExitPool(                                                                                                                                                                                       │
│         bytes32,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         address,                                                                                                                                                                                                │
│         uint256[] memory balances,                                                                                                                                                                              │
│         uint256,                                                                                                                                                                                                │
│         uint256 protocolSwapFeePercentage,                                                                                                                                                                      │
│         uint256[] memory scalingFactors,                                                                                                                                                                        │
│         bytes memory userData                                                                                                                                                                                   │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         virtual                                                                                                                                                                                                 │
│         override                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 bptAmountIn,                                                                                                                                                                                │
│             uint256[] memory amountsOut,                                                                                                                                                                        │
│             uint256[] memory dueProtocolFeeAmounts                                                                                                                                                              │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256[] memory tokenRates = _getTokenRates();                                                                                                                                                         │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens                                                                                          │
│         // out) remain functional.                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (_isNotPaused()) {                                                                                                                                                                                   │
│             // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous                                                                                         │
│             // join or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids                                                                                                 │
│             // spending gas calculating fee amounts during each individual swap                                                                                                                                 │
│             dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                  │
│             balances.sub(dueProtocolFeeAmounts);                                                                                                                                                                │
│         } else {                                                                                                                                                                                                │
│             // If the contract is paused, swap protocol fee amounts are not charged to avoid extra calculations and                                                                                             │
│             // reduce the potential for errors.                                                                                                                                                                 │
│             dueProtocolFeeAmounts = new uint256[](_TOTAL_TOKENS);                                                                                                                                               │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (bptAmountIn, amountsOut) = _doExit(balances, scalingFactors, userData);                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Update the invariant with the balances the Pool will have after the exit, in order to compute the                                                                                                    │
│         // protocol swap fee amounts due in future joins and exits.                                                                                                                                             │
│         _updateInvariantAfterExit(balances, amountsOut);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│         amountsOut.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                    │
│         dueProtocolFeeAmounts.div(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _getTokenRates() private returns (uint256[] memory) {                                                                                                                                              │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShare();                                                                                                                                                              │
│         rates[1] = _token1.getPricePerFullShare();                                                                                                                                                              │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                        │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                            │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                           │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                           │
│                                                                                                                                                                                                                 │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                          │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                        │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                              │
│                                                                                                                                                                                                                 │
│         return amountOut;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) public view returns (uint256) {                                                                                                        │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         (IPoolShare tokenIn, IPoolShare tokenOut) = yieldShareIn                                                                                                                                                │
│             ? (tempusPool.yieldShare(), tempusPool.principalShare())                                                                                                                                            │
│             : (tempusPool.principalShare(), tempusPool.yieldShare());                                                                                                                                           │
│         (uint256 indexIn, uint256 indexOut) = address(tokenIn) == address(_token0) ? (0, 1) : (1, 0);                                                                                                           │
│                                                                                                                                                                                                                 │
│         amount = _subtractSwapFeeAmount(amount);                                                                                                                                                                │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                          │
│         uint256 rateAdjustedSwapAmount = (amount * tokenIn.getPricePerFullShareStored()) / _TEMPUS_SHARE_PRECISION;                                                                                             │
│                                                                                                                                                                                                                 │
│         uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, rateAdjustedSwapAmount);                                                                                        │
│         amountOut = (amountOut * _TEMPUS_SHARE_PRECISION) / tokenOut.getPricePerFullShareStored();                                                                                                              │
│                                                                                                                                                                                                                 │
│         return amountOut;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedLPTokensForTokensIn(uint256[] memory amountsIn) external view returns (uint256) {                                                                                                       │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         return                                                                                                                                                                                                  │
│             (balances[0] == 0)                                                                                                                                                                                  │
│                 ? StableMath._calculateInvariant(currentAmp, amountsIn, true)                                                                                                                                   │
│                 : StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                     │
│                     currentAmp,                                                                                                                                                                                 │
│                     balances,                                                                                                                                                                                   │
│                     amountsIn,                                                                                                                                                                                  │
│                     totalSupply(),                                                                                                                                                                              │
│                     getSwapFeePercentage()                                                                                                                                                                      │
│                 );                                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedLPTokensForTokensIn(uint256[] memory amountsIn) external view returns (uint256) {                                                                                                       │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│         amountsIn.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         return                                                                                                                                                                                                  │
│             (balances[0] == 0)                                                                                                                                                                                  │
│                 ? StableMath._calculateInvariant(currentAmp, amountsIn, true)                                                                                                                                   │
│                 : StableMath._calcBptOutGivenExactTokensIn(                                                                                                                                                     │
│                     currentAmp,                                                                                                                                                                                 │
│                     balances,                                                                                                                                                                                   │
│                     amountsIn,                                                                                                                                                                                  │
│                     totalSupply(),                                                                                                                                                                              │
│                     getSwapFeePercentage()                                                                                                                                                                      │
│                 );                                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                     │
│         external                                                                                                                                                                                                │
│         view                                                                                                                                                                                                    │
│         returns (uint256 lpTokens)                                                                                                                                                                              │
│     {                                                                                                                                                                                                           │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                       │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                         │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                        │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                  │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                    │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                    │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                             │
│         if (_isNotPaused()) {                                                                                                                                                                                   │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                  │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                    │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             protocolSwapFeePercentage                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                     │
│         external                                                                                                                                                                                                │
│         view                                                                                                                                                                                                    │
│         returns (uint256 lpTokens)                                                                                                                                                                              │
│     {                                                                                                                                                                                                           │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                       │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                         │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                        │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                  │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                    │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                    │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                             │
│         if (_isNotPaused()) {                                                                                                                                                                                   │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                  │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                    │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             protocolSwapFeePercentage                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function getRate() public view override returns (uint256) {                                                                                                                                                 │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // When calculating the current BPT rate, we may not have paid the protocol fees, therefore                                                                                                             │
│         // the invariant should be smaller than its current value. Then, we round down overall.                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _upscaleArray(balances, _scalingFactors());                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                          │
│         uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, false);                                                                                                                        │
│         return invariant.divDown(totalSupply());                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function getRate() public view override returns (uint256) {                                                                                                                                                 │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // When calculating the current BPT rate, we may not have paid the protocol fees, therefore                                                                                                             │
│         // the invariant should be smaller than its current value. Then, we round down overall.                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _upscaleArray(balances, _scalingFactors());                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                          │
│         uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, false);                                                                                                                        │
│         return invariant.divDown(totalSupply());                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _getTokenRatesStored() private view returns (uint256[] memory) {                                                                                                                                   │
│         uint256[] memory rates = new uint256[](_TOTAL_TOKENS);                                                                                                                                                  │
│         rates[0] = _token0.getPricePerFullShareStored();                                                                                                                                                        │
│         rates[1] = _token1.getPricePerFullShareStored();                                                                                                                                                        │
│         return rates;                                                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function getRate() public view override returns (uint256) {                                                                                                                                                 │
│         (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // When calculating the current BPT rate, we may not have paid the protocol fees, therefore                                                                                                             │
│         // the invariant should be smaller than its current value. Then, we round down overall.                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         _upscaleArray(balances, _scalingFactors());                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         balances.mul(_getTokenRatesStored(), _TEMPUS_SHARE_PRECISION);                                                                                                                                          │
│         uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, false);                                                                                                                        │
│         return invariant.divDown(totalSupply());                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No",                                                                                                                                                                                                  │
│     "3": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {                                                                                                    │
│         _require(rawEndValue >= _MIN_AMP, Errors.MIN_AMP);                                                                                                                                                      │
│         _require(rawEndValue <= _MAX_AMP, Errors.MAX_AMP);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 duration = Math.sub(endTime, block.timestamp);                                                                                                                                                  │
│         _require(duration >= _MIN_UPDATE_TIME, Errors.AMP_END_TIME_TOO_CLOSE);                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();                                                                                                                                 │
│         _require(!isUpdating, Errors.AMP_ONGOING_UPDATE);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 endValue = Math.mul(rawEndValue, _AMP_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // daily rate = (endValue / currentValue) / duration * 1 day                                                                                                                                            │
│         // We perform all multiplications first to not reduce precision, and round the division up as we want to avoid                                                                                          │
│         // large rates. Note that these are regular integer multiplications and divisions, not fixed point.                                                                                                     │
│         uint256 dailyRate = endValue > currentValue                                                                                                                                                             │
│             ? Math.divUp(Math.mul(1 days, endValue), Math.mul(currentValue, duration))                                                                                                                          │
│             : Math.divUp(Math.mul(1 days, currentValue), Math.mul(endValue, duration));                                                                                                                         │
│         _require(dailyRate <= _MAX_AMP_UPDATE_DAILY_RATE, Errors.AMP_RATE_TOO_HIGH);                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _setAmplificationData(currentValue, endValue, block.timestamp, endTime);                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│     function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {                                                                                                    │
│         _require(rawEndValue >= _MIN_AMP, Errors.MIN_AMP);                                                                                                                                                      │
│         _require(rawEndValue <= _MAX_AMP, Errors.MAX_AMP);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 duration = Math.sub(endTime, block.timestamp);                                                                                                                                                  │
│         _require(duration >= _MIN_UPDATE_TIME, Errors.AMP_END_TIME_TOO_CLOSE);                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();                                                                                                                                 │
│         _require(!isUpdating, Errors.AMP_ONGOING_UPDATE);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 endValue = Math.mul(rawEndValue, _AMP_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // daily rate = (endValue / currentValue) / duration * 1 day                                                                                                                                            │
│         // We perform all multiplications first to not reduce precision, and round the division up as we want to avoid                                                                                          │
│         // large rates. Note that these are regular integer multiplications and divisions, not fixed point.                                                                                                     │
│         uint256 dailyRate = endValue > currentValue                                                                                                                                                             │
│             ? Math.divUp(Math.mul(1 days, endValue), Math.mul(currentValue, duration))                                                                                                                          │
│             : Math.divUp(Math.mul(1 days, currentValue), Math.mul(endValue, duration));                                                                                                                         │
│         _require(dailyRate <= _MAX_AMP_UPDATE_DAILY_RATE, Errors.AMP_RATE_TOO_HIGH);                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _setAmplificationData(currentValue, endValue, block.timestamp, endTime);                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "ammLiquidityProvisionAmounts": "Array holding the calculated liquidity provision amounts for AMM tokens"                                                                                               │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "request": "Variable 'request' holds the JoinPoolRequest struct for providing liquidity to TempusAMM"                                                                                                   │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:42] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusController.sol, current       tasks.py:260
                             function: _provideLiquidity, current vul: price-manipulation                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 209, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the `validate_description` validation                                                                                             
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "vault": "Variable holding the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "mintedShares": "Variable holding the calculated value/price of LP token"                                                                                                                               │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:43] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusController.sol, current       tasks.py:359
                             function: _provideLiquidity, current vul: price-manipulation                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function _deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                              │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedBT,                                                                                                                                                                                │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(!matured, "Maturity reached.");                                                                                                                                                                 │
│         rate = updateInterestRate();                                                                                                                                                                            │
│         require(rate >= initialInterestRate, "Negative yield!");                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Collect fees if they are set, reducing the number of tokens for the sender                                                                                                                           │
│         // thus leaving more YBT in the TempusPool than there are minted TPS/TYS                                                                                                                                │
│         uint256 tokenAmount = yieldTokenAmount;                                                                                                                                                                 │
│         uint256 depositFees = feesConfig.depositPercent;                                                                                                                                                        │
│         if (depositFees != 0) {                                                                                                                                                                                 │
│             fee = tokenAmount.mulfV(depositFees, yieldBearingONE);                                                                                                                                              │
│             tokenAmount -= fee;                                                                                                                                                                                 │
│             totalFees += fee;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Issue appropriate shares                                                                                                                                                                             │
│         depositedBT = numAssetsPerYieldToken(tokenAmount, rate);                                                                                                                                                │
│         mintedShares = numSharesToMint(depositedBT, rate);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         PrincipalShare(address(principalShare)).mint(recipient, mintedShares);                                                                                                                                  │
│         YieldShare(address(yieldShare)).mint(recipient, mintedShares);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `rate = updateInterestRate();`.                                                                                                                  │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _deposit(uint256 yieldTokenAmount, address recipient)                                                                                                                                              │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 mintedShares,                                                                                                                                                                               │
│             uint256 depositedBT,                                                                                                                                                                                │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 rate                                                                                                                                                                                        │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(!matured, "Maturity reached.");                                                                                                                                                                 │
│         rate = updateInterestRate();                                                                                                                                                                            │
│         require(rate >= initialInterestRate, "Negative yield!");                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Collect fees if they are set, reducing the number of tokens for the sender                                                                                                                           │
│         // thus leaving more YBT in the TempusPool than there are minted TPS/TYS                                                                                                                                │
│         uint256 tokenAmount = yieldTokenAmount;                                                                                                                                                                 │
│         uint256 depositFees = feesConfig.depositPercent;                                                                                                                                                        │
│         if (depositFees != 0) {                                                                                                                                                                                 │
│             fee = tokenAmount.mulfV(depositFees, yieldBearingONE);                                                                                                                                              │
│             tokenAmount -= fee;                                                                                                                                                                                 │
│             totalFees += fee;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Issue appropriate shares                                                                                                                                                                             │
│         depositedBT = numAssetsPerYieldToken(tokenAmount, rate);                                                                                                                                                │
│         mintedShares = numSharesToMint(depositedBT, rate);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         PrincipalShare(address(principalShare)).mint(recipient, mintedShares);                                                                                                                                  │
│         YieldShare(address(yieldShare)).mint(recipient, mintedShares);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `mintedShares = numSharesToMint(depositedBT, rate);`                                                                                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:44] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:260
                             _deposit, current vul: wrong-order-interest                                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `updateInterestRate();`                                                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function burnShares(                                                                                                                                                                                        │
│         address from,                                                                                                                                                                                           │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         internal                                                                                                                                                                                                │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemedYieldTokens,                                                                                                                                                                        │
│             uint256 fee,                                                                                                                                                                                        │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, "Insufficient principals.");                                                                                                │
│         require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, "Insufficient yields.");                                                                                                            │
│                                                                                                                                                                                                                 │
│         // Redeeming prior to maturity is only allowed in equal amounts.                                                                                                                                        │
│         require(matured || (principalAmount == yieldAmount), "Inequal redemption not allowed before maturity.");                                                                                                │
│                                                                                                                                                                                                                 │
│         // Burn the appropriate shares                                                                                                                                                                          │
│         PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);                                                                                                                                │
│         YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         uint256 currentRate = updateInterestRate();                                                                                                                                                             │
│         (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);                                                                                           │
│         totalFees += fee;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 currentRate = updateInterestRate();`                                                                                                                                                                   │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:45] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:260
                             burnShares, current vul: wrong-order-interest                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "currentRate": "Variable holding the market reserves/AMM price/exchange rate calculation"                                                                                                               │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "interestRate": "Variable holding the calculated value/price of LP token"                                                                                                                               │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:260
                             burnShares, current vul: price-manipulation                                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "redeemedYieldTokens": "Amount of redeemed yield tokens",                                                                                                                                               │
│         "fee": "Fee amount",                                                                                                                                                                                    │
│         "rate": "Exchange rate"                                                                                                                                                                                 │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "redeemedBackingTokens": "Amount of redeemed backing tokens"                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:46] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:359
                             burnShares, current vul: price-manipulation                                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 310, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the validation                                                                                                                    
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function getRedemptionAmounts(                                                                                                                                                                              │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         uint256 currentRate                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemableYieldTokens,                                                                                                                                                                      │
│             uint256 redeemableBackingTokens,                                                                                                                                                                    │
│             uint256 redeemFeeAmount,                                                                                                                                                                            │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (interestRate < initialInterestRate) {                                                                                                                                                               │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                              │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                         │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                        │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                               │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                            │
│                                                                                                                                                                                                                 │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                   │
│             if (matured && currentRate > interestRate) {                                                                                                                                                        │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                       │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                   │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                            │
│                     exchangeRateONE                                                                                                                                                                             │
│                 );                                                                                                                                                                                              │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                        │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                    │
│         if (redeemFeePercent != 0) {                                                                                                                                                                            │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                          │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                          │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                               │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is the statement inside the `if (interestRate < initialInterestRate)` block.                                                                        │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function getRedemptionAmounts(                                                                                                                                                                              │
│         uint256 principalAmount,                                                                                                                                                                                │
│         uint256 yieldAmount,                                                                                                                                                                                    │
│         uint256 currentRate                                                                                                                                                                                     │
│     )                                                                                                                                                                                                           │
│         private                                                                                                                                                                                                 │
│         view                                                                                                                                                                                                    │
│         returns (                                                                                                                                                                                               │
│             uint256 redeemableYieldTokens,                                                                                                                                                                      │
│             uint256 redeemableBackingTokens,                                                                                                                                                                    │
│             uint256 redeemFeeAmount,                                                                                                                                                                            │
│             uint256 interestRate                                                                                                                                                                                │
│         )                                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         interestRate = effectiveRate(currentRate);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         if (interestRate < initialInterestRate) {                                                                                                                                                               │
│             redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;                                                                                                                   │
│         } else {                                                                                                                                                                                                │
│             uint256 rateDiff = interestRate - initialInterestRate;                                                                                                                                              │
│             // this is expressed in percent with exchangeRate precision                                                                                                                                         │
│             uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);                                                                                                                        │
│             uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);                                                                                                             │
│                                                                                                                                                                                                                 │
│             // TODO: Scale based on number of decimals for tokens                                                                                                                                               │
│             redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;                                                                                                                            │
│                                                                                                                                                                                                                 │
│             // after maturity, all additional yield is being collected as fee                                                                                                                                   │
│             if (matured && currentRate > interestRate) {                                                                                                                                                        │
│                 uint256 additionalYieldRate = currentRate - interestRate;                                                                                                                                       │
│                 uint256 feeBackingAmount = yieldAmount.mulfV(                                                                                                                                                   │
│                     additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),                                                                                                                            │
│                     exchangeRateONE                                                                                                                                                                             │
│                 );                                                                                                                                                                                              │
│                 redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);                                                                                                                        │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;                                                                                                    │
│         if (redeemFeePercent != 0) {                                                                                                                                                                            │
│             uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);                                                                                                          │
│             redeemableYieldTokens -= regularRedeemFee;                                                                                                                                                          │
│             redeemFeeAmount += regularRedeemFee;                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│             redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);                                                                                                               │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward is `redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;`.                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:48] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:260
                             getRedemptionAmounts, current vul: wrong-order-interest                                                                                                                               
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "currentRate": "Holds the market reserves/AMM price/exchange rate"                                                                                                                                      │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "redeemableYieldTokens": "Holds the calculated value/price of LP token"                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:260
                             getRedemptionAmounts, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "currentRate": "Variable holding the market reserves/AMM price/exchange rate calculation"                                                                                                               │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "interestRate": "Variable holding the calculated value/price of LP token"                                                                                                                               │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:49] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:359
                             getRedemptionAmounts, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "currentRate": "Holds the current interest rate"                                                                                                                                                        │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "backingTokens": "Holds the calculated value of LP token when toBackingToken is false"                                                                                                                  │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:50] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:359
                             getRedemptionAmounts, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "exchangeRateONE": "Holds the exchange rate value"                                                                                                                                                      │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "timeLeft": "Holds the calculated time left value"                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:51] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:260
                             estimatedYield, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "exchangeRateONE": "Holds the market reserves/AMM price/exchange rate"                                                                                                                                  │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "principalPrice": "Holds the calculated value/price of LP token"                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:52] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:359
                             estimatedYield, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "exchangeRateONE": "Holds the market reserves/AMM price/exchange rate"                                                                                                                                  │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "yieldPrice": "Holds the calculated value/price of LP token"                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:359
                             estimatedYield, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "exchangeRateONE": "Holds the market reserves/AMM price/exchange rate"                                                                                                                                  │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "yieldPrice": "Holds the calculated value/price of LP token"                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:53] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:260
                             pricePerYieldShare, current vul: price-manipulation                                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "exchangeRateONE": "Variable holding the market reserves/AMM price/exchange rate"                                                                                                                       │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "yieldPrice": "Variable holding the calculated value/price of LP token"                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:54] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:359
                             pricePerYieldShare, current vul: price-manipulation                                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "exchangeRateONE": "Holds the market reserves/AMM price/exchange rate"                                                                                                                                  │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "principalPrice": "Holds the calculated value/price of LP token"                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:55] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:260
                             pricePerPrincipalShare, current vul: price-manipulation                                                                                                                               
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "exchangeRateONE": "Holds the market reserves/AMM price/exchange rate"                                                                                                                                  │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "principalPrice": "Holds the calculated value/price of LP token"                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:56] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/TempusPool.sol, current function:   tasks.py:359
                             pricePerPrincipalShare, current vul: price-manipulation                                                                                                                               
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "newTotalShares": "Holds the value of total minted shares or amount"                                                                                                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_getTotalShares()": "Holds the total supply/liquidity and is used by the conditional branch to determine the supply/liquidity is 0"                                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_sharesAmount": "Holds the value of the deposit/mint/add amount"                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:57] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/mocks/lido/StETH.sol, current       tasks.py:260
                             function: _mintShares, current vul: first-deposit                                                                                                                                     
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "sharesAmount": "Holds the value of total minted share or amount"                                                                                                                                       │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "totalControlledEther": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                 │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "deposit": "Holds the value of the deposit/mint/add amount"                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:58] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/mocks/lido/StETH.sol, current       tasks.py:359
                             function: _mintShares, current vul: first-deposit                                                                                                                                     
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "sharesToMint": "Holds the value of total minted shares"                                                                                                                                                │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "_getTotalPooledEther()": "Holds the total supply/liquidity and used in conditional branch to determine if supply/liquidity is 0"                                                                       │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "_totalRewards": "Holds the value of the deposit/mint/add amount"                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:15:59] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/mocks/lido/StETH.sol, current       tasks.py:359
                             function: _mintShares, current vul: first-deposit                                                                                                                                     
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "exchangeRate": "Holds the market reserves/AMM price/exchange rate calculation"                                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "mintTokens": "Holds the calculated value/price of LP token"                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:00] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/mocks/compound/CTokenMock.sol,      tasks.py:260
                             current function: mintFresh, current vul: price-manipulation                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "preDepositBalance": "Variable holding the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "backingAmount": "Variable holding the calculated value/price of LP token"                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:01] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/pools/CompoundTempusPool.sol,       tasks.py:260
                             current function: depositToUnderlying, current vul: price-manipulation                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "depositedYBT": "Variable holding the calculated value of deposited YBT tokens"                                                                                                                         │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "mintedShares": "Variable holding the calculated value of minted shares"                                                                                                                                │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:02] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/pools/CompoundTempusPool.sol,       tasks.py:359
                             current function: depositToUnderlying, current vul: price-manipulation                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         // tempus pool owns YBT                                                                                                                                                                                 │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                    │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                           │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                               │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `updateInterestRate()` statement.                                                                                                                │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)                                                                                                                │
│         internal                                                                                                                                                                                                │
│         override                                                                                                                                                                                                │
│         returns (uint256 backingTokenAmount)                                                                                                                                                                    │
│     {                                                                                                                                                                                                           │
│         // tempus pool owns YBT                                                                                                                                                                                 │
│         assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);                                                                                                                                    │
│         require(cToken.redeem(yieldBearingTokensAmount) == 0, "CErc20 redeem failed");                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // need to rescale the truncated amount which was used during cToken.redeem()                                                                                                                           │
│         uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());                                                                                                               │
│         return IERC20(backingToken).untrustedTransfer(recipient, backing);                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward is `uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());`.                      │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:03] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/pools/CompoundTempusPool.sol,       tasks.py:260
                             current function: withdrawFromUnderlyingProtocol, current vul: wrong-order-interest                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "backing": "Variable holding the calculated value/price of LP token"                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:04] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/pools/CompoundTempusPool.sol,       tasks.py:260
                             current function: withdrawFromUnderlyingProtocol, current vul: price-manipulation                                                                                                     
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "redeemedYieldTokens": "Holds the amount of redeemed yield tokens",                                                                                                                                     │
│         "fee": "Holds the fee amount",                                                                                                                                                                          │
│         "rate": "Holds the rate value"                                                                                                                                                                          │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "redeemedBackingTokens": "Holds the calculated value of redeemed backing tokens"                                                                                                                        │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:05] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/pools/CompoundTempusPool.sol,       tasks.py:359
                             current function: withdrawFromUnderlyingProtocol, current vul: price-manipulation                                                                                                     
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balances": "Array holding pool token balances",                                                                                                                                                        │
│         "currentAmp": "Variable holding current amplification parameter",                                                                                                                                       │
│         "tokenIn": "Variable holding input pool share token",                                                                                                                                                   │
│         "tokenOut": "Variable holding output pool share token",                                                                                                                                                 │
│         "indexIn": "Index of input token",                                                                                                                                                                      │
│         "indexOut": "Index of output token",                                                                                                                                                                    │
│         "rateAdjustedSwapAmount": "Variable holding rate adjusted swap amount"                                                                                                                                  │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "amountOut": "Variable holding calculated amount out"                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:06] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:260
                             function: getExpectedReturnGivenIn, current vul: price-manipulation                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "principalsRate": "Holds the market reserves/AMM price/exchange rate for principals token",                                                                                                             │
│         "yieldsRate": "Holds the market reserves/AMM price/exchange rate for yields token"                                                                                                                      │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "amountIn": "Holds the calculated value/price of LP token"                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:07] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: getExpectedReturnGivenIn, current vul: price-manipulation                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                     │
│         external                                                                                                                                                                                                │
│         view                                                                                                                                                                                                    │
│         returns (uint256 lpTokens)                                                                                                                                                                              │
│     {                                                                                                                                                                                                           │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                       │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                         │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                        │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                  │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                    │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                    │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                             │
│         if (_isNotPaused()) {                                                                                                                                                                                   │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                  │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                    │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             protocolSwapFeePercentage                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);`.                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)                                                                                                                     │
│         external                                                                                                                                                                                                │
│         view                                                                                                                                                                                                    │
│         returns (uint256 lpTokens)                                                                                                                                                                              │
│     {                                                                                                                                                                                                           │
│         (IERC20[] memory ammTokens, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());                                                                                                       │
│         uint256[] memory amountsOut = new uint256[](2);                                                                                                                                                         │
│         (amountsOut[0], amountsOut[1]) = (address(ammTokens[0]) == address(tempusPool.principalShare()))                                                                                                        │
│             ? (principalsStaked, yieldsStaked)                                                                                                                                                                  │
│             : (yieldsStaked, principalsStaked);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         uint256[] memory scalingFactors = _scalingFactors();                                                                                                                                                    │
│         _upscaleArray(amountsOut, scalingFactors);                                                                                                                                                              │
│         _upscaleArray(balances, scalingFactors);                                                                                                                                                                │
│         uint256[] memory tokenRates = _getTokenRatesStored();                                                                                                                                                   │
│         amountsOut.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                    │
│         balances.mul(tokenRates, _TEMPUS_SHARE_PRECISION);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 protocolSwapFeePercentage = getSwapFeePercentage();                                                                                                                                             │
│         if (_isNotPaused()) {                                                                                                                                                                                   │
│             // Update current balances by subtracting the protocol fee amounts                                                                                                                                  │
│             balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));                                                                                                                       │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (uint256 currentAmp, ) = _getAmplificationParameter();                                                                                                                                                  │
│         lpTokens = StableMath._calcBptInGivenExactTokensOut(                                                                                                                                                    │
│             currentAmp,                                                                                                                                                                                         │
│             balances,                                                                                                                                                                                           │
│             amountsOut,                                                                                                                                                                                         │
│             totalSupply(),                                                                                                                                                                                      │
│             protocolSwapFeePercentage                                                                                                                                                                           │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `balances.sub(_getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage));`                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:08] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:260
                             function: getExpectedBPTInGivenTokensOut, current vul: wrong-order-interest                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "bptAmountOut": "Holds the value of total minted share or amount"                                                                                                                                       │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "totalSupply()": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                        │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "amountsIn": "Holds the value of the deposit/mint/add amount"                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:09] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:260
                             function: _joinExactTokensInForBPTOut, current vul: first-deposit                                                                                                                     
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "bptAmountOut": "Variable holding the value of total minted share or amount"                                                                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "balances": "Variable holding the total supply/liquidity AND used by the conditional branch to determine the supply/liquidity is 0"                                                                     │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "amountsIn": "Variable holding the value of the deposit/mint/add amount"                                                                                                                                │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:10] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _joinExactTokensInForBPTOut, current vul: first-deposit                                                                                                                     
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_token0.getPricePerFullShare()": "Market reserves/AMM price/exchange rate of token0",                                                                                                                  │
│         "_token1.getPricePerFullShare()": "Market reserves/AMM price/exchange rate of token1"                                                                                                                   │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "rates": "Calculated values/prices of LP tokens"                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:11] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:260
                             function: _getTokenRates, current vul: price-manipulation                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balances": "Holds the market reserves/AMM price/exchange rate or the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                  │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "bptAmountOut": "Holds the calculated value/price of LP token"                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:12] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRates, current vul: price-manipulation                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balances": "Array holding market reserves/AMMprice/exchangeRate or custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "bptAmountOut": "Variable holding the calculated value/price of LP token"                                                                                                                               │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:13] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRates, current vul: price-manipulation                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "currentAmp": "Variable holding the current amplification parameter"                                                                                                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "bptAmountIn": "Variable holding the calculated BPT amount in"                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRates, current vul: price-manipulation                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 310, in simple_cli                                                                                       
                                 raise Exception(                                                                                                                                                                  
                             Exception: The description of variable did not pass the validation                                                                                                                    
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "tokenRates": "Array holding the token rates for LP token calculation"                                                                                                                                      │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "bptAmountOut": "Variable holding the calculated value/price of LP token"                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:14] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRates, current vul: price-manipulation                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balances": "Holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "bptAmountIn": "Holds the calculated value/price of LP token"                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:15] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRates, current vul: price-manipulation                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_token0.getPricePerFullShareStored()": "Market reserves/AMM price/exchange rate of token0",                                                                                                            │
│         "_token1.getPricePerFullShareStored()": "Market reserves/AMM price/exchange rate of token1"                                                                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "rates": "Calculated values/prices of LP tokens"                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:16] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:260
                             function: _getTokenRatesStored, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balances": "Array holding pool token balances",                                                                                                                                                        │
│         "currentAmp": "Variable holding current amplification parameter",                                                                                                                                       │
│         "tokenIn": "Variable holding input pool share token",                                                                                                                                                   │
│         "tokenOut": "Variable holding output pool share token",                                                                                                                                                 │
│         "indexIn": "Index of input token in balances array",                                                                                                                                                    │
│         "indexOut": "Index of output token in balances array",                                                                                                                                                  │
│         "rateAdjustedSwapAmount": "Variable holding rate adjusted swap amount"                                                                                                                                  │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "amountOut": "Variable holding the calculated amount out"                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:17] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRatesStored, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balances": "Array holding market reserves/AMMprice/exchangeRate or custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "currentAmp": "Variable holding the calculated value/price of LP token"                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:19] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRatesStored, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balances": "Holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "lpTokens": "Holds the calculated value/price of LP token"                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRatesStored, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balances": "Array holding the token balances of the pool"                                                                                                                                              │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "invariant": "Variable holding the calculated invariant value"                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:20] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:359
                             function: _getTokenRatesStored, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│     function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {                                                                                                    │
│         _require(rawEndValue >= _MIN_AMP, Errors.MIN_AMP);                                                                                                                                                      │
│         _require(rawEndValue <= _MAX_AMP, Errors.MAX_AMP);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 duration = Math.sub(endTime, block.timestamp);                                                                                                                                                  │
│         _require(duration >= _MIN_UPDATE_TIME, Errors.AMP_END_TIME_TOO_CLOSE);                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();                                                                                                                                 │
│         _require(!isUpdating, Errors.AMP_ONGOING_UPDATE);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 endValue = Math.mul(rawEndValue, _AMP_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // daily rate = (endValue / currentValue) / duration * 1 day                                                                                                                                            │
│         // We perform all multiplications first to not reduce precision, and round the division up as we want to avoid                                                                                          │
│         // large rates. Note that these are regular integer multiplications and divisions, not fixed point.                                                                                                     │
│         uint256 dailyRate = endValue > currentValue                                                                                                                                                             │
│             ? Math.divUp(Math.mul(1 days, endValue), Math.mul(currentValue, duration))                                                                                                                          │
│             : Math.divUp(Math.mul(1 days, currentValue), Math.mul(endValue, duration));                                                                                                                         │
│         _require(dailyRate <= _MAX_AMP_UPDATE_DAILY_RATE, Errors.AMP_RATE_TOO_HIGH);                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _setAmplificationData(currentValue, endValue, block.timestamp, endTime);                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `uint256 endValue = Math.mul(rawEndValue, _AMP_PRECISION);`.                                                                                     │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {                                                                                                    │
│         _require(rawEndValue >= _MIN_AMP, Errors.MIN_AMP);                                                                                                                                                      │
│         _require(rawEndValue <= _MAX_AMP, Errors.MAX_AMP);                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 duration = Math.sub(endTime, block.timestamp);                                                                                                                                                  │
│         _require(duration >= _MIN_UPDATE_TIME, Errors.AMP_END_TIME_TOO_CLOSE);                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();                                                                                                                                 │
│         _require(!isUpdating, Errors.AMP_ONGOING_UPDATE);                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 endValue = Math.mul(rawEndValue, _AMP_PRECISION);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // daily rate = (endValue / currentValue) / duration * 1 day                                                                                                                                            │
│         // We perform all multiplications first to not reduce precision, and round the division up as we want to avoid                                                                                          │
│         // large rates. Note that these are regular integer multiplications and divisions, not fixed point.                                                                                                     │
│         uint256 dailyRate = endValue > currentValue                                                                                                                                                             │
│             ? Math.divUp(Math.mul(1 days, endValue), Math.mul(currentValue, duration))                                                                                                                          │
│             : Math.divUp(Math.mul(1 days, currentValue), Math.mul(endValue, duration));                                                                                                                         │
│         _require(dailyRate <= _MAX_AMP_UPDATE_DAILY_RATE, Errors.AMP_RATE_TOO_HIGH);                                                                                                                            │
│                                                                                                                                                                                                                 │
│         _setAmplificationData(currentValue, endValue, block.timestamp, endTime);                                                                                                                                │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 endValue = Math.mul(rawEndValue, _AMP_PRECISION);`                                                                                                                                                     │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:16:21] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2021-10-tempus-main/contracts/amm/TempusAMM.sol, current          tasks.py:260
                             function: startAmplificationParameterUpdate, current vul: wrong-order-interest                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                   Summary                   
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value              ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 37                 │
│ Contracts            │ 40                 │
│ Functions            │ 100                │
│ Lines of Code        │ 4483               │
│ Used Time            │ 274.54227805137634 │
│ Estimated Cost (USD) │ 0.097315           │
└──────────────────────┴────────────────────┘
