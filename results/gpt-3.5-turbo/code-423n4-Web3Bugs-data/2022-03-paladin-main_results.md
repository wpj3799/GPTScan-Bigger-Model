

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[19:41:32] Loaded 10 rules                                                                                                                                                                             tasks.py:119
[12/08/24 19:41:32] ERROR    CryticCompile: Cannot execute `forge`, is it installed and in PATH?                                                                                                   subprocess.py:38
                    ERROR    CryticCompile: Cannot execute `forge`, is it installed and in PATH?                                                                                                   subprocess.py:38
           Traceback (most recent call last):                                                                                                                                                          tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                     
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                    
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                    
               self._compile(**kwargs)                                                                                                                                                                             
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                    
               self._platform.compile(self, **kwargs)                                                                                                                                                              
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/foundry.py", line 67, in compile                                                    
               hardhat_like_parsing(crytic_compile, self._target, build_directory, self._target)                                                                                                                   
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 52, in hardhat_like_parsing                                       
               raise InvalidCompilation(txt)                                                                                                                                                                       
           crytic_compile.platform.exceptions.InvalidCompilation: Compilation failed. Can you run build command?                                                                                                   
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-03-paladin-main/out/build-info is not a directory.                                                              
                                                                                                                                                                                                                   
           During handling of the above exception, another exception occurred:                                                                                                                                     
                                                                                                                                                                                                                   
           Traceback (most recent call last):                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                         
               falcon_instance = compile_project(source_dir)                                                                                                                                                       
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                    
               return falcon.Falcon(abs_path)                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                     
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                               
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                     
           Compilation failed. Can you run build command?                                                                                                                                                          
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-03-paladin-main/out/build-info is not a directory.                                                              
                                                                                                                                                                                                                   
           Compile failed.                                                                                                                                                                             tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                  tasks.py:128
[12/08/24 19:41:36] INFO     antlr4helper.callgraph: In whitelist: AccessControl.renounceRole(bytes32,address) returns()                                                                            callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: AccessControl._setRoleAdmin(bytes32,bytes32) returns()                                                                           callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: ECDSA.recover(bytes32,bytes) returns(address)                                                                                    callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: Address.sendValue(address,uint) returns()                                                                                        callgraph.py:21
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function cooldown() external {                                                                                                                                                                              │
│         require(balanceOf(msg.sender) > 0, "hPAL: No balance");                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Set the current timestamp as start of the user cooldown                                                                                                                                              │
│         cooldowns = block.timestamp;                                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         emit Cooldown(msg.sender);                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {                                                                                          │
│         uint256 senderCooldown = cooldowns;                                                                                                                                                                     │
│         uint256 receiverBalance = balanceOf(receiver);                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         return _getNewReceiverCooldown(                                                                                                                                                                         │
│             senderCooldown,                                                                                                                                                                                     │
│             amount,                                                                                                                                                                                             │
│             receiver,                                                                                                                                                                                           │
│             receiverBalance                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {                                                                                                                    │
│         require(                                                                                                                                                                                                │
│             blockNumber < block.number,                                                                                                                                                                         │
│             "hPAL: invalid blockNumber"                                                                                                                                                                         │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         TotalLock memory emptyLock = TotalLock(                                                                                                                                                                 │
│             0,                                                                                                                                                                                                  │
│             0                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 nbCheckpoints = totalLocks.length;                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // last checkpoint check                                                                                                                                                                                │
│         if (totalLocks.fromBlock <= blockNumber) {                                                                                                                                                              │
│             return totalLocks;                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // no checkpoint old enough                                                                                                                                                                             │
│         if (totalLocks[0].fromBlock > blockNumber) {                                                                                                                                                            │
│             return emptyLock;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 high = nbCheckpoints - 1; // last checkpoint already checked                                                                                                                                    │
│         uint256 low = 0;                                                                                                                                                                                        │
│         uint256 mid;                                                                                                                                                                                            │
│         while (low < high) {                                                                                                                                                                                    │
│             mid = Math.average(low, high);                                                                                                                                                                      │
│             if (totalLocks.fromBlock == blockNumber) {                                                                                                                                                          │
│                 return totalLocks;                                                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│             if (totalLocks.fromBlock > blockNumber) {                                                                                                                                                           │
│                 high = mid;                                                                                                                                                                                     │
│             } else {                                                                                                                                                                                            │
│                 low = mid + 1;                                                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         return high == 0 ? emptyLock : totalLocks;                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function allBalancesOf(address user) external view returns(                                                                                                                                                 │
│         uint256 staked,                                                                                                                                                                                         │
│         uint256 locked,                                                                                                                                                                                         │
│         uint256 available                                                                                                                                                                                       │
│     ) {                                                                                                                                                                                                         │
│         // If the contract was blocked (emergency mode) or                                                                                                                                                      │
│         // If the user has no Lock                                                                                                                                                                              │
│         // then available == staked                                                                                                                                                                             │
│         if(emergency || userLocks.length == 0) {                                                                                                                                                                │
│             return(                                                                                                                                                                                             │
│                 balanceOf(user),                                                                                                                                                                                │
│                 0,                                                                                                                                                                                              │
│                 balanceOf(user)                                                                                                                                                                                 │
│             );                                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // If a Lock exists                                                                                                                                                                                     │
│         // Then return                                                                                                                                                                                          │
│         // total staked balance                                                                                                                                                                                 │
│         // locked balance                                                                                                                                                                                       │
│         // available balance (staked - locked)                                                                                                                                                                  │
│         uint256 lastUserLockIndex = userLocks.length - 1;                                                                                                                                                       │
│         return(                                                                                                                                                                                                 │
│             balanceOf(user),                                                                                                                                                                                    │
│             uint256(userLocks.amount),                                                                                                                                                                          │
│             balanceOf(user) - uint256(userLocks.amount)                                                                                                                                                         │
│         );                                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function getCurrentVotes(address user) external view returns (uint256) {                                                                                                                                    │
│         if(emergency) return 0; //If emergency mode, do not show voting power                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 nbCheckpoints = checkpoints.length;                                                                                                                                                             │
│         // current votes with delegation                                                                                                                                                                        │
│         uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints.votes;                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // check if user has a lock                                                                                                                                                                             │
│         uint256 nbLocks = userLocks.length;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         if(nbLocks == 0) return currentVotes;                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // and if there is a lock, and user self-delegate, add the bonus voting power                                                                                                                           │
│         uint256 lockAmount = userLocks.amount;                                                                                                                                                                  │
│         uint256 bonusVotes = delegates == user && userLocks.duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;                                                                                │
│                                                                                                                                                                                                                 │
│         return currentVotes + bonusVotes;                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function getPastDelegate(address account, uint256 blockNumber)                                                                                                                                              │
│         public                                                                                                                                                                                                  │
│         view                                                                                                                                                                                                    │
│         returns (address)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         require(                                                                                                                                                                                                │
│             blockNumber < block.number,                                                                                                                                                                         │
│             "hPAL: invalid blockNumber"                                                                                                                                                                         │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // no checkpoints written                                                                                                                                                                               │
│         uint256 nbCheckpoints = delegateCheckpoints.length;                                                                                                                                                     │
│         if (nbCheckpoints == 0) return address(0);                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // last checkpoint check                                                                                                                                                                                │
│         if (delegateCheckpoints.fromBlock <= blockNumber) {                                                                                                                                                     │
│             return delegateCheckpoints.delegate;                                                                                                                                                                │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // no checkpoint old enough                                                                                                                                                                             │
│         if (delegateCheckpoints[0].fromBlock > blockNumber) {                                                                                                                                                   │
│             return address(0);                                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 high = nbCheckpoints - 1; // last checkpoint already checked                                                                                                                                    │
│         uint256 low = 0;                                                                                                                                                                                        │
│         uint256 mid;                                                                                                                                                                                            │
│         while (low < high) {                                                                                                                                                                                    │
│             mid = Math.average(low, high);                                                                                                                                                                      │
│             if (delegateCheckpoints.fromBlock == blockNumber) {                                                                                                                                                 │
│                 return delegateCheckpoints.delegate;                                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│             if (delegateCheckpoints.fromBlock > blockNumber) {                                                                                                                                                  │
│                 high = mid;                                                                                                                                                                                     │
│             } else {                                                                                                                                                                                            │
│                 low = mid + 1;                                                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         return high == 0 ? address(0) : delegateCheckpoints.delegate;                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _availableBalanceOf(address user) internal view returns(uint256) {                                                                                                                                 │
│         if(userLocks.length == 0) return balanceOf(user);                                                                                                                                                       │
│         uint256 lastUserLockIndex = userLocks.length - 1;                                                                                                                                                       │
│         return balanceOf(user) - uint256(userLocks.amount);                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _beforeTokenTransfer(                                                                                                                                                                              │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount                                                                                                                                                                                          │
│     ) internal virtual override {                                                                                                                                                                               │
│         if(from != address(0)) { //check must be skipped on minting                                                                                                                                             │
│             // Only allow the balance that is unlocked to be transfered                                                                                                                                         │
│             require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(from);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 fromCooldown = cooldowns; //If from is address 0x00...0, cooldown is always 0                                                                                                                   │
│                                                                                                                                                                                                                 │
│         if(from != to) {                                                                                                                                                                                        │
│             // Update user rewards before any change on their balance (staked and locked)                                                                                                                       │
│             _updateUserRewards(to);                                                                                                                                                                             │
│             // => we don't want a self-transfer to double count new claimable rewards                                                                                                                           │
│             // + no need to update the cooldown on a self-transfer                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             uint256 previousToBalance = balanceOf(to);                                                                                                                                                          │
│             cooldowns = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If from transfer all of its balance, reset the cooldown to 0                                                                                                                                         │
│         uint256 previousFromBalance = balanceOf(from);                                                                                                                                                          │
│         if(previousFromBalance == amount && fromCooldown != 0) {                                                                                                                                                │
│             cooldowns = 0;                                                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _availableBalanceOf(address user) internal view returns(uint256) {                                                                                                                                 │
│         if(userLocks.length == 0) return balanceOf(user);                                                                                                                                                       │
│         uint256 lastUserLockIndex = userLocks.length - 1;                                                                                                                                                       │
│         return balanceOf(user) - uint256(userLocks.amount);                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {                                                                                                               │
│         require(amount > 0, "hPAL: Null amount");                                                                                                                                                               │
│         require(receiver != address(0), "hPAL: Address Zero");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // Check if user in inside the allowed period base on its cooldown                                                                                                                                      │
│         uint256 userCooldown = cooldowns;                                                                                                                                                                       │
│         require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");                                                                                                             │
│         require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");                                                                                          │
│                                                                                                                                                                                                                 │
│         // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Can only unstake was is available, need to unlock before                                                                                                                                             │
│         uint256 userAvailableBalance = _availableBalanceOf(user);                                                                                                                                               │
│         uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Burn the hPAL 1:1 with PAL                                                                                                                                                                           │
│         _burn(user, burnAmount);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // Then transfer the PAL to the user                                                                                                                                                                    │
│         pal.safeTransfer(receiver, burnAmount);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Unstake(user, burnAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return burnAmount;                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function _availableBalanceOf(address user) internal view returns(uint256) {                                                                                                                                 │
│         if(userLocks.length == 0) return balanceOf(user);                                                                                                                                                       │
│         uint256 lastUserLockIndex = userLocks.length - 1;                                                                                                                                                       │
│         return balanceOf(user) - uint256(userLocks.amount);                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _getUserAccruedRewards(                                                                                                                                                                            │
│         address user,                                                                                                                                                                                           │
│         uint256 currentRewardsIndex                                                                                                                                                                             │
│     ) internal view returns(                                                                                                                                                                                    │
│         uint256 accruedRewards,                                                                                                                                                                                 │
│         uint256 newBonusRatio                                                                                                                                                                                   │
│     ) {                                                                                                                                                                                                         │
│         // Find the user last index & current balances                                                                                                                                                          │
│         uint256 userLastIndex = userRewardIndex;                                                                                                                                                                │
│         uint256 userStakedBalance = _availableBalanceOf(user);                                                                                                                                                  │
│         uint256 userLockedBalance = 0;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if(userLastIndex != currentRewardsIndex){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             if(balanceOf(user) > 0){                                                                                                                                                                            │
│                 // calculate the base rewards for the user staked balance                                                                                                                                       │
│                 // (using avaialable balance to count the locked balance with the multiplier later in this function)                                                                                            │
│                 uint256 indexDiff = currentRewardsIndex - userLastIndex;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;                                                                                                                                │
│                                                                                                                                                                                                                 │
│                 uint256 lockingRewards = 0;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│                 if(userLocks.length > 0){                                                                                                                                                                       │
│                     UserLockRewardVars memory vars;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                     // and if an user has a lock, calculate the locked rewards                                                                                                                                  │
│                     vars.lastUserLockIndex = userLocks.length - 1;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // using the locked balance, and the lock duration                                                                                                                                          │
│                     userLockedBalance = uint256(userLocks.amount);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // Check that the user's Lock is not empty                                                                                                                                                  │
│                     if(userLockedBalance > 0 && userLocks.duration != 0){                                                                                                                                       │
│                         vars.previousBonusRatio = userCurrentBonusRatio;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                         if(vars.previousBonusRatio > 0){                                                                                                                                                        │
│                             vars.userRatioDecrease = userBonusRatioDecrease;                                                                                                                                    │
│                             // Find the new multiplier for user:                                                                                                                                                │
│                             // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                                                                                    │
│                             vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate) * vars.userRatioDecrease;                                                                                           │
│                                                                                                                                                                                                                 │
│                             newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                                                         │
│                                                                                                                                                                                                                 │
│                             if(vars.bonusRatioDecrease >= vars.previousBonusRatio){                                                                                                                             │
│                                 // Since the last update, bonus ratio decrease under 0                                                                                                                          │
│                                 // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                                                                                         │
│                                 vars.bonusRatioDecrease = vars.previousBonusRatio;                                                                                                                              │
│                                 // In the case this update is made far after the end of the lock, this method would mean                                                                                        │
│                                 // the user could get a multiplier for longer than expected                                                                                                                     │
│                                 // We count on the Kick logic to avoid that scenario                                                                                                                            │
│                             }                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│                             // and calculate the locking rewards based on the locked balance &                                                                                                                  │
│                             // a ratio based on the rpevious one and the newly calculated one                                                                                                                   │
│                             vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                                                                                   │
│                             lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                                                                                         │
│                         }                                                                                                                                                                                       │
│                     }                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                 // sum up the accrued rewards, and return it                                                                                                                                                    │
│                 accruedRewards = stakingRewards + lockingRewards;                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _availableBalanceOf(address user) internal view returns(uint256) {                                                                                                                                 │
│         if(userLocks.length == 0) return balanceOf(user);                                                                                                                                                       │
│         uint256 lastUserLockIndex = userLocks.length - 1;                                                                                                                                                       │
│         return balanceOf(user) - uint256(userLocks.amount);                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _getUserAccruedRewards(                                                                                                                                                                            │
│         address user,                                                                                                                                                                                           │
│         uint256 currentRewardsIndex                                                                                                                                                                             │
│     ) internal view returns(                                                                                                                                                                                    │
│         uint256 accruedRewards,                                                                                                                                                                                 │
│         uint256 newBonusRatio                                                                                                                                                                                   │
│     ) {                                                                                                                                                                                                         │
│         // Find the user last index & current balances                                                                                                                                                          │
│         uint256 userLastIndex = userRewardIndex;                                                                                                                                                                │
│         uint256 userStakedBalance = _availableBalanceOf(user);                                                                                                                                                  │
│         uint256 userLockedBalance = 0;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if(userLastIndex != currentRewardsIndex){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             if(balanceOf(user) > 0){                                                                                                                                                                            │
│                 // calculate the base rewards for the user staked balance                                                                                                                                       │
│                 // (using avaialable balance to count the locked balance with the multiplier later in this function)                                                                                            │
│                 uint256 indexDiff = currentRewardsIndex - userLastIndex;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;                                                                                                                                │
│                                                                                                                                                                                                                 │
│                 uint256 lockingRewards = 0;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│                 if(userLocks.length > 0){                                                                                                                                                                       │
│                     UserLockRewardVars memory vars;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                     // and if an user has a lock, calculate the locked rewards                                                                                                                                  │
│                     vars.lastUserLockIndex = userLocks.length - 1;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // using the locked balance, and the lock duration                                                                                                                                          │
│                     userLockedBalance = uint256(userLocks.amount);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // Check that the user's Lock is not empty                                                                                                                                                  │
│                     if(userLockedBalance > 0 && userLocks.duration != 0){                                                                                                                                       │
│                         vars.previousBonusRatio = userCurrentBonusRatio;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                         if(vars.previousBonusRatio > 0){                                                                                                                                                        │
│                             vars.userRatioDecrease = userBonusRatioDecrease;                                                                                                                                    │
│                             // Find the new multiplier for user:                                                                                                                                                │
│                             // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                                                                                    │
│                             vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate) * vars.userRatioDecrease;                                                                                           │
│                                                                                                                                                                                                                 │
│                             newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                                                         │
│                                                                                                                                                                                                                 │
│                             if(vars.bonusRatioDecrease >= vars.previousBonusRatio){                                                                                                                             │
│                                 // Since the last update, bonus ratio decrease under 0                                                                                                                          │
│                                 // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                                                                                         │
│                                 vars.bonusRatioDecrease = vars.previousBonusRatio;                                                                                                                              │
│                                 // In the case this update is made far after the end of the lock, this method would mean                                                                                        │
│                                 // the user could get a multiplier for longer than expected                                                                                                                     │
│                                 // We count on the Kick logic to avoid that scenario                                                                                                                            │
│                             }                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│                             // and calculate the locking rewards based on the locked balance &                                                                                                                  │
│                             // a ratio based on the rpevious one and the newly calculated one                                                                                                                   │
│                             vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                                                                                   │
│                             lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                                                                                         │
│                         }                                                                                                                                                                                       │
│                     }                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                 // sum up the accrued rewards, and return it                                                                                                                                                    │
│                 accruedRewards = stakingRewards + lockingRewards;                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _availableBalanceOf(address user) internal view returns(uint256) {                                                                                                                                 │
│         if(userLocks.length == 0) return balanceOf(user);                                                                                                                                                       │
│         uint256 lastUserLockIndex = userLocks.length - 1;                                                                                                                                                       │
│         return balanceOf(user) - uint256(userLocks.amount);                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){                                                                                                                       │
│         // Get the current total Supply                                                                                                                                                                         │
│         uint256 currentTotalSupply = totalSupply();                                                                                                                                                             │
│         // and the seconds since the last update                                                                                                                                                                │
│         uint256 ellapsedTime = block.timestamp - lastRewardUpdate;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // DropPerSeond without any multiplier => the base dropPerSecond for stakers                                                                                                                            │
│         // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.                                                                                                      │
│         uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // total base reward (without multiplier) to be distributed since last update                                                                                                                           │
│         uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;                                                                                                                                           │
│                                                                                                                                                                                                                 │
│          // calculate the ratio to add to the index                                                                                                                                                             │
│         uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;                                                                                                           │
│                                                                                                                                                                                                                 │
│         return rewardIndex + ratio;                                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function estimateClaimableRewards(address user) external view returns(uint256) {                                                                                                                            │
│         // no rewards for address 0x0                                                                                                                                                                           │
│         // & in case of emergency mode, show 0                                                                                                                                                                  │
│         if(emergency || user == address(0)) return 0;                                                                                                                                                           │
│         // If the user rewards where updated on that block, then return the last updated value                                                                                                                  │
│         if(rewardsLastUpdate == block.timestamp) return claimableRewards;                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Get the user current claimable amount                                                                                                                                                                │
│         uint256 estimatedClaimableRewards = claimableRewards;                                                                                                                                                   │
│         // Get the last updated reward index                                                                                                                                                                    │
│         uint256 currentRewardIndex = rewardIndex;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         if(lastRewardUpdate < block.timestamp){                                                                                                                                                                 │
│             // If needed, update the reward index                                                                                                                                                               │
│             currentRewardIndex = _getNewIndex(currentDropPerSecond);                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);                                                                                                                           │
│                                                                                                                                                                                                                 │
│         estimatedClaimableRewards += accruedRewards;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         return estimatedClaimableRewards;                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){                                                                                                                       │
│         // Get the current total Supply                                                                                                                                                                         │
│         uint256 currentTotalSupply = totalSupply();                                                                                                                                                             │
│         // and the seconds since the last update                                                                                                                                                                │
│         uint256 ellapsedTime = block.timestamp - lastRewardUpdate;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // DropPerSeond without any multiplier => the base dropPerSecond for stakers                                                                                                                            │
│         // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.                                                                                                      │
│         uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // total base reward (without multiplier) to be distributed since last update                                                                                                                           │
│         uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;                                                                                                                                           │
│                                                                                                                                                                                                                 │
│          // calculate the ratio to add to the index                                                                                                                                                             │
│         uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;                                                                                                           │
│                                                                                                                                                                                                                 │
│         return rewardIndex + ratio;                                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _updateRewardState() internal returns (uint256){                                                                                                                                                   │
│         if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block                                                                                                           │
│                                                                                                                                                                                                                 │
│         // Update (if needed) & get the current DropPerSecond                                                                                                                                                   │
│         uint256 _currentDropPerSecond = _updateDropPerSecond();                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         // Update the index                                                                                                                                                                                     │
│         uint256 newIndex = _getNewIndex(_currentDropPerSecond);                                                                                                                                                 │
│         rewardIndex = newIndex;                                                                                                                                                                                 │
│         lastRewardUpdate = block.timestamp;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         return newIndex;                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){                                                                                                                       │
│         // Get the current total Supply                                                                                                                                                                         │
│         uint256 currentTotalSupply = totalSupply();                                                                                                                                                             │
│         // and the seconds since the last update                                                                                                                                                                │
│         uint256 ellapsedTime = block.timestamp - lastRewardUpdate;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         // DropPerSeond without any multiplier => the base dropPerSecond for stakers                                                                                                                            │
│         // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.                                                                                                      │
│         uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // total base reward (without multiplier) to be distributed since last update                                                                                                                           │
│         uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;                                                                                                                                           │
│                                                                                                                                                                                                                 │
│          // calculate the ratio to add to the index                                                                                                                                                             │
│         uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;                                                                                                           │
│                                                                                                                                                                                                                 │
│         return rewardIndex + ratio;                                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _getUserAccruedRewards(                                                                                                                                                                            │
│         address user,                                                                                                                                                                                           │
│         uint256 currentRewardsIndex                                                                                                                                                                             │
│     ) internal view returns(                                                                                                                                                                                    │
│         uint256 accruedRewards,                                                                                                                                                                                 │
│         uint256 newBonusRatio                                                                                                                                                                                   │
│     ) {                                                                                                                                                                                                         │
│         // Find the user last index & current balances                                                                                                                                                          │
│         uint256 userLastIndex = userRewardIndex;                                                                                                                                                                │
│         uint256 userStakedBalance = _availableBalanceOf(user);                                                                                                                                                  │
│         uint256 userLockedBalance = 0;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if(userLastIndex != currentRewardsIndex){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             if(balanceOf(user) > 0){                                                                                                                                                                            │
│                 // calculate the base rewards for the user staked balance                                                                                                                                       │
│                 // (using avaialable balance to count the locked balance with the multiplier later in this function)                                                                                            │
│                 uint256 indexDiff = currentRewardsIndex - userLastIndex;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;                                                                                                                                │
│                                                                                                                                                                                                                 │
│                 uint256 lockingRewards = 0;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│                 if(userLocks.length > 0){                                                                                                                                                                       │
│                     UserLockRewardVars memory vars;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                     // and if an user has a lock, calculate the locked rewards                                                                                                                                  │
│                     vars.lastUserLockIndex = userLocks.length - 1;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // using the locked balance, and the lock duration                                                                                                                                          │
│                     userLockedBalance = uint256(userLocks.amount);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // Check that the user's Lock is not empty                                                                                                                                                  │
│                     if(userLockedBalance > 0 && userLocks.duration != 0){                                                                                                                                       │
│                         vars.previousBonusRatio = userCurrentBonusRatio;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                         if(vars.previousBonusRatio > 0){                                                                                                                                                        │
│                             vars.userRatioDecrease = userBonusRatioDecrease;                                                                                                                                    │
│                             // Find the new multiplier for user:                                                                                                                                                │
│                             // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                                                                                    │
│                             vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate) * vars.userRatioDecrease;                                                                                           │
│                                                                                                                                                                                                                 │
│                             newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                                                         │
│                                                                                                                                                                                                                 │
│                             if(vars.bonusRatioDecrease >= vars.previousBonusRatio){                                                                                                                             │
│                                 // Since the last update, bonus ratio decrease under 0                                                                                                                          │
│                                 // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                                                                                         │
│                                 vars.bonusRatioDecrease = vars.previousBonusRatio;                                                                                                                              │
│                                 // In the case this update is made far after the end of the lock, this method would mean                                                                                        │
│                                 // the user could get a multiplier for longer than expected                                                                                                                     │
│                                 // We count on the Kick logic to avoid that scenario                                                                                                                            │
│                             }                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│                             // and calculate the locking rewards based on the locked balance &                                                                                                                  │
│                             // a ratio based on the rpevious one and the newly calculated one                                                                                                                   │
│                             vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                                                                                   │
│                             lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                                                                                         │
│                         }                                                                                                                                                                                       │
│                     }                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                 // sum up the accrued rewards, and return it                                                                                                                                                    │
│                 accruedRewards = stakingRewards + lockingRewards;                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _getUserAccruedRewards(                                                                                                                                                                            │
│         address user,                                                                                                                                                                                           │
│         uint256 currentRewardsIndex                                                                                                                                                                             │
│     ) internal view returns(                                                                                                                                                                                    │
│         uint256 accruedRewards,                                                                                                                                                                                 │
│         uint256 newBonusRatio                                                                                                                                                                                   │
│     ) {                                                                                                                                                                                                         │
│         // Find the user last index & current balances                                                                                                                                                          │
│         uint256 userLastIndex = userRewardIndex;                                                                                                                                                                │
│         uint256 userStakedBalance = _availableBalanceOf(user);                                                                                                                                                  │
│         uint256 userLockedBalance = 0;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if(userLastIndex != currentRewardsIndex){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             if(balanceOf(user) > 0){                                                                                                                                                                            │
│                 // calculate the base rewards for the user staked balance                                                                                                                                       │
│                 // (using avaialable balance to count the locked balance with the multiplier later in this function)                                                                                            │
│                 uint256 indexDiff = currentRewardsIndex - userLastIndex;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;                                                                                                                                │
│                                                                                                                                                                                                                 │
│                 uint256 lockingRewards = 0;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│                 if(userLocks.length > 0){                                                                                                                                                                       │
│                     UserLockRewardVars memory vars;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                     // and if an user has a lock, calculate the locked rewards                                                                                                                                  │
│                     vars.lastUserLockIndex = userLocks.length - 1;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // using the locked balance, and the lock duration                                                                                                                                          │
│                     userLockedBalance = uint256(userLocks.amount);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // Check that the user's Lock is not empty                                                                                                                                                  │
│                     if(userLockedBalance > 0 && userLocks.duration != 0){                                                                                                                                       │
│                         vars.previousBonusRatio = userCurrentBonusRatio;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                         if(vars.previousBonusRatio > 0){                                                                                                                                                        │
│                             vars.userRatioDecrease = userBonusRatioDecrease;                                                                                                                                    │
│                             // Find the new multiplier for user:                                                                                                                                                │
│                             // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                                                                                    │
│                             vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate) * vars.userRatioDecrease;                                                                                           │
│                                                                                                                                                                                                                 │
│                             newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                                                         │
│                                                                                                                                                                                                                 │
│                             if(vars.bonusRatioDecrease >= vars.previousBonusRatio){                                                                                                                             │
│                                 // Since the last update, bonus ratio decrease under 0                                                                                                                          │
│                                 // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                                                                                         │
│                                 vars.bonusRatioDecrease = vars.previousBonusRatio;                                                                                                                              │
│                                 // In the case this update is made far after the end of the lock, this method would mean                                                                                        │
│                                 // the user could get a multiplier for longer than expected                                                                                                                     │
│                                 // We count on the Kick logic to avoid that scenario                                                                                                                            │
│                             }                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│                             // and calculate the locking rewards based on the locked balance &                                                                                                                  │
│                             // a ratio based on the rpevious one and the newly calculated one                                                                                                                   │
│                             vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                                                                                   │
│                             lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                                                                                         │
│                         }                                                                                                                                                                                       │
│                     }                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                 // sum up the accrued rewards, and return it                                                                                                                                                    │
│                 accruedRewards = stakingRewards + lockingRewards;                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _updateUserRewards(address user) internal {                                                                                                                                                        │
│         // Update the global reward state and get the latest index                                                                                                                                              │
│         uint256 newIndex = _updateRewardState();                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Called for minting & burning, but we don't want to update for address 0x0                                                                                                                            │
│         if(user == address(0)) return;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if(rewardsLastUpdate == block.timestamp) return; // Already updated for this block                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // Update the user claimable rewards                                                                                                                                                                    │
│         (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);                                                                                                               │
│         claimableRewards += accruedRewards;                                                                                                                                                                     │
│         // Store the new Bonus Ratio                                                                                                                                                                            │
│         userCurrentBonusRatio = newBonusRatio;                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // and set the current timestamp for last update, and the last used index for the user rewards                                                                                                          │
│         rewardsLastUpdate = block.timestamp;                                                                                                                                                                    │
│         userRewardIndex = newIndex;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     function _getUserAccruedRewards(                                                                                                                                                                            │
│         address user,                                                                                                                                                                                           │
│         uint256 currentRewardsIndex                                                                                                                                                                             │
│     ) internal view returns(                                                                                                                                                                                    │
│         uint256 accruedRewards,                                                                                                                                                                                 │
│         uint256 newBonusRatio                                                                                                                                                                                   │
│     ) {                                                                                                                                                                                                         │
│         // Find the user last index & current balances                                                                                                                                                          │
│         uint256 userLastIndex = userRewardIndex;                                                                                                                                                                │
│         uint256 userStakedBalance = _availableBalanceOf(user);                                                                                                                                                  │
│         uint256 userLockedBalance = 0;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if(userLastIndex != currentRewardsIndex){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             if(balanceOf(user) > 0){                                                                                                                                                                            │
│                 // calculate the base rewards for the user staked balance                                                                                                                                       │
│                 // (using avaialable balance to count the locked balance with the multiplier later in this function)                                                                                            │
│                 uint256 indexDiff = currentRewardsIndex - userLastIndex;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;                                                                                                                                │
│                                                                                                                                                                                                                 │
│                 uint256 lockingRewards = 0;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│                 if(userLocks.length > 0){                                                                                                                                                                       │
│                     UserLockRewardVars memory vars;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                     // and if an user has a lock, calculate the locked rewards                                                                                                                                  │
│                     vars.lastUserLockIndex = userLocks.length - 1;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // using the locked balance, and the lock duration                                                                                                                                          │
│                     userLockedBalance = uint256(userLocks.amount);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // Check that the user's Lock is not empty                                                                                                                                                  │
│                     if(userLockedBalance > 0 && userLocks.duration != 0){                                                                                                                                       │
│                         vars.previousBonusRatio = userCurrentBonusRatio;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                         if(vars.previousBonusRatio > 0){                                                                                                                                                        │
│                             vars.userRatioDecrease = userBonusRatioDecrease;                                                                                                                                    │
│                             // Find the new multiplier for user:                                                                                                                                                │
│                             // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                                                                                    │
│                             vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate) * vars.userRatioDecrease;                                                                                           │
│                                                                                                                                                                                                                 │
│                             newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                                                         │
│                                                                                                                                                                                                                 │
│                             if(vars.bonusRatioDecrease >= vars.previousBonusRatio){                                                                                                                             │
│                                 // Since the last update, bonus ratio decrease under 0                                                                                                                          │
│                                 // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                                                                                         │
│                                 vars.bonusRatioDecrease = vars.previousBonusRatio;                                                                                                                              │
│                                 // In the case this update is made far after the end of the lock, this method would mean                                                                                        │
│                                 // the user could get a multiplier for longer than expected                                                                                                                     │
│                                 // We count on the Kick logic to avoid that scenario                                                                                                                            │
│                             }                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│                             // and calculate the locking rewards based on the locked balance &                                                                                                                  │
│                             // a ratio based on the rpevious one and the newly calculated one                                                                                                                   │
│                             vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                                                                                   │
│                             lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                                                                                         │
│                         }                                                                                                                                                                                       │
│                     }                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                 // sum up the accrued rewards, and return it                                                                                                                                                    │
│                 accruedRewards = stakingRewards + lockingRewards;                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function estimateClaimableRewards(address user) external view returns(uint256) {                                                                                                                            │
│         // no rewards for address 0x0                                                                                                                                                                           │
│         // & in case of emergency mode, show 0                                                                                                                                                                  │
│         if(emergency || user == address(0)) return 0;                                                                                                                                                           │
│         // If the user rewards where updated on that block, then return the last updated value                                                                                                                  │
│         if(rewardsLastUpdate == block.timestamp) return claimableRewards;                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Get the user current claimable amount                                                                                                                                                                │
│         uint256 estimatedClaimableRewards = claimableRewards;                                                                                                                                                   │
│         // Get the last updated reward index                                                                                                                                                                    │
│         uint256 currentRewardIndex = rewardIndex;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         if(lastRewardUpdate < block.timestamp){                                                                                                                                                                 │
│             // If needed, update the reward index                                                                                                                                                               │
│             currentRewardIndex = _getNewIndex(currentDropPerSecond);                                                                                                                                            │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);                                                                                                                           │
│                                                                                                                                                                                                                 │
│         estimatedClaimableRewards += accruedRewards;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│         return estimatedClaimableRewards;                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function _getUserAccruedRewards(                                                                                                                                                                            │
│         address user,                                                                                                                                                                                           │
│         uint256 currentRewardsIndex                                                                                                                                                                             │
│     ) internal view returns(                                                                                                                                                                                    │
│         uint256 accruedRewards,                                                                                                                                                                                 │
│         uint256 newBonusRatio                                                                                                                                                                                   │
│     ) {                                                                                                                                                                                                         │
│         // Find the user last index & current balances                                                                                                                                                          │
│         uint256 userLastIndex = userRewardIndex;                                                                                                                                                                │
│         uint256 userStakedBalance = _availableBalanceOf(user);                                                                                                                                                  │
│         uint256 userLockedBalance = 0;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if(userLastIndex != currentRewardsIndex){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│             if(balanceOf(user) > 0){                                                                                                                                                                            │
│                 // calculate the base rewards for the user staked balance                                                                                                                                       │
│                 // (using avaialable balance to count the locked balance with the multiplier later in this function)                                                                                            │
│                 uint256 indexDiff = currentRewardsIndex - userLastIndex;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;                                                                                                                                │
│                                                                                                                                                                                                                 │
│                 uint256 lockingRewards = 0;                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│                 if(userLocks.length > 0){                                                                                                                                                                       │
│                     UserLockRewardVars memory vars;                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                     // and if an user has a lock, calculate the locked rewards                                                                                                                                  │
│                     vars.lastUserLockIndex = userLocks.length - 1;                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // using the locked balance, and the lock duration                                                                                                                                          │
│                     userLockedBalance = uint256(userLocks.amount);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│                     // Check that the user's Lock is not empty                                                                                                                                                  │
│                     if(userLockedBalance > 0 && userLocks.duration != 0){                                                                                                                                       │
│                         vars.previousBonusRatio = userCurrentBonusRatio;                                                                                                                                        │
│                                                                                                                                                                                                                 │
│                         if(vars.previousBonusRatio > 0){                                                                                                                                                        │
│                             vars.userRatioDecrease = userBonusRatioDecrease;                                                                                                                                    │
│                             // Find the new multiplier for user:                                                                                                                                                │
│                             // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                                                                                    │
│                             vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate) * vars.userRatioDecrease;                                                                                           │
│                                                                                                                                                                                                                 │
│                             newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                                                         │
│                                                                                                                                                                                                                 │
│                             if(vars.bonusRatioDecrease >= vars.previousBonusRatio){                                                                                                                             │
│                                 // Since the last update, bonus ratio decrease under 0                                                                                                                          │
│                                 // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                                                                                         │
│                                 vars.bonusRatioDecrease = vars.previousBonusRatio;                                                                                                                              │
│                                 // In the case this update is made far after the end of the lock, this method would mean                                                                                        │
│                                 // the user could get a multiplier for longer than expected                                                                                                                     │
│                                 // We count on the Kick logic to avoid that scenario                                                                                                                            │
│                             }                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│                             // and calculate the locking rewards based on the locked balance &                                                                                                                  │
│                             // a ratio based on the rpevious one and the newly calculated one                                                                                                                   │
│                             vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                                                                                   │
│                             lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                                                                                         │
│                         }                                                                                                                                                                                       │
│                     }                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│                 }                                                                                                                                                                                               │
│                 // sum up the accrued rewards, and return it                                                                                                                                                    │
│                 accruedRewards = stakingRewards + lockingRewards;                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _beforeTokenTransfer(                                                                                                                                                                              │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount                                                                                                                                                                                          │
│     ) internal virtual override {                                                                                                                                                                               │
│         if(from != address(0)) { //check must be skipped on minting                                                                                                                                             │
│             // Only allow the balance that is unlocked to be transfered                                                                                                                                         │
│             require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(from);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 fromCooldown = cooldowns; //If from is address 0x00...0, cooldown is always 0                                                                                                                   │
│                                                                                                                                                                                                                 │
│         if(from != to) {                                                                                                                                                                                        │
│             // Update user rewards before any change on their balance (staked and locked)                                                                                                                       │
│             _updateUserRewards(to);                                                                                                                                                                             │
│             // => we don't want a self-transfer to double count new claimable rewards                                                                                                                           │
│             // + no need to update the cooldown on a self-transfer                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             uint256 previousToBalance = balanceOf(to);                                                                                                                                                          │
│             cooldowns = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If from transfer all of its balance, reset the cooldown to 0                                                                                                                                         │
│         uint256 previousFromBalance = balanceOf(from);                                                                                                                                                          │
│         if(previousFromBalance == amount && fromCooldown != 0) {                                                                                                                                                │
│             cooldowns = 0;                                                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function _beforeTokenTransfer(                                                                                                                                                                              │
│         address from,                                                                                                                                                                                           │
│         address to,                                                                                                                                                                                             │
│         uint256 amount                                                                                                                                                                                          │
│     ) internal virtual override {                                                                                                                                                                               │
│         if(from != address(0)) { //check must be skipped on minting                                                                                                                                             │
│             // Only allow the balance that is unlocked to be transfered                                                                                                                                         │
│             require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");                                                                                                                    │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(from);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         uint256 fromCooldown = cooldowns; //If from is address 0x00...0, cooldown is always 0                                                                                                                   │
│                                                                                                                                                                                                                 │
│         if(from != to) {                                                                                                                                                                                        │
│             // Update user rewards before any change on their balance (staked and locked)                                                                                                                       │
│             _updateUserRewards(to);                                                                                                                                                                             │
│             // => we don't want a self-transfer to double count new claimable rewards                                                                                                                           │
│             // + no need to update the cooldown on a self-transfer                                                                                                                                              │
│                                                                                                                                                                                                                 │
│             uint256 previousToBalance = balanceOf(to);                                                                                                                                                          │
│             cooldowns = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // If from transfer all of its balance, reset the cooldown to 0                                                                                                                                         │
│         uint256 previousFromBalance = balanceOf(from);                                                                                                                                                          │
│         if(previousFromBalance == amount && fromCooldown != 0) {                                                                                                                                                │
│             cooldowns = 0;                                                                                                                                                                                      │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {                                                                                                        │
│         require(                                                                                                                                                                                                │
│             blockNumber < block.number,                                                                                                                                                                         │
│             "hPAL: invalid blockNumber"                                                                                                                                                                         │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         UserLock memory emptyLock = UserLock(                                                                                                                                                                   │
│             0,                                                                                                                                                                                                  │
│             0,                                                                                                                                                                                                  │
│             0,                                                                                                                                                                                                  │
│             0                                                                                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // no checkpoints written                                                                                                                                                                               │
│         uint256 nbCheckpoints = userLocks.length;                                                                                                                                                               │
│         if (nbCheckpoints == 0) return emptyLock;                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // last checkpoint check                                                                                                                                                                                │
│         if (userLocks.fromBlock <= blockNumber) {                                                                                                                                                               │
│             return userLocks;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // no checkpoint old enough                                                                                                                                                                             │
│         if (userLocks[0].fromBlock > blockNumber) {                                                                                                                                                             │
│             return emptyLock;                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         uint256 high = nbCheckpoints - 1; // last checkpoint already checked                                                                                                                                    │
│         uint256 low = 0;                                                                                                                                                                                        │
│         uint256 mid;                                                                                                                                                                                            │
│         while (low < high) {                                                                                                                                                                                    │
│             mid = Math.average(low, high);                                                                                                                                                                      │
│             if (userLocks.fromBlock == blockNumber) {                                                                                                                                                           │
│                 return userLocks;                                                                                                                                                                               │
│             }                                                                                                                                                                                                   │
│             if (userLocks.fromBlock > blockNumber) {                                                                                                                                                            │
│                 high = mid;                                                                                                                                                                                     │
│             } else {                                                                                                                                                                                            │
│                 low = mid + 1;                                                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         return high == 0 ? emptyLock : userLocks;                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){                                                                                                               │
│         require( blockNumber < block.number, "hPAL: invalid blockNumber");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         // no checkpoints written                                                                                                                                                                               │
│         uint256 nbCheckpoints = checkpoints.length;                                                                                                                                                             │
│         if (nbCheckpoints == 0) return 0;                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // last checkpoint check                                                                                                                                                                                │
│         if (checkpoints.fromBlock <= blockNumber) {                                                                                                                                                             │
│             return checkpoints.votes;                                                                                                                                                                           │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // no checkpoint old enough                                                                                                                                                                             │
│         if (checkpoints[0].fromBlock > blockNumber) return 0;                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         uint256 high = nbCheckpoints - 1; // last checkpoint already checked                                                                                                                                    │
│         uint256 low = 0;                                                                                                                                                                                        │
│         uint256 mid;                                                                                                                                                                                            │
│         while (low < high) {                                                                                                                                                                                    │
│             mid = Math.average(low, high);                                                                                                                                                                      │
│             if (checkpoints.fromBlock == blockNumber) {                                                                                                                                                         │
│                 return checkpoints.votes;                                                                                                                                                                       │
│             }                                                                                                                                                                                                   │
│             if (checkpoints.fromBlock > blockNumber) {                                                                                                                                                          │
│                 high = mid;                                                                                                                                                                                     │
│             } else {                                                                                                                                                                                            │
│                 low = mid + 1;                                                                                                                                                                                  │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│         return high == 0 ? 0 : checkpoints.votes;                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function _moveDelegates(address from, address to, uint256 amount) internal {                                                                                                                                │
│         if (from != to && amount > 0) {                                                                                                                                                                         │
│             if (from != address(0)) {                                                                                                                                                                           │
│                 // Calculate the change in voting power, then write a new checkpoint                                                                                                                            │
│                 uint256 nbCheckpoints = checkpoints.length;                                                                                                                                                     │
│                 uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints.votes;                                                                                                                                  │
│                 uint256 newVotes = oldVotes - amount;                                                                                                                                                           │
│                 _writeCheckpoint(from, newVotes);                                                                                                                                                               │
│                 emit DelegateVotesChanged(from, oldVotes, newVotes);                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             if (to != address(0)) {                                                                                                                                                                             │
│                 // Calculate the change in voting power, then write a new checkpoint                                                                                                                            │
│                 uint256 nbCheckpoints = checkpoints.length;                                                                                                                                                     │
│                 uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints.votes;                                                                                                                                  │
│                 uint256 newVotes = oldVotes + amount;                                                                                                                                                           │
│                 _writeCheckpoint(to, newVotes);                                                                                                                                                                 │
│                 emit DelegateVotesChanged(to, oldVotes, newVotes);                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint, and have inside code statements that calculate/assigns/distribute the balance/share/stake/fee/loan/reward                                   │
│ Code:                                                                                                                                                                                                           │
│     function _moveDelegates(address from, address to, uint256 amount) internal {                                                                                                                                │
│         if (from != to && amount > 0) {                                                                                                                                                                         │
│             if (from != address(0)) {                                                                                                                                                                           │
│                 // Calculate the change in voting power, then write a new checkpoint                                                                                                                            │
│                 uint256 nbCheckpoints = checkpoints.length;                                                                                                                                                     │
│                 uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints.votes;                                                                                                                                  │
│                 uint256 newVotes = oldVotes - amount;                                                                                                                                                           │
│                 _writeCheckpoint(from, newVotes);                                                                                                                                                               │
│                 emit DelegateVotesChanged(from, oldVotes, newVotes);                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             if (to != address(0)) {                                                                                                                                                                             │
│                 // Calculate the change in voting power, then write a new checkpoint                                                                                                                            │
│                 uint256 nbCheckpoints = checkpoints.length;                                                                                                                                                     │
│                 uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints.votes;                                                                                                                                  │
│                 uint256 newVotes = oldVotes + amount;                                                                                                                                                           │
│                 _writeCheckpoint(to, newVotes);                                                                                                                                                                 │
│                 emit DelegateVotesChanged(to, oldVotes, newVotes);                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that invoke user checkpoint,                                                                                                                                             │
│ Code:                                                                                                                                                                                                           │
│     function _writeCheckpoint(address delegatee, uint256 newVotes) internal {                                                                                                                                   │
│         // write a new checkpoint for an user                                                                                                                                                                   │
│         uint pos = checkpoints.length;                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         if (pos > 0 && checkpoints.fromBlock == block.number) {                                                                                                                                                 │
│             checkpoints.votes = safe224(newVotes);                                                                                                                                                              │
│         } else {                                                                                                                                                                                                │
│             uint32 blockNumber = safe32(block.number);                                                                                                                                                          │
│             checkpoints.push(Checkpoint(blockNumber, safe224(newVotes)));                                                                                                                                       │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {                                                                                                               │
│         require(amount > 0, "hPAL: Null amount");                                                                                                                                                               │
│         require(receiver != address(0), "hPAL: Address Zero");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // Check if user in inside the allowed period base on its cooldown                                                                                                                                      │
│         uint256 userCooldown = cooldowns;                                                                                                                                                                       │
│         require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");                                                                                                             │
│         require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");                                                                                          │
│                                                                                                                                                                                                                 │
│         // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Can only unstake was is available, need to unlock before                                                                                                                                             │
│         uint256 userAvailableBalance = _availableBalanceOf(user);                                                                                                                                               │
│         uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Burn the hPAL 1:1 with PAL                                                                                                                                                                           │
│         _burn(user, burnAmount);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // Then transfer the PAL to the user                                                                                                                                                                    │
│         pal.safeTransfer(receiver, burnAmount);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Unstake(user, burnAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         return burnAmount;                                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {                                                                                                                 │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(userLocks.length != 0, "hPAL: No Lock");                                                                                                                                                        │
│         // Find the current Lock                                                                                                                                                                                │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         uint256 previousLockAmount = userLocks.amount;                                                                                                                                                          │
│         // Stake the new amount                                                                                                                                                                                 │
│         uint256 stakedAmount = _stake(msg.sender, amount);                                                                                                                                                      │
│         // No need to update user rewards since it's done through the _stake() method                                                                                                                           │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // Then update the lock with the new increased amount                                                                                                                                                   │
│         if(duration == userLocks.duration) {                                                                                                                                                                    │
│             _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);                                                                                                               │
│         } else {                                                                                                                                                                                                │
│             _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         return stakedAmount;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {                                                                                                                 │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(userLocks.length != 0, "hPAL: No Lock");                                                                                                                                                        │
│         // Find the current Lock                                                                                                                                                                                │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         uint256 previousLockAmount = userLocks.amount;                                                                                                                                                          │
│         // Stake the new amount                                                                                                                                                                                 │
│         uint256 stakedAmount = _stake(msg.sender, amount);                                                                                                                                                      │
│         // No need to update user rewards since it's done through the _stake() method                                                                                                                           │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // Then update the lock with the new increased amount                                                                                                                                                   │
│         if(duration == userLocks.duration) {                                                                                                                                                                    │
│             _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);                                                                                                               │
│         } else {                                                                                                                                                                                                │
│             _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         return stakedAmount;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {                                                                                                                         │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         // Stake the given amount                                                                                                                                                                               │
│         uint256 stakedAmount = _stake(msg.sender, amount);                                                                                                                                                      │
│         // No need to update user rewards since it's done through the _stake() method                                                                                                                           │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // And then lock it                                                                                                                                                                                     │
│         _lock(msg.sender, amount, duration, LockAction.LOCK);                                                                                                                                                   │
│         return stakedAmount;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {                                                                                                                         │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         // Stake the given amount                                                                                                                                                                               │
│         uint256 stakedAmount = _stake(msg.sender, amount);                                                                                                                                                      │
│         // No need to update user rewards since it's done through the _stake() method                                                                                                                           │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // And then lock it                                                                                                                                                                                     │
│         _lock(msg.sender, amount, duration, LockAction.LOCK);                                                                                                                                                   │
│         return stakedAmount;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function increaseLockDuration(uint256 duration) external {                                                                                                                                                  │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(userLocks.length != 0, "hPAL: No Lock");                                                                                                                                                        │
│         // Find the current Lock                                                                                                                                                                                │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         UserLock storage currentUserLock = userLocks;                                                                                                                                                           │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         // Call the _lock method with the current amount, and the new duration                                                                                                                                  │
│         _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│ "1": "No",                                                                                                                                                                                                      │
│ "2": "Yes"                                                                                                                                                                                                      │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function increaseLockDuration(uint256 duration) external {                                                                                                                                                  │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(userLocks.length != 0, "hPAL: No Lock");                                                                                                                                                        │
│         // Find the current Lock                                                                                                                                                                                │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         UserLock storage currentUserLock = userLocks;                                                                                                                                                           │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         // Call the _lock method with the current amount, and the new duration                                                                                                                                  │
│         _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function lock(uint256 amount, uint256 duration) external {                                                                                                                                                  │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             // If the user does not deelegate currently, automatically self-delegate                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         _lock(msg.sender, amount, duration, LockAction.LOCK);                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function lock(uint256 amount, uint256 duration) external {                                                                                                                                                  │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             // If the user does not deelegate currently, automatically self-delegate                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         _lock(msg.sender, amount, duration, LockAction.LOCK);                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function increaseLock(uint256 amount) external {                                                                                                                                                            │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(userLocks.length != 0, "hPAL: No Lock");                                                                                                                                                        │
│         // Find the current Lock                                                                                                                                                                                │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         UserLock storage currentUserLock = userLocks;                                                                                                                                                           │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         // Call the _lock method with the current duration, and the new amount                                                                                                                                  │
│         _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│         "1": "No",                                                                                                                                                                                              │
│         "2": "Yes"                                                                                                                                                                                              │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function increaseLock(uint256 amount) external {                                                                                                                                                            │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(userLocks.length != 0, "hPAL: No Lock");                                                                                                                                                        │
│         // Find the current Lock                                                                                                                                                                                │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         UserLock storage currentUserLock = userLocks;                                                                                                                                                           │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         // Call the _lock method with the current duration, and the new amount                                                                                                                                  │
│         _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {                                                                                                                │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(amount != 0, "hPAL: Null amount");                                                                                                                                                              │
│         uint256 userBalance = balanceOf(user);                                                                                                                                                                  │
│         require(amount <= userBalance, "hPAL: Amount over balance");                                                                                                                                            │
│         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");                                                                                                                                │
│         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         if(userLocks.length == 0){                                                                                                                                                                              │
│             //User 1st Lock                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(amount),                                                                                                                                                                                │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(duration),                                                                                                                                                                               │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             // find the reward multiplier based on the user lock duration                                                                                                                                       │
│             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                          │
│             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                                │
│                                                                                                                                                                                                                 │
│             userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                         │
│             userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                      │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             currentTotalLocked += amount;                                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);                                                                                                                             │
│         }                                                                                                                                                                                                       │
│         else {                                                                                                                                                                                                  │
│             // Get the current user Lock                                                                                                                                                                        │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│             // Calculate the end of the user current lock                                                                                                                                                       │
│             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                             │
│                                                                                                                                                                                                                 │
│             uint256 startTimestamp = block.timestamp;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│             if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                                                                                                                           │
│                 // User locked, and then unlocked                                                                                                                                                               │
│                 // or user lock expired                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     safe48(startTimestamp),                                                                                                                                                                     │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│             else {                                                                                                                                                                                              │
│                 // Update of the current Lock : increase amount or increase duration                                                                                                                            │
│                 // or renew with the same parameters, but starting at the current timestamp                                                                                                                     │
│                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                                                                                                                              │
│                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                                                                                                                        │
│                                                                                                                                                                                                                 │
│                 // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                                                                                            │
│                                                                                                                                                                                                                 │
│                 userLocks.push(UserLock(                                                                                                                                                                        │
│                     safe128(amount),                                                                                                                                                                            │
│                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                                                                                             │
│                     safe48(duration),                                                                                                                                                                           │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│                 startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;                                                                                        │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // If the duration is updated, re-calculate the multiplier for the Lock                                                                                                                             │
│             if(action != LockAction.INCREASE_AMOUNT){                                                                                                                                                           │
│                 // find the reward multiplier based on the user lock duration                                                                                                                                   │
│                 uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);                                                                                      │
│                 uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);                                                                            │
│                                                                                                                                                                                                                 │
│                 userCurrentBonusRatio = userLockBonusRatio;                                                                                                                                                     │
│                 userBonusRatioDecrease = (userLockBonusRatio - baseLockBonusRatio) / duration;                                                                                                                  │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             // Update total locked supply                                                                                                                                                                       │
│             if(amount != currentUserLock.amount){                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│                 if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;                                                                                                                   │
│                                                                                                                                                                                                                 │
│                 currentTotalLocked += amount;                                                                                                                                                                   │
│                 totalLocks.push(TotalLock(                                                                                                                                                                      │
│                     safe224(currentTotalLocked),                                                                                                                                                                │
│                     safe32(block.number)                                                                                                                                                                        │
│                 ));                                                                                                                                                                                             │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);                                                                                                                              │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _unlock(address user) internal {                                                                                                                                                                   │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(userLocks.length > 0, "hPAL: No Lock");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Get the user current Lock                                                                                                                                                                            │
│         // And calculate the end of the Lock                                                                                                                                                                    │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         UserLock storage currentUserLock = userLocks;                                                                                                                                                           │
│         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                                 │
│                                                                                                                                                                                                                 │
│         require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");                                                                                                                                     │
│         require(currentUserLock.amount > 0, "hPAL: No Lock");                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Remove amount from total locked supply                                                                                                                                                               │
│         currentTotalLocked -= currentUserLock.amount;                                                                                                                                                           │
│         totalLocks.push(TotalLock(                                                                                                                                                                              │
│             safe224(currentTotalLocked),                                                                                                                                                                        │
│             safe32(block.number)                                                                                                                                                                                │
│         ));                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Remove the bonus multiplier                                                                                                                                                                          │
│         userCurrentBonusRatio = 0;                                                                                                                                                                              │
│         userBonusRatioDecrease = 0;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Set the user Lock as an empty Lock                                                                                                                                                                   │
│         userLocks.push(UserLock(                                                                                                                                                                                │
│             safe128(0),                                                                                                                                                                                         │
│             safe48(block.timestamp),                                                                                                                                                                            │
│             safe48(0),                                                                                                                                                                                          │
│             safe32(block.number)                                                                                                                                                                                │
│         ));                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         emit Unlock(user, currentUserLock.amount, currentTotalLocked);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function unlock() external {                                                                                                                                                                                │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(userLocks.length != 0, "hPAL: No Lock");                                                                                                                                                        │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         _unlock(msg.sender);                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _unlock(address user) internal {                                                                                                                                                                   │
│         require(user != address(0)); //Never supposed to happen, but security check                                                                                                                             │
│         require(userLocks.length > 0, "hPAL: No Lock");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Get the user current Lock                                                                                                                                                                            │
│         // And calculate the end of the Lock                                                                                                                                                                    │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         UserLock storage currentUserLock = userLocks;                                                                                                                                                           │
│         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                                 │
│                                                                                                                                                                                                                 │
│         require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");                                                                                                                                     │
│         require(currentUserLock.amount > 0, "hPAL: No Lock");                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         // Remove amount from total locked supply                                                                                                                                                               │
│         currentTotalLocked -= currentUserLock.amount;                                                                                                                                                           │
│         totalLocks.push(TotalLock(                                                                                                                                                                              │
│             safe224(currentTotalLocked),                                                                                                                                                                        │
│             safe32(block.number)                                                                                                                                                                                │
│         ));                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Remove the bonus multiplier                                                                                                                                                                          │
│         userCurrentBonusRatio = 0;                                                                                                                                                                              │
│         userBonusRatioDecrease = 0;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Set the user Lock as an empty Lock                                                                                                                                                                   │
│         userLocks.push(UserLock(                                                                                                                                                                                │
│             safe128(0),                                                                                                                                                                                         │
│             safe48(block.timestamp),                                                                                                                                                                            │
│             safe48(0),                                                                                                                                                                                          │
│             safe32(block.number)                                                                                                                                                                                │
│         ));                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         emit Unlock(user, currentUserLock.amount, currentTotalLocked);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function _kick(address user, address kicker) internal {                                                                                                                                                     │
│         require(user != address(0) && kicker != address(0), "hPAL: Address Zero");                                                                                                                              │
│         require(userLocks.length > 0, "hPAL: No Lock");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Get the user to kick current Lock                                                                                                                                                                    │
│         // and calculate the end of the Lock                                                                                                                                                                    │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         UserLock storage currentUserLock = userLocks;                                                                                                                                                           │
│         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                                 │
│                                                                                                                                                                                                                 │
│         require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");                                                                                                                                     │
│         require(currentUserLock.amount > 0, "hPAL: No Lock");                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Remove amount from total locked supply                                                                                                                                                               │
│         currentTotalLocked -= currentUserLock.amount;                                                                                                                                                           │
│         totalLocks.push(TotalLock(                                                                                                                                                                              │
│             safe224(currentTotalLocked),                                                                                                                                                                        │
│             safe32(block.number)                                                                                                                                                                                │
│         ));                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Set an empty Lock for the user                                                                                                                                                                       │
│         userLocks.push(UserLock(                                                                                                                                                                                │
│             safe128(0),                                                                                                                                                                                         │
│             safe48(block.timestamp),                                                                                                                                                                            │
│             safe48(0),                                                                                                                                                                                          │
│             safe32(block.number)                                                                                                                                                                                │
│         ));                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Remove the bonus multiplier                                                                                                                                                                          │
│         userCurrentBonusRatio = 0;                                                                                                                                                                              │
│         userBonusRatioDecrease = 0;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Calculate the penalty for the Lock                                                                                                                                                                   │
│         uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;                                                                                                                            │
│         uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;                                                                                                                                        │
│         uint256 penaltyAmount = penaltyPercent >= MAX_BPS ?                                                                                                                                                     │
│             currentUserLock.amount :                                                                                                                                                                            │
│             (currentUserLock.amount * penaltyPercent) / MAX_BPS;                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Send penalties to the kicker                                                                                                                                                                         │
│         _transfer(user, kicker, penaltyAmount);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function kick(address user) external {                                                                                                                                                                      │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(msg.sender != user, "hPAL: cannot kick yourself");                                                                                                                                              │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         // For both the user and the kicker                                                                                                                                                                     │
│         _updateUserRewards(user);                                                                                                                                                                               │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         _kick(user, msg.sender);                                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     function _kick(address user, address kicker) internal {                                                                                                                                                     │
│         require(user != address(0) && kicker != address(0), "hPAL: Address Zero");                                                                                                                              │
│         require(userLocks.length > 0, "hPAL: No Lock");                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│         // Get the user to kick current Lock                                                                                                                                                                    │
│         // and calculate the end of the Lock                                                                                                                                                                    │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         UserLock storage currentUserLock = userLocks;                                                                                                                                                           │
│         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;                                                                                                                 │
│                                                                                                                                                                                                                 │
│         require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");                                                                                                                                     │
│         require(currentUserLock.amount > 0, "hPAL: No Lock");                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│         require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Remove amount from total locked supply                                                                                                                                                               │
│         currentTotalLocked -= currentUserLock.amount;                                                                                                                                                           │
│         totalLocks.push(TotalLock(                                                                                                                                                                              │
│             safe224(currentTotalLocked),                                                                                                                                                                        │
│             safe32(block.number)                                                                                                                                                                                │
│         ));                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Set an empty Lock for the user                                                                                                                                                                       │
│         userLocks.push(UserLock(                                                                                                                                                                                │
│             safe128(0),                                                                                                                                                                                         │
│             safe48(block.timestamp),                                                                                                                                                                            │
│             safe48(0),                                                                                                                                                                                          │
│             safe32(block.number)                                                                                                                                                                                │
│         ));                                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│         // Remove the bonus multiplier                                                                                                                                                                          │
│         userCurrentBonusRatio = 0;                                                                                                                                                                              │
│         userBonusRatioDecrease = 0;                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│         // Calculate the penalty for the Lock                                                                                                                                                                   │
│         uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;                                                                                                                            │
│         uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;                                                                                                                                        │
│         uint256 penaltyAmount = penaltyPercent >= MAX_BPS ?                                                                                                                                                     │
│             currentUserLock.amount :                                                                                                                                                                            │
│             (currentUserLock.amount * penaltyPercent) / MAX_BPS;                                                                                                                                                │
│                                                                                                                                                                                                                 │
│         // Send penalties to the kicker                                                                                                                                                                         │
│         _transfer(user, kicker, penaltyAmount);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);                                                                                                                     │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that invoke user checkpoint,                                                                                                                                                        │
│ Code:                                                                                                                                                                                                           │
│     function _delegate(address delegator, address delegatee) internal {                                                                                                                                         │
│         // Move delegation from the old delegate to the given delegate                                                                                                                                          │
│         address oldDelegatee = delegates;                                                                                                                                                                       │
│         uint256 delegatorBalance = balanceOf(delegator);                                                                                                                                                        │
│         delegates = delegatee;                                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // update the the Delegate chekpoint for the delegatee                                                                                                                                                  │
│         delegateCheckpoints.push(DelegateCheckpoint(safe32(block.number), delegatee));                                                                                                                          │
│                                                                                                                                                                                                                 │
│         emit DelegateChanged(delegator, oldDelegatee, delegatee);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // and write the checkpoints for Votes                                                                                                                                                                  │
│         _moveDelegates(oldDelegatee, delegatee, delegatorBalance);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {                                                                                                                 │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         require(userLocks.length != 0, "hPAL: No Lock");                                                                                                                                                        │
│         // Find the current Lock                                                                                                                                                                                │
│         uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                    │
│         uint256 previousLockAmount = userLocks.amount;                                                                                                                                                          │
│         // Stake the new amount                                                                                                                                                                                 │
│         uint256 stakedAmount = _stake(msg.sender, amount);                                                                                                                                                      │
│         // No need to update user rewards since it's done through the _stake() method                                                                                                                           │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // Then update the lock with the new increased amount                                                                                                                                                   │
│         if(duration == userLocks.duration) {                                                                                                                                                                    │
│             _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);                                                                                                               │
│         } else {                                                                                                                                                                                                │
│             _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);                                                                                                                          │
│         }                                                                                                                                                                                                       │
│         return stakedAmount;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _delegate(address delegator, address delegatee) internal {                                                                                                                                         │
│         // Move delegation from the old delegate to the given delegate                                                                                                                                          │
│         address oldDelegatee = delegates;                                                                                                                                                                       │
│         uint256 delegatorBalance = balanceOf(delegator);                                                                                                                                                        │
│         delegates = delegatee;                                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // update the the Delegate chekpoint for the delegatee                                                                                                                                                  │
│         delegateCheckpoints.push(DelegateCheckpoint(safe32(block.number), delegatee));                                                                                                                          │
│                                                                                                                                                                                                                 │
│         emit DelegateChanged(delegator, oldDelegatee, delegatee);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // and write the checkpoints for Votes                                                                                                                                                                  │
│         _moveDelegates(oldDelegatee, delegatee, delegatorBalance);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {                                                                                                                         │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         // Stake the given amount                                                                                                                                                                               │
│         uint256 stakedAmount = _stake(msg.sender, amount);                                                                                                                                                      │
│         // No need to update user rewards since it's done through the _stake() method                                                                                                                           │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         // And then lock it                                                                                                                                                                                     │
│         _lock(msg.sender, amount, duration, LockAction.LOCK);                                                                                                                                                   │
│         return stakedAmount;                                                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│     function _delegate(address delegator, address delegatee) internal {                                                                                                                                         │
│         // Move delegation from the old delegate to the given delegate                                                                                                                                          │
│         address oldDelegatee = delegates;                                                                                                                                                                       │
│         uint256 delegatorBalance = balanceOf(delegator);                                                                                                                                                        │
│         delegates = delegatee;                                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // update the the Delegate chekpoint for the delegatee                                                                                                                                                  │
│         delegateCheckpoints.push(DelegateCheckpoint(safe32(block.number), delegatee));                                                                                                                          │
│                                                                                                                                                                                                                 │
│         emit DelegateChanged(delegator, oldDelegatee, delegatee);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // and write the checkpoints for Votes                                                                                                                                                                  │
│         _moveDelegates(oldDelegatee, delegatee, delegatorBalance);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function lock(uint256 amount, uint256 duration) external {                                                                                                                                                  │
│         if(emergency) revert EmergencyBlock();                                                                                                                                                                  │
│         // Update user rewards before any change on their balance (staked and locked)                                                                                                                           │
│         _updateUserRewards(msg.sender);                                                                                                                                                                         │
│         if(delegates == address(0)){                                                                                                                                                                            │
│             // If the user does not deelegate currently, automatically self-delegate                                                                                                                            │
│             _delegate(msg.sender, msg.sender);                                                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│         _lock(msg.sender, amount, duration, LockAction.LOCK);                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     function _delegate(address delegator, address delegatee) internal {                                                                                                                                         │
│         // Move delegation from the old delegate to the given delegate                                                                                                                                          │
│         address oldDelegatee = delegates;                                                                                                                                                                       │
│         uint256 delegatorBalance = balanceOf(delegator);                                                                                                                                                        │
│         delegates = delegatee;                                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         // update the the Delegate chekpoint for the delegatee                                                                                                                                                  │
│         delegateCheckpoints.push(DelegateCheckpoint(safe32(block.number), delegatee));                                                                                                                          │
│                                                                                                                                                                                                                 │
│         emit DelegateChanged(delegator, oldDelegatee, delegatee);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         // and write the checkpoints for Votes                                                                                                                                                                  │
│         _moveDelegates(oldDelegatee, delegatee, delegatorBalance);                                                                                                                                              │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {                                                                                                                    │
│                                                                                                                                                                                                                 │
│         require(emergency, "hPAL: Not emergency");                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         require(amount > 0, "hPAL: Null amount");                                                                                                                                                               │
│         require(receiver != address(0), "hPAL: Address Zero");                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│         if(userLocks.length != 0){                                                                                                                                                                              │
│             // Check if the user has a Lock, and if so, fetch it                                                                                                                                                │
│             uint256 currentUserLockIndex = userLocks.length - 1;                                                                                                                                                │
│             UserLock storage currentUserLock = userLocks;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│             // To remove the Lock and update the total locked                                                                                                                                                   │
│             currentTotalLocked -= currentUserLock.amount;                                                                                                                                                       │
│             totalLocks.push(TotalLock(                                                                                                                                                                          │
│                 safe224(currentTotalLocked),                                                                                                                                                                    │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│             userLocks.push(UserLock(                                                                                                                                                                            │
│                 safe128(0),                                                                                                                                                                                     │
│                 safe48(block.timestamp),                                                                                                                                                                        │
│                 safe48(0),                                                                                                                                                                                      │
│                 safe32(block.number)                                                                                                                                                                            │
│             ));                                                                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger                                                                                             │
│         uint256 userAvailableBalance = balanceOf(msg.sender);                                                                                                                                                   │
│         uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;                                                                                                                     │
│                                                                                                                                                                                                                 │
│         _burn(msg.sender, burnAmount);                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         // Transfer the PAL to the user                                                                                                                                                                         │
│         pal.safeTransfer(receiver, burnAmount);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│         emit EmergencyUnstake(msg.sender, burnAmount);                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│         return burnAmount;                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balanceOf": "Function that holds the custom token balance calculation"                                                                                                                                 │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "N/A": "No variable holds the calculated value/price of LP token in this function"                                                                                                                      │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:41:58] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-03-paladin-main/contracts/HolyPaladinToken.sol, current      tasks.py:260
                             function: _availableBalanceOf, current vul: price-manipulation                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "userStakedBalance": "Holds the user's staked balance for calculating rewards",                                                                                                                             │
│     "userLockedBalance": "Holds the user's locked balance for calculating rewards"                                                                                                                              │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "newBonusRatio": "Holds the calculated new bonus ratio for locking rewards"                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:41:59] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-03-paladin-main/contracts/HolyPaladinToken.sol, current      tasks.py:359
                             function: _availableBalanceOf, current vul: price-manipulation                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "userStakedBalance": "Variable holding the user's staked balance"                                                                                                                                           │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "accruedRewards": "Variable holding the calculated accrued rewards"                                                                                                                                         │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:42:00] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-03-paladin-main/contracts/HolyPaladinToken.sol, current      tasks.py:260
                             function: _getUserAccruedRewards, current vul: price-manipulation                                                                                                                     
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to invoke user checkpoint? Answer only ZERO or ONE statement, cover the code with backquotes.                                  │
│ Code:                                                                                                                                                                                                           │
│     function _moveDelegates(address from, address to, uint256 amount) internal {                                                                                                                                │
│         if (from != to && amount > 0) {                                                                                                                                                                         │
│             if (from != address(0)) {                                                                                                                                                                           │
│                 // Calculate the change in voting power, then write a new checkpoint                                                                                                                            │
│                 uint256 nbCheckpoints = checkpoints.length;                                                                                                                                                     │
│                 uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints.votes;                                                                                                                                  │
│                 uint256 newVotes = oldVotes - amount;                                                                                                                                                           │
│                 _writeCheckpoint(from, newVotes);                                                                                                                                                               │
│                 emit DelegateVotesChanged(from, oldVotes, newVotes);                                                                                                                                            │
│             }                                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│             if (to != address(0)) {                                                                                                                                                                             │
│                 // Calculate the change in voting power, then write a new checkpoint                                                                                                                            │
│                 uint256 nbCheckpoints = checkpoints.length;                                                                                                                                                     │
│                 uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints.votes;                                                                                                                                  │
│                 uint256 newVotes = oldVotes + amount;                                                                                                                                                           │
│                 _writeCheckpoint(to, newVotes);                                                                                                                                                                 │
│                 emit DelegateVotesChanged(to, oldVotes, newVotes);                                                                                                                                              │
│             }                                                                                                                                                                                                   │
│         }                                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `ONE statement`                                                                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-03-paladin-main/contracts/HolyPaladinToken.sol, current      tasks.py:260
                             function: _moveDelegates, current vul: wrong-order-checkpoint                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "currentTotalLocked": "Holds the value of total minted share or amount"                                                                                                                                 │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "currentTotalLocked": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                   │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:42:01] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-03-paladin-main/contracts/HolyPaladinToken.sol, current      tasks.py:260
                             function: _lock, current vul: first-deposit                                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "amount": "Holds the value of total minted share or amount"                                                                                                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "userLocks": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                            │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:42:03] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-03-paladin-main/contracts/HolyPaladinToken.sol, current      tasks.py:359
                             function: _lock, current vul: first-deposit                                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                    Summary                    
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value                ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 14                   │
│ Contracts            │ 14                   │
│ Functions            │ 55                   │
│ Lines of Code        │ 2597                 │
│ Used Time            │ 30.1832537651062     │
│ Estimated Cost (USD) │ 0.051544000000000006 │
└──────────────────────┴──────────────────────┘
